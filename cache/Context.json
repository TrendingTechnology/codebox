{"Name":"context","PkgPath":"context","PkgName":"context","ID":"context","Funcs":[{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Background","Signature":"func Background() Context","ID":"FunctionBackground","Docs":["Background returns a non-nil, empty Context. It is never canceled, has no","values, and has no deadline. It is typically used by the main function,","initialization, and tests, and as the top-level Context for incoming","requests."],"Name":"Background","PkgPath":"context","PkgName":"context","Parameters":null,"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"Context","PkgName":"context","PkgPath":"context","QualifiedName":"context.Context","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"TODO","Signature":"func TODO() Context","ID":"FunctionTODO","Docs":["TODO returns a non-nil, empty Context. Code should use context.TODO when","it's unclear which Context to use or it is not yet available (because the","surrounding function has not yet been extended to accept a Context","parameter)."],"Name":"TODO","PkgPath":"context","PkgName":"context","Parameters":null,"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"Context","PkgName":"context","PkgPath":"context","QualifiedName":"context.Context","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]},{"CodeQL":{"IsEnabled":true,"Pointers":{"Inp":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"Outp":{"Placeholder":"isResult(0)","Element":"result","Index":0}}},"ClassName":"WithCancel","Signature":"func WithCancel(parent Context) (ctx Context, cancel CancelFunc)","ID":"FunctionWithCancel","Docs":["WithCancel returns a copy of parent with a new Done channel. The returned","context's Done channel is closed when the returned cancel function is called","or when the parent context's Done channel is closed, whichever happens first.","","Canceling this context releases resources associated with it, so code should","call cancel as soon as the operations running in this Context complete."],"Name":"WithCancel","PkgPath":"context","PkgName":"context","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"parent","TypeName":"Context","PkgName":"context","PkgPath":"context","QualifiedName":"context.Context","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult(0)","Element":"result","Index":0},"VarName":"ctx","TypeName":"Context","PkgName":"context","PkgPath":"context","QualifiedName":"context.Context","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isResult(1)","Element":"result","Index":1},"VarName":"cancel","TypeName":"CancelFunc","PkgName":"context","PkgPath":"context","QualifiedName":"context.CancelFunc","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]},{"CodeQL":{"IsEnabled":true,"Pointers":{"Inp":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"Outp":{"Placeholder":"isResult(0)","Element":"result","Index":0}}},"ClassName":"WithDeadline","Signature":"func WithDeadline(parent Context, d time.Time) (Context, CancelFunc)","ID":"FunctionWithDeadline","Docs":["WithDeadline returns a copy of the parent context with the deadline adjusted","to be no later than d. If the parent's deadline is already earlier than d,","WithDeadline(parent, d) is semantically equivalent to parent. The returned","context's Done channel is closed when the deadline expires, when the returned","cancel function is called, or when the parent context's Done channel is","closed, whichever happens first.","","Canceling this context releases resources associated with it, so code should","call cancel as soon as the operations running in this Context complete."],"Name":"WithDeadline","PkgPath":"context","PkgName":"context","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"parent","TypeName":"Context","PkgName":"context","PkgPath":"context","QualifiedName":"context.Context","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"VarName":"d","TypeName":"Time","PkgName":"time","PkgPath":"time","QualifiedName":"time.Time","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":true,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult(0)","Element":"result","Index":0},"VarName":"into564","TypeName":"Context","PkgName":"context","PkgPath":"context","QualifiedName":"context.Context","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isResult(1)","Element":"result","Index":1},"VarName":"","TypeName":"CancelFunc","PkgName":"context","PkgPath":"context","QualifiedName":"context.CancelFunc","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]},{"CodeQL":{"IsEnabled":true,"Pointers":{"Inp":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"Outp":{"Placeholder":"isResult(0)","Element":"result","Index":0}}},"ClassName":"WithTimeout","Signature":"func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc)","ID":"FunctionWithTimeout","Docs":["WithTimeout returns WithDeadline(parent, time.Now().Add(timeout)).","","Canceling this context releases resources associated with it, so code should","call cancel as soon as the operations running in this Context complete:","","\tfunc slowOperationWithTimeout(ctx context.Context) (Result, error) {","\t\tctx, cancel := context.WithTimeout(ctx, 100*time.Millisecond)","\t\tdefer cancel()  // releases resources if slowOperation completes before timeout elapses","\t\treturn slowOperation(ctx)","\t}"],"Name":"WithTimeout","PkgPath":"context","PkgName":"context","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"parent","TypeName":"Context","PkgName":"context","PkgPath":"context","QualifiedName":"context.Context","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"VarName":"timeout","TypeName":"Duration","PkgName":"time","PkgPath":"time","QualifiedName":"time.Duration","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult(0)","Element":"result","Index":0},"VarName":"into540","TypeName":"Context","PkgName":"context","PkgPath":"context","QualifiedName":"context.Context","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isResult(1)","Element":"result","Index":1},"VarName":"","TypeName":"CancelFunc","PkgName":"context","PkgPath":"context","QualifiedName":"context.CancelFunc","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]},{"CodeQL":{"IsEnabled":true,"Pointers":{"Inp":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"Outp":{"Placeholder":"isResult()","Element":"result","Index":0}}},"ClassName":"WithValue","Signature":"func WithValue(parent Context, key interface{}, val interface{}) Context","ID":"FunctionWithValue","Docs":["WithValue returns a copy of parent in which the value associated with key is","val.","","Use context Values only for request-scoped data that transits processes and","APIs, not for passing optional parameters to functions.","","The provided key must be comparable and should not be of type","string or any other built-in type to avoid collisions between","packages using context. Users of WithValue should define their own","types for keys. To avoid allocating when assigning to an","interface{}, context keys often have concrete type","struct{}. Alternatively, exported context key variables' static","type should be a pointer or interface."],"Name":"WithValue","PkgPath":"context","PkgName":"context","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"parent","TypeName":"Context","PkgName":"context","PkgPath":"context","QualifiedName":"context.Context","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"VarName":"key","TypeName":"interface{}","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(2)","Element":"parameter","Index":2},"VarName":"val","TypeName":"interface{}","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"into145","TypeName":"Context","PkgName":"context","PkgPath":"context","QualifiedName":"context.Context","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]}],"TypeMethods":[],"InterfaceMethods":[{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"ContextDeadline","Docs":["Deadline returns the time when work done on behalf of this context","should be canceled. Deadline returns ok==false when no deadline is","set. Successive calls to Deadline return the same results."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Context","PkgName":"context","PkgPath":"context","QualifiedName":"context.Deadline","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"interface-method-Context-Deadline","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Deadline","Signature":"func (Context).Deadline() (deadline time.Time, ok bool)","ID":"FunctionDeadline","Docs":["Deadline returns the time when work done on behalf of this context","should be canceled. Deadline returns ok==false when no deadline is","set. Successive calls to Deadline return the same results."],"Name":"Deadline","PkgPath":"context","PkgName":"context","Parameters":null,"Results":[{"Identity":{"Placeholder":"isResult(0)","Element":"result","Index":0},"VarName":"deadline","TypeName":"Time","PkgName":"time","PkgPath":"time","QualifiedName":"time.Time","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":true,"IsRepeated":false},{"Identity":{"Placeholder":"isResult(1)","Element":"result","Index":1},"VarName":"ok","TypeName":"bool","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"ContextDone","Docs":["Done returns a channel that's closed when work done on behalf of this","context should be canceled. Done may return nil if this context can","never be canceled. Successive calls to Done return the same value.","The close of the Done channel may happen asynchronously,","after the cancel function returns.","","WithCancel arranges for Done to be closed when cancel is called;","WithDeadline arranges for Done to be closed when the deadline","expires; WithTimeout arranges for Done to be closed when the timeout","elapses.","","Done is provided for use in select statements:",""," // Stream generates values with DoSomething and sends them to out"," // until DoSomething returns an error or ctx.Done is closed."," func Stream(ctx context.Context, out chan\u003c- Value) error {"," \tfor {"," \t\tv, err := DoSomething(ctx)"," \t\tif err != nil {"," \t\t\treturn err"," \t\t}"," \t\tselect {"," \t\tcase \u003c-ctx.Done():"," \t\t\treturn ctx.Err()"," \t\tcase out \u003c- v:"," \t\t}"," \t}"," }","","See https://blog.golang.org/pipelines for more examples of how to use","a Done channel for cancellation."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Context","PkgName":"context","PkgPath":"context","QualifiedName":"context.Done","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"interface-method-Context-Done","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Done","Signature":"func (Context).Done() \u003c-chan struct{}","ID":"FunctionDone","Docs":["Done returns a channel that's closed when work done on behalf of this","context should be canceled. Done may return nil if this context can","never be canceled. Successive calls to Done return the same value.","The close of the Done channel may happen asynchronously,","after the cancel function returns.","","WithCancel arranges for Done to be closed when cancel is called;","WithDeadline arranges for Done to be closed when the deadline","expires; WithTimeout arranges for Done to be closed when the timeout","elapses.","","Done is provided for use in select statements:",""," // Stream generates values with DoSomething and sends them to out"," // until DoSomething returns an error or ctx.Done is closed."," func Stream(ctx context.Context, out chan\u003c- Value) error {"," \tfor {"," \t\tv, err := DoSomething(ctx)"," \t\tif err != nil {"," \t\t\treturn err"," \t\t}"," \t\tselect {"," \t\tcase \u003c-ctx.Done():"," \t\t\treturn ctx.Err()"," \t\tcase out \u003c- v:"," \t\t}"," \t}"," }","","See https://blog.golang.org/pipelines for more examples of how to use","a Done channel for cancellation."],"Name":"Done","PkgPath":"context","PkgName":"context","Parameters":null,"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"\u003c-chan struct{}","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"ContextErr","Docs":["If Done is not yet closed, Err returns nil.","If Done is closed, Err returns a non-nil error explaining why:","Canceled if the context was canceled","or DeadlineExceeded if the context's deadline passed.","After Err returns a non-nil error, successive calls to Err return the same error."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Context","PkgName":"context","PkgPath":"context","QualifiedName":"context.Err","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"interface-method-Context-Err","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Err","Signature":"func (Context).Err() error","ID":"FunctionErr","Docs":["If Done is not yet closed, Err returns nil.","If Done is closed, Err returns a non-nil error explaining why:","Canceled if the context was canceled","or DeadlineExceeded if the context's deadline passed.","After Err returns a non-nil error, successive calls to Err return the same error."],"Name":"Err","PkgPath":"context","PkgName":"context","Parameters":null,"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":true,"Pointers":{"Inp":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"Outp":{"Placeholder":"isResult()","Element":"result","Index":0}}},"ClassName":"ContextValue","Docs":["Value returns the value associated with this context for key, or nil","if no value is associated with key. Successive calls to Value with","the same key returns the same result.","","Use context values only for request-scoped data that transits","processes and API boundaries, not for passing optional parameters to","functions.","","A key identifies a specific value in a Context. Functions that wish","to store values in Context typically allocate a key in a global","variable then use that key as the argument to context.WithValue and","Context.Value. A key can be any type that supports equality;","packages should define keys as an unexported type to avoid","collisions.","","Packages that define a Context key should provide type-safe accessors","for the values stored using that key:","","\t// Package user defines a User type that's stored in Contexts.","\tpackage user","","\timport \"context\"","","\t// User is the type of value stored in the Contexts.","\ttype User struct {...}","","\t// key is an unexported type for keys defined in this package.","\t// This prevents collisions with keys defined in other packages.","\ttype key int","","\t// userKey is the key for user.User values in Contexts. It is","\t// unexported; clients use user.NewContext and user.FromContext","\t// instead of using this key directly.","\tvar userKey key","","\t// NewContext returns a new Context that carries value u.","\tfunc NewContext(ctx context.Context, u *User) context.Context {","\t\treturn context.WithValue(ctx, userKey, u)","\t}","","\t// FromContext returns the User value stored in ctx, if any.","\tfunc FromContext(ctx context.Context) (*User, bool) {","\t\tu, ok := ctx.Value(userKey).(*User)","\t\treturn u, ok","\t}"],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"from948","TypeName":"Context","PkgName":"context","PkgPath":"context","QualifiedName":"context.Value","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"interface-method-Context-Value","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Value","Signature":"func (Context).Value(key interface{}) interface{}","ID":"FunctionValue","Docs":["Value returns the value associated with this context for key, or nil","if no value is associated with key. Successive calls to Value with","the same key returns the same result.","","Use context values only for request-scoped data that transits","processes and API boundaries, not for passing optional parameters to","functions.","","A key identifies a specific value in a Context. Functions that wish","to store values in Context typically allocate a key in a global","variable then use that key as the argument to context.WithValue and","Context.Value. A key can be any type that supports equality;","packages should define keys as an unexported type to avoid","collisions.","","Packages that define a Context key should provide type-safe accessors","for the values stored using that key:","","\t// Package user defines a User type that's stored in Contexts.","\tpackage user","","\timport \"context\"","","\t// User is the type of value stored in the Contexts.","\ttype User struct {...}","","\t// key is an unexported type for keys defined in this package.","\t// This prevents collisions with keys defined in other packages.","\ttype key int","","\t// userKey is the key for user.User values in Contexts. It is","\t// unexported; clients use user.NewContext and user.FromContext","\t// instead of using this key directly.","\tvar userKey key","","\t// NewContext returns a new Context that carries value u.","\tfunc NewContext(ctx context.Context, u *User) context.Context {","\t\treturn context.WithValue(ctx, userKey, u)","\t}","","\t// FromContext returns the User value stored in ctx, if any.","\tfunc FromContext(ctx context.Context) (*User, bool) {","\t\tu, ok := ctx.Value(userKey).(*User)","\t\treturn u, ok","\t}"],"Name":"Value","PkgPath":"context","PkgName":"context","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"key","TypeName":"interface{}","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"into731","TypeName":"interface{}","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]}}]}