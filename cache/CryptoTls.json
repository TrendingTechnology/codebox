{"Name":"tls","PkgPath":"crypto/tls","PkgName":"tls","ID":"crypto/tls","Funcs":[{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"CipherSuiteName","Signature":"func CipherSuiteName(id uint16) string","ID":"FunctionCipherSuiteName","Docs":["CipherSuiteName returns the standard name for the passed cipher suite ID","(e.g. \"TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256\"), or a fallback representation","of the ID value if the cipher suite is not implemented by this package."],"Name":"CipherSuiteName","PkgPath":"crypto/tls","PkgName":"tls","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"id","TypeName":"uint16","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}]},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"CipherSuites","Signature":"func CipherSuites() []*CipherSuite","ID":"FunctionCipherSuites","Docs":["CipherSuites returns a list of cipher suites currently implemented by this","package, excluding those with security issues, which are returned by","InsecureCipherSuites.","","The list is sorted by ID. Note that the default cipher suites selected by","this package might depend on logic that can't be captured by a static list."],"Name":"CipherSuites","PkgPath":"crypto/tls","PkgName":"tls","Parameters":null,"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"CipherSuite","PkgName":"tls","PkgPath":"crypto/tls","QualifiedName":"crypto/tls.CipherSuite","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":true}]},{"CodeQL":{"IsEnabled":true,"Pointers":{"Inp":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"Outp":{"Placeholder":"isResult()","Element":"result","Index":0}}},"ClassName":"Client","Signature":"func Client(conn net.Conn, config *Config) *Conn","ID":"FunctionClient","Docs":["Client returns a new TLS client side connection","using conn as the underlying transport.","The config cannot be nil: users must set either ServerName or","InsecureSkipVerify in the config."],"Name":"Client","PkgPath":"crypto/tls","PkgName":"tls","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"conn","TypeName":"Conn","PkgName":"net","PkgPath":"net","QualifiedName":"net.Conn","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"VarName":"config","TypeName":"Config","PkgName":"tls","PkgPath":"crypto/tls","QualifiedName":"crypto/tls.Config","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":true,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"into366","TypeName":"Conn","PkgName":"tls","PkgPath":"crypto/tls","QualifiedName":"crypto/tls.Conn","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":true,"IsRepeated":false}]},{"CodeQL":{"IsEnabled":true,"Pointers":{"Inp":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"Outp":{"Placeholder":"isResult(0)","Element":"result","Index":0}}},"ClassName":"Dial","Signature":"func Dial(network string, addr string, config *Config) (*Conn, error)","ID":"FunctionDial","Docs":["Dial connects to the given network address using net.Dial","and then initiates a TLS handshake, returning the resulting","TLS connection.","Dial interprets a nil configuration as equivalent to","the zero configuration; see the documentation of Config","for the defaults."],"Name":"Dial","PkgPath":"crypto/tls","PkgName":"tls","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"network","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"VarName":"addr","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(2)","Element":"parameter","Index":2},"VarName":"config","TypeName":"Config","PkgName":"tls","PkgPath":"crypto/tls","QualifiedName":"crypto/tls.Config","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":true,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult(0)","Element":"result","Index":0},"VarName":"into507","TypeName":"Conn","PkgName":"tls","PkgPath":"crypto/tls","QualifiedName":"crypto/tls.Conn","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":true,"IsRepeated":false},{"Identity":{"Placeholder":"isResult(1)","Element":"result","Index":1},"VarName":"","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]},{"CodeQL":{"IsEnabled":true,"Pointers":{"Inp":{"Placeholder":"isParameter(2)","Element":"parameter","Index":2},"Outp":{"Placeholder":"isResult(0)","Element":"result","Index":0}}},"ClassName":"DialWithDialer","Signature":"func DialWithDialer(dialer *net.Dialer, network string, addr string, config *Config) (*Conn, error)","ID":"FunctionDialWithDialer","Docs":["DialWithDialer connects to the given network address using dialer.Dial and","then initiates a TLS handshake, returning the resulting TLS connection. Any","timeout or deadline given in the dialer apply to connection and TLS","handshake as a whole.","","DialWithDialer interprets a nil configuration as equivalent to the zero","configuration; see the documentation of Config for the defaults."],"Name":"DialWithDialer","PkgPath":"crypto/tls","PkgName":"tls","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"dialer","TypeName":"Dialer","PkgName":"net","PkgPath":"net","QualifiedName":"net.Dialer","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":true,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"VarName":"network","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(2)","Element":"parameter","Index":2},"VarName":"addr","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(3)","Element":"parameter","Index":3},"VarName":"config","TypeName":"Config","PkgName":"tls","PkgPath":"crypto/tls","QualifiedName":"crypto/tls.Config","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":true,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult(0)","Element":"result","Index":0},"VarName":"into419","TypeName":"Conn","PkgName":"tls","PkgPath":"crypto/tls","QualifiedName":"crypto/tls.Conn","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":true,"IsRepeated":false},{"Identity":{"Placeholder":"isResult(1)","Element":"result","Index":1},"VarName":"","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"InsecureCipherSuites","Signature":"func InsecureCipherSuites() []*CipherSuite","ID":"FunctionInsecureCipherSuites","Docs":["InsecureCipherSuites returns a list of cipher suites currently implemented by","this package and which have security issues.","","Most applications should not use the cipher suites in this list, and should","only use those returned by CipherSuites."],"Name":"InsecureCipherSuites","PkgPath":"crypto/tls","PkgName":"tls","Parameters":null,"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"CipherSuite","PkgName":"tls","PkgPath":"crypto/tls","QualifiedName":"crypto/tls.CipherSuite","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":true}]},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Listen","Signature":"func Listen(network string, laddr string, config *Config) (net.Listener, error)","ID":"FunctionListen","Docs":["Listen creates a TLS listener accepting connections on the","given network address using net.Listen.","The configuration config must be non-nil and must include","at least one certificate or else set GetCertificate."],"Name":"Listen","PkgPath":"crypto/tls","PkgName":"tls","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"network","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"VarName":"laddr","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(2)","Element":"parameter","Index":2},"VarName":"config","TypeName":"Config","PkgName":"tls","PkgPath":"crypto/tls","QualifiedName":"crypto/tls.Config","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":true,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult(0)","Element":"result","Index":0},"VarName":"","TypeName":"Listener","PkgName":"net","PkgPath":"net","QualifiedName":"net.Listener","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isResult(1)","Element":"result","Index":1},"VarName":"","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"LoadX509KeyPair","Signature":"func LoadX509KeyPair(certFile string, keyFile string) (Certificate, error)","ID":"FunctionLoadX509KeyPair","Docs":["LoadX509KeyPair reads and parses a public/private key pair from a pair","of files. The files must contain PEM encoded data. The certificate file","may contain intermediate certificates following the leaf certificate to","form a certificate chain. On successful return, Certificate.Leaf will","be nil because the parsed form of the certificate is not retained."],"Name":"LoadX509KeyPair","PkgPath":"crypto/tls","PkgName":"tls","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"certFile","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"VarName":"keyFile","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult(0)","Element":"result","Index":0},"VarName":"","TypeName":"Certificate","PkgName":"tls","PkgPath":"crypto/tls","QualifiedName":"crypto/tls.Certificate","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":true,"IsRepeated":false},{"Identity":{"Placeholder":"isResult(1)","Element":"result","Index":1},"VarName":"","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"NewLRUClientSessionCache","Signature":"func NewLRUClientSessionCache(capacity int) ClientSessionCache","ID":"FunctionNewLRUClientSessionCache","Docs":["NewLRUClientSessionCache returns a ClientSessionCache with the given","capacity that uses an LRU strategy. If capacity is \u003c 1, a default capacity","is used instead."],"Name":"NewLRUClientSessionCache","PkgPath":"crypto/tls","PkgName":"tls","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"capacity","TypeName":"int","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"ClientSessionCache","PkgName":"tls","PkgPath":"crypto/tls","QualifiedName":"crypto/tls.ClientSessionCache","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]},{"CodeQL":{"IsEnabled":true,"Pointers":{"Inp":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"Outp":{"Placeholder":"isResult()","Element":"result","Index":0}}},"ClassName":"NewListener","Signature":"func NewListener(inner net.Listener, config *Config) net.Listener","ID":"FunctionNewListener","Docs":["NewListener creates a Listener which accepts connections from an inner","Listener and wraps each connection with Server.","The configuration config must be non-nil and must include","at least one certificate or else set GetCertificate."],"Name":"NewListener","PkgPath":"crypto/tls","PkgName":"tls","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"inner","TypeName":"Listener","PkgName":"net","PkgPath":"net","QualifiedName":"net.Listener","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"VarName":"config","TypeName":"Config","PkgName":"tls","PkgPath":"crypto/tls","QualifiedName":"crypto/tls.Config","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":true,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"into778","TypeName":"Listener","PkgName":"net","PkgPath":"net","QualifiedName":"net.Listener","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]},{"CodeQL":{"IsEnabled":true,"Pointers":{"Inp":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"Outp":{"Placeholder":"isResult()","Element":"result","Index":0}}},"ClassName":"Server","Signature":"func Server(conn net.Conn, config *Config) *Conn","ID":"FunctionServer","Docs":["Server returns a new TLS server side connection","using conn as the underlying transport.","The configuration config must be non-nil and must include","at least one certificate or else set GetCertificate."],"Name":"Server","PkgPath":"crypto/tls","PkgName":"tls","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"conn","TypeName":"Conn","PkgName":"net","PkgPath":"net","QualifiedName":"net.Conn","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"VarName":"config","TypeName":"Config","PkgName":"tls","PkgPath":"crypto/tls","QualifiedName":"crypto/tls.Config","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":true,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"into901","TypeName":"Conn","PkgName":"tls","PkgPath":"crypto/tls","QualifiedName":"crypto/tls.Conn","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":true,"IsRepeated":false}]},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"X509KeyPair","Signature":"func X509KeyPair(certPEMBlock []byte, keyPEMBlock []byte) (Certificate, error)","ID":"FunctionX509KeyPair","Docs":["X509KeyPair parses a public/private key pair from a pair of","PEM encoded data. On successful return, Certificate.Leaf will be nil because","the parsed form of the certificate is not retained."],"Name":"X509KeyPair","PkgPath":"crypto/tls","PkgName":"tls","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"certPEMBlock","TypeName":"byte","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":true},{"Identity":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"VarName":"keyPEMBlock","TypeName":"byte","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":true}],"Results":[{"Identity":{"Placeholder":"isResult(0)","Element":"result","Index":0},"VarName":"","TypeName":"Certificate","PkgName":"tls","PkgPath":"crypto/tls","QualifiedName":"crypto/tls.Certificate","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":true,"IsRepeated":false},{"Identity":{"Placeholder":"isResult(1)","Element":"result","Index":1},"VarName":"","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]}],"TypeMethods":[{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"CertificateRequestInfoSupportsCertificate","Docs":["SupportsCertificate returns nil if the provided certificate is supported by","the server that sent the CertificateRequest. Otherwise, it returns an error","describing the reason for the incompatibility."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"CertificateRequestInfo","PkgName":"tls","PkgPath":"crypto/tls","QualifiedName":"crypto/tls.CertificateRequestInfo","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-CertificateRequestInfo-SupportsCertificate","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"SupportsCertificate","Signature":"func (*CertificateRequestInfo).SupportsCertificate(c *Certificate) error","ID":"FunctionSupportsCertificate","Docs":["SupportsCertificate returns nil if the provided certificate is supported by","the server that sent the CertificateRequest. Otherwise, it returns an error","describing the reason for the incompatibility."],"Name":"SupportsCertificate","PkgPath":"crypto/tls","PkgName":"tls","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"c","TypeName":"Certificate","PkgName":"tls","PkgPath":"crypto/tls","QualifiedName":"crypto/tls.Certificate","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":true,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"ClientHelloInfoSupportsCertificate","Docs":["SupportsCertificate returns nil if the provided certificate is supported by","the client that sent the ClientHello. Otherwise, it returns an error","describing the reason for the incompatibility.","","If this ClientHelloInfo was passed to a GetConfigForClient or GetCertificate","callback, this method will take into account the associated Config. Note that","if GetConfigForClient returns a different Config, the change can't be","accounted for by this method.","","This function will call x509.ParseCertificate unless c.Leaf is set, which can","incur a significant performance cost."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"ClientHelloInfo","PkgName":"tls","PkgPath":"crypto/tls","QualifiedName":"crypto/tls.ClientHelloInfo","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-ClientHelloInfo-SupportsCertificate","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"SupportsCertificate","Signature":"func (*ClientHelloInfo).SupportsCertificate(c *Certificate) error","ID":"FunctionSupportsCertificate","Docs":["SupportsCertificate returns nil if the provided certificate is supported by","the client that sent the ClientHello. Otherwise, it returns an error","describing the reason for the incompatibility.","","If this ClientHelloInfo was passed to a GetConfigForClient or GetCertificate","callback, this method will take into account the associated Config. Note that","if GetConfigForClient returns a different Config, the change can't be","accounted for by this method.","","This function will call x509.ParseCertificate unless c.Leaf is set, which can","incur a significant performance cost."],"Name":"SupportsCertificate","PkgPath":"crypto/tls","PkgName":"tls","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"c","TypeName":"Certificate","PkgName":"tls","PkgPath":"crypto/tls","QualifiedName":"crypto/tls.Certificate","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":true,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"ConfigBuildNameToCertificate","Docs":["BuildNameToCertificate parses c.Certificates and builds c.NameToCertificate","from the CommonName and SubjectAlternateName fields of each of the leaf","certificates.","","Deprecated: NameToCertificate only allows associating a single certificate","with a given name. Leave that field nil to let the library select the first","compatible chain from Certificates."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Config","PkgName":"tls","PkgPath":"crypto/tls","QualifiedName":"crypto/tls.Config","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Config-BuildNameToCertificate","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"BuildNameToCertificate","Signature":"func (*Config).BuildNameToCertificate()","ID":"FunctionBuildNameToCertificate","Docs":["BuildNameToCertificate parses c.Certificates and builds c.NameToCertificate","from the CommonName and SubjectAlternateName fields of each of the leaf","certificates.","","Deprecated: NameToCertificate only allows associating a single certificate","with a given name. Leave that field nil to let the library select the first","compatible chain from Certificates."],"Name":"BuildNameToCertificate","PkgPath":"crypto/tls","PkgName":"tls","Parameters":null,"Results":null}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"ConfigClone","Docs":["Clone returns a shallow clone of c. It is safe to clone a Config that is","being used concurrently by a TLS client or server."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Config","PkgName":"tls","PkgPath":"crypto/tls","QualifiedName":"crypto/tls.Config","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Config-Clone","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Clone","Signature":"func (*Config).Clone() *Config","ID":"FunctionClone","Docs":["Clone returns a shallow clone of c. It is safe to clone a Config that is","being used concurrently by a TLS client or server."],"Name":"Clone","PkgPath":"crypto/tls","PkgName":"tls","Parameters":null,"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"Config","PkgName":"tls","PkgPath":"crypto/tls","QualifiedName":"crypto/tls.Config","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":true,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"ConfigSetSessionTicketKeys","Docs":["SetSessionTicketKeys updates the session ticket keys for a server. The first","key will be used when creating new tickets, while all keys can be used for","decrypting tickets. It is safe to call this function while the server is","running in order to rotate the session ticket keys. The function will panic","if keys is empty."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Config","PkgName":"tls","PkgPath":"crypto/tls","QualifiedName":"crypto/tls.Config","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Config-SetSessionTicketKeys","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"SetSessionTicketKeys","Signature":"func (*Config).SetSessionTicketKeys(keys [][32]byte)","ID":"FunctionSetSessionTicketKeys","Docs":["SetSessionTicketKeys updates the session ticket keys for a server. The first","key will be used when creating new tickets, while all keys can be used for","decrypting tickets. It is safe to call this function while the server is","running in order to rotate the session ticket keys. The function will panic","if keys is empty."],"Name":"SetSessionTicketKeys","PkgPath":"crypto/tls","PkgName":"tls","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"keys","TypeName":"byte","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":true}],"Results":null}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"ConnClose","Docs":["Close closes the connection."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Conn","PkgName":"tls","PkgPath":"crypto/tls","QualifiedName":"crypto/tls.Conn","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Conn-Close","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Close","Signature":"func (*Conn).Close() error","ID":"FunctionClose","Docs":["Close closes the connection."],"Name":"Close","PkgPath":"crypto/tls","PkgName":"tls","Parameters":null,"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"ConnCloseWrite","Docs":["CloseWrite shuts down the writing side of the connection. It should only be","called once the handshake has completed and does not call CloseWrite on the","underlying connection. Most callers should just use Close."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Conn","PkgName":"tls","PkgPath":"crypto/tls","QualifiedName":"crypto/tls.Conn","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Conn-CloseWrite","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"CloseWrite","Signature":"func (*Conn).CloseWrite() error","ID":"FunctionCloseWrite","Docs":["CloseWrite shuts down the writing side of the connection. It should only be","called once the handshake has completed and does not call CloseWrite on the","underlying connection. Most callers should just use Close."],"Name":"CloseWrite","PkgPath":"crypto/tls","PkgName":"tls","Parameters":null,"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"ConnConnectionState","Docs":["ConnectionState returns basic TLS details about the connection."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Conn","PkgName":"tls","PkgPath":"crypto/tls","QualifiedName":"crypto/tls.Conn","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Conn-ConnectionState","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"ConnectionState","Signature":"func (*Conn).ConnectionState() ConnectionState","ID":"FunctionConnectionState","Docs":["ConnectionState returns basic TLS details about the connection."],"Name":"ConnectionState","PkgPath":"crypto/tls","PkgName":"tls","Parameters":null,"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"ConnectionState","PkgName":"tls","PkgPath":"crypto/tls","QualifiedName":"crypto/tls.ConnectionState","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":true,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"ConnHandshake","Docs":["Handshake runs the client or server handshake","protocol if it has not yet been run.","Most uses of this package need not call Handshake","explicitly: the first Read or Write will call it automatically."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Conn","PkgName":"tls","PkgPath":"crypto/tls","QualifiedName":"crypto/tls.Conn","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Conn-Handshake","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Handshake","Signature":"func (*Conn).Handshake() error","ID":"FunctionHandshake","Docs":["Handshake runs the client or server handshake","protocol if it has not yet been run.","Most uses of this package need not call Handshake","explicitly: the first Read or Write will call it automatically."],"Name":"Handshake","PkgPath":"crypto/tls","PkgName":"tls","Parameters":null,"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"ConnLocalAddr","Docs":["LocalAddr returns the local network address."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Conn","PkgName":"tls","PkgPath":"crypto/tls","QualifiedName":"crypto/tls.Conn","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Conn-LocalAddr","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"LocalAddr","Signature":"func (*Conn).LocalAddr() net.Addr","ID":"FunctionLocalAddr","Docs":["LocalAddr returns the local network address."],"Name":"LocalAddr","PkgPath":"crypto/tls","PkgName":"tls","Parameters":null,"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"Addr","PkgName":"net","PkgPath":"net","QualifiedName":"net.Addr","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"ConnOCSPResponse","Docs":["OCSPResponse returns the stapled OCSP response from the TLS server, if","any. (Only valid for client connections.)"],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Conn","PkgName":"tls","PkgPath":"crypto/tls","QualifiedName":"crypto/tls.Conn","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Conn-OCSPResponse","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"OCSPResponse","Signature":"func (*Conn).OCSPResponse() []byte","ID":"FunctionOCSPResponse","Docs":["OCSPResponse returns the stapled OCSP response from the TLS server, if","any. (Only valid for client connections.)"],"Name":"OCSPResponse","PkgPath":"crypto/tls","PkgName":"tls","Parameters":null,"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"byte","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":true}]}},{"CodeQL":{"IsEnabled":true,"Pointers":{"Inp":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"Outp":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0}}},"ClassName":"ConnRead","Docs":["Read can be made to time out and return a net.Error with Timeout() == true","after a fixed time limit; see SetDeadline and SetReadDeadline."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"from748","TypeName":"Conn","PkgName":"tls","PkgPath":"crypto/tls","QualifiedName":"crypto/tls.Conn","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Conn-Read","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Read","Signature":"func (*Conn).Read(b []byte) (int, error)","ID":"FunctionRead","Docs":["Read can be made to time out and return a net.Error with Timeout() == true","after a fixed time limit; see SetDeadline and SetReadDeadline."],"Name":"Read","PkgPath":"crypto/tls","PkgName":"tls","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"b","TypeName":"byte","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":true}],"Results":[{"Identity":{"Placeholder":"isResult(0)","Element":"result","Index":0},"VarName":"into813","TypeName":"int","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isResult(1)","Element":"result","Index":1},"VarName":"","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"ConnRemoteAddr","Docs":["RemoteAddr returns the remote network address."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Conn","PkgName":"tls","PkgPath":"crypto/tls","QualifiedName":"crypto/tls.Conn","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Conn-RemoteAddr","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"RemoteAddr","Signature":"func (*Conn).RemoteAddr() net.Addr","ID":"FunctionRemoteAddr","Docs":["RemoteAddr returns the remote network address."],"Name":"RemoteAddr","PkgPath":"crypto/tls","PkgName":"tls","Parameters":null,"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"Addr","PkgName":"net","PkgPath":"net","QualifiedName":"net.Addr","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"ConnSetDeadline","Docs":["SetDeadline sets the read and write deadlines associated with the connection.","A zero value for t means Read and Write will not time out.","After a Write has timed out, the TLS state is corrupt and all future writes will return the same error."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Conn","PkgName":"tls","PkgPath":"crypto/tls","QualifiedName":"crypto/tls.Conn","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Conn-SetDeadline","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"SetDeadline","Signature":"func (*Conn).SetDeadline(t time.Time) error","ID":"FunctionSetDeadline","Docs":["SetDeadline sets the read and write deadlines associated with the connection.","A zero value for t means Read and Write will not time out.","After a Write has timed out, the TLS state is corrupt and all future writes will return the same error."],"Name":"SetDeadline","PkgPath":"crypto/tls","PkgName":"tls","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"t","TypeName":"Time","PkgName":"time","PkgPath":"time","QualifiedName":"time.Time","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":true,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"ConnSetReadDeadline","Docs":["SetReadDeadline sets the read deadline on the underlying connection.","A zero value for t means Read will not time out."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Conn","PkgName":"tls","PkgPath":"crypto/tls","QualifiedName":"crypto/tls.Conn","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Conn-SetReadDeadline","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"SetReadDeadline","Signature":"func (*Conn).SetReadDeadline(t time.Time) error","ID":"FunctionSetReadDeadline","Docs":["SetReadDeadline sets the read deadline on the underlying connection.","A zero value for t means Read will not time out."],"Name":"SetReadDeadline","PkgPath":"crypto/tls","PkgName":"tls","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"t","TypeName":"Time","PkgName":"time","PkgPath":"time","QualifiedName":"time.Time","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":true,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"ConnSetWriteDeadline","Docs":["SetWriteDeadline sets the write deadline on the underlying connection.","A zero value for t means Write will not time out.","After a Write has timed out, the TLS state is corrupt and all future writes will return the same error."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Conn","PkgName":"tls","PkgPath":"crypto/tls","QualifiedName":"crypto/tls.Conn","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Conn-SetWriteDeadline","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"SetWriteDeadline","Signature":"func (*Conn).SetWriteDeadline(t time.Time) error","ID":"FunctionSetWriteDeadline","Docs":["SetWriteDeadline sets the write deadline on the underlying connection.","A zero value for t means Write will not time out.","After a Write has timed out, the TLS state is corrupt and all future writes will return the same error."],"Name":"SetWriteDeadline","PkgPath":"crypto/tls","PkgName":"tls","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"t","TypeName":"Time","PkgName":"time","PkgPath":"time","QualifiedName":"time.Time","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":true,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"ConnVerifyHostname","Docs":["VerifyHostname checks that the peer certificate chain is valid for","connecting to host. If so, it returns nil; if not, it returns an error","describing the problem."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Conn","PkgName":"tls","PkgPath":"crypto/tls","QualifiedName":"crypto/tls.Conn","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Conn-VerifyHostname","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"VerifyHostname","Signature":"func (*Conn).VerifyHostname(host string) error","ID":"FunctionVerifyHostname","Docs":["VerifyHostname checks that the peer certificate chain is valid for","connecting to host. If so, it returns nil; if not, it returns an error","describing the problem."],"Name":"VerifyHostname","PkgPath":"crypto/tls","PkgName":"tls","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"host","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":true,"Pointers":{"Inp":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"Outp":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1}}},"ClassName":"ConnWrite","Docs":["Write writes data to the connection."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"into454","TypeName":"Conn","PkgName":"tls","PkgPath":"crypto/tls","QualifiedName":"crypto/tls.Conn","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Conn-Write","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Write","Signature":"func (*Conn).Write(b []byte) (int, error)","ID":"FunctionWrite","Docs":["Write writes data to the connection."],"Name":"Write","PkgPath":"crypto/tls","PkgName":"tls","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"b","TypeName":"byte","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":true}],"Results":[{"Identity":{"Placeholder":"isResult(0)","Element":"result","Index":0},"VarName":"","TypeName":"int","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isResult(1)","Element":"result","Index":1},"VarName":"","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"ConnectionStateExportKeyingMaterial","Docs":["ExportKeyingMaterial returns length bytes of exported key material in a new","slice as defined in RFC 5705. If context is nil, it is not used as part of","the seed. If the connection was set to allow renegotiation via","Config.Renegotiation, this function will return an error."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"ConnectionState","PkgName":"tls","PkgPath":"crypto/tls","QualifiedName":"crypto/tls.ConnectionState","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-ConnectionState-ExportKeyingMaterial","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"ExportKeyingMaterial","Signature":"func (*ConnectionState).ExportKeyingMaterial(label string, context []byte, length int) ([]byte, error)","ID":"FunctionExportKeyingMaterial","Docs":["ExportKeyingMaterial returns length bytes of exported key material in a new","slice as defined in RFC 5705. If context is nil, it is not used as part of","the seed. If the connection was set to allow renegotiation via","Config.Renegotiation, this function will return an error."],"Name":"ExportKeyingMaterial","PkgPath":"crypto/tls","PkgName":"tls","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"label","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"VarName":"context","TypeName":"byte","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":true},{"Identity":{"Placeholder":"isParameter(2)","Element":"parameter","Index":2},"VarName":"length","TypeName":"int","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult(0)","Element":"result","Index":0},"VarName":"","TypeName":"byte","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":true},{"Identity":{"Placeholder":"isResult(1)","Element":"result","Index":1},"VarName":"","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"RecordHeaderErrorError","Docs":[],"IsOnPtr":false,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"RecordHeaderError","PkgName":"tls","PkgPath":"crypto/tls","QualifiedName":"crypto/tls.RecordHeaderError","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-RecordHeaderError-Error","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Error","Signature":"func (RecordHeaderError).Error() string","ID":"FunctionError","Docs":[],"Name":"Error","PkgPath":"crypto/tls","PkgName":"tls","Parameters":null,"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}]}}],"InterfaceMethods":[{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"ClientSessionCacheGet","Docs":["Get searches for a ClientSessionState associated with the given key.","On return, ok is true if one was found."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"ClientSessionCache","PkgName":"tls","PkgPath":"crypto/tls","QualifiedName":"crypto/tls.Get","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"interface-method-ClientSessionCache-Get","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Get","Signature":"func (ClientSessionCache).Get(sessionKey string) (session *ClientSessionState, ok bool)","ID":"FunctionGet","Docs":["Get searches for a ClientSessionState associated with the given key.","On return, ok is true if one was found."],"Name":"Get","PkgPath":"crypto/tls","PkgName":"tls","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"sessionKey","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult(0)","Element":"result","Index":0},"VarName":"session","TypeName":"ClientSessionState","PkgName":"tls","PkgPath":"crypto/tls","QualifiedName":"crypto/tls.ClientSessionState","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":true,"IsRepeated":false},{"Identity":{"Placeholder":"isResult(1)","Element":"result","Index":1},"VarName":"ok","TypeName":"bool","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"ClientSessionCachePut","Docs":["Put adds the ClientSessionState to the cache with the given key. It might","get called multiple times in a connection if a TLS 1.3 server provides","more than one session ticket. If called with a nil *ClientSessionState,","it should remove the cache entry."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"ClientSessionCache","PkgName":"tls","PkgPath":"crypto/tls","QualifiedName":"crypto/tls.Put","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"interface-method-ClientSessionCache-Put","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Put","Signature":"func (ClientSessionCache).Put(sessionKey string, cs *ClientSessionState)","ID":"FunctionPut","Docs":["Put adds the ClientSessionState to the cache with the given key. It might","get called multiple times in a connection if a TLS 1.3 server provides","more than one session ticket. If called with a nil *ClientSessionState,","it should remove the cache entry."],"Name":"Put","PkgPath":"crypto/tls","PkgName":"tls","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"sessionKey","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"VarName":"cs","TypeName":"ClientSessionState","PkgName":"tls","PkgPath":"crypto/tls","QualifiedName":"crypto/tls.ClientSessionState","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":true,"IsRepeated":false}],"Results":null}}]}