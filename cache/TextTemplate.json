{"Name":"template","PkgPath":"text/template","PkgName":"template","ID":"text/template","Funcs":[{"CodeQL":{"IsEnabled":true,"Pointers":{"Inp":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"Outp":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0}}},"ClassName":"HTMLEscape","Signature":"func HTMLEscape(w io.Writer, b []byte)","ID":"FunctionHTMLEscape","Docs":["HTMLEscape writes to w the escaped HTML equivalent of the plain text data b."],"Name":"HTMLEscape","PkgPath":"text/template","PkgName":"template","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"w","TypeName":"Writer","PkgName":"io","PkgPath":"io","QualifiedName":"io.Writer","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"VarName":"b","TypeName":"byte","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":true}],"Results":null},{"CodeQL":{"IsEnabled":true,"Pointers":{"Inp":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"Outp":{"Placeholder":"isResult()","Element":"result","Index":0}}},"ClassName":"HTMLEscapeString","Signature":"func HTMLEscapeString(s string) string","ID":"FunctionHTMLEscapeString","Docs":["HTMLEscapeString returns the escaped HTML equivalent of the plain text data s."],"Name":"HTMLEscapeString","PkgPath":"text/template","PkgName":"template","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"s","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"into281","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}]},{"CodeQL":{"IsEnabled":true,"Pointers":{"Inp":{"Placeholder":"isParameter(_)","Element":"parameter","Index":0},"Outp":{"Placeholder":"isResult()","Element":"result","Index":0}}},"ClassName":"HTMLEscaper","Signature":"func HTMLEscaper(args ...interface{}) string","ID":"FunctionHTMLEscaper","Docs":["HTMLEscaper returns the escaped HTML equivalent of the textual","representation of its arguments."],"Name":"HTMLEscaper","PkgPath":"text/template","PkgName":"template","Parameters":[{"Identity":{"Placeholder":"isParameter(_)","Element":"parameter","Index":0},"VarName":"args","TypeName":"interface{}","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":true,"IsNullable":true,"IsStruct":false,"IsRepeated":true}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"into178","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}]},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"IsTrue","Signature":"func IsTrue(val interface{}) (truth bool, ok bool)","ID":"FunctionIsTrue","Docs":["IsTrue reports whether the value is 'true', in the sense of not the zero of its type,","and whether the value has a meaningful truth value. This is the definition of","truth used by if and other such actions."],"Name":"IsTrue","PkgPath":"text/template","PkgName":"template","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"val","TypeName":"interface{}","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult(0)","Element":"result","Index":0},"VarName":"truth","TypeName":"bool","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isResult(1)","Element":"result","Index":1},"VarName":"ok","TypeName":"bool","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}]},{"CodeQL":{"IsEnabled":true,"Pointers":{"Inp":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"Outp":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0}}},"ClassName":"JSEscape","Signature":"func JSEscape(w io.Writer, b []byte)","ID":"FunctionJSEscape","Docs":["JSEscape writes to w the escaped JavaScript equivalent of the plain text data b."],"Name":"JSEscape","PkgPath":"text/template","PkgName":"template","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"w","TypeName":"Writer","PkgName":"io","PkgPath":"io","QualifiedName":"io.Writer","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"VarName":"b","TypeName":"byte","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":true}],"Results":null},{"CodeQL":{"IsEnabled":true,"Pointers":{"Inp":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"Outp":{"Placeholder":"isResult()","Element":"result","Index":0}}},"ClassName":"JSEscapeString","Signature":"func JSEscapeString(s string) string","ID":"FunctionJSEscapeString","Docs":["JSEscapeString returns the escaped JavaScript equivalent of the plain text data s."],"Name":"JSEscapeString","PkgPath":"text/template","PkgName":"template","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"s","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"into124","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}]},{"CodeQL":{"IsEnabled":true,"Pointers":{"Inp":{"Placeholder":"isParameter(_)","Element":"parameter","Index":0},"Outp":{"Placeholder":"isResult()","Element":"result","Index":0}}},"ClassName":"JSEscaper","Signature":"func JSEscaper(args ...interface{}) string","ID":"FunctionJSEscaper","Docs":["JSEscaper returns the escaped JavaScript equivalent of the textual","representation of its arguments."],"Name":"JSEscaper","PkgPath":"text/template","PkgName":"template","Parameters":[{"Identity":{"Placeholder":"isParameter(_)","Element":"parameter","Index":0},"VarName":"args","TypeName":"interface{}","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":true,"IsNullable":true,"IsStruct":false,"IsRepeated":true}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"into186","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}]},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Must","Signature":"func Must(t *Template, err error) *Template","ID":"FunctionMust","Docs":["Must is a helper that wraps a call to a function returning (*Template, error)","and panics if the error is non-nil. It is intended for use in variable","initializations such as","\tvar t = template.Must(template.New(\"name\").Parse(\"text\"))"],"Name":"Must","PkgPath":"text/template","PkgName":"template","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"t","TypeName":"Template","PkgName":"template","PkgPath":"text/template","QualifiedName":"text/template.Template","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":true,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"VarName":"err","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"Template","PkgName":"template","PkgPath":"text/template","QualifiedName":"text/template.Template","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":true,"IsRepeated":false}]},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"New","Signature":"func New(name string) *Template","ID":"FunctionNew","Docs":["New allocates a new, undefined template with the given name."],"Name":"New","PkgPath":"text/template","PkgName":"template","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"name","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"Template","PkgName":"template","PkgPath":"text/template","QualifiedName":"text/template.Template","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":true,"IsRepeated":false}]},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"ParseFiles","Signature":"func ParseFiles(filenames ...string) (*Template, error)","ID":"FunctionParseFiles","Docs":["ParseFiles creates a new Template and parses the template definitions from","the named files. The returned template's name will have the base name and","parsed contents of the first file. There must be at least one file.","If an error occurs, parsing stops and the returned *Template is nil.","","When parsing multiple files with the same name in different directories,","the last one mentioned will be the one that results.","For instance, ParseFiles(\"a/foo\", \"b/foo\") stores \"b/foo\" as the template","named \"foo\", while \"a/foo\" is unavailable."],"Name":"ParseFiles","PkgPath":"text/template","PkgName":"template","Parameters":[{"Identity":{"Placeholder":"isParameter(_)","Element":"parameter","Index":0},"VarName":"filenames","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":true,"IsNullable":true,"IsStruct":false,"IsRepeated":true}],"Results":[{"Identity":{"Placeholder":"isResult(0)","Element":"result","Index":0},"VarName":"","TypeName":"Template","PkgName":"template","PkgPath":"text/template","QualifiedName":"text/template.Template","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":true,"IsRepeated":false},{"Identity":{"Placeholder":"isResult(1)","Element":"result","Index":1},"VarName":"","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"ParseGlob","Signature":"func ParseGlob(pattern string) (*Template, error)","ID":"FunctionParseGlob","Docs":["ParseGlob creates a new Template and parses the template definitions from","the files identified by the pattern. The files are matched according to the","semantics of filepath.Match, and the pattern must match at least one file.","The returned template will have the (base) name and (parsed) contents of the","first file matched by the pattern. ParseGlob is equivalent to calling","ParseFiles with the list of files matched by the pattern.","","When parsing multiple files with the same name in different directories,","the last one mentioned will be the one that results."],"Name":"ParseGlob","PkgPath":"text/template","PkgName":"template","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"pattern","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult(0)","Element":"result","Index":0},"VarName":"","TypeName":"Template","PkgName":"template","PkgPath":"text/template","QualifiedName":"text/template.Template","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":true,"IsRepeated":false},{"Identity":{"Placeholder":"isResult(1)","Element":"result","Index":1},"VarName":"","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]},{"CodeQL":{"IsEnabled":true,"Pointers":{"Inp":{"Placeholder":"isParameter(_)","Element":"parameter","Index":0},"Outp":{"Placeholder":"isResult()","Element":"result","Index":0}}},"ClassName":"URLQueryEscaper","Signature":"func URLQueryEscaper(args ...interface{}) string","ID":"FunctionURLQueryEscaper","Docs":["URLQueryEscaper returns the escaped value of the textual representation of","its arguments in a form suitable for embedding in a URL query."],"Name":"URLQueryEscaper","PkgPath":"text/template","PkgName":"template","Parameters":[{"Identity":{"Placeholder":"isParameter(_)","Element":"parameter","Index":0},"VarName":"args","TypeName":"interface{}","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":true,"IsNullable":true,"IsStruct":false,"IsRepeated":true}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"into551","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}]}],"TypeMethods":[{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"ExecErrorError","Docs":[],"IsOnPtr":false,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"ExecError","PkgName":"template","PkgPath":"text/template","QualifiedName":"text/template.ExecError","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-ExecError-Error","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Error","Signature":"func (ExecError).Error() string","ID":"FunctionError","Docs":[],"Name":"Error","PkgPath":"text/template","PkgName":"template","Parameters":null,"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"ExecErrorUnwrap","Docs":[],"IsOnPtr":false,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"ExecError","PkgName":"template","PkgPath":"text/template","QualifiedName":"text/template.ExecError","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-ExecError-Unwrap","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Unwrap","Signature":"func (ExecError).Unwrap() error","ID":"FunctionUnwrap","Docs":[],"Name":"Unwrap","PkgPath":"text/template","PkgName":"template","Parameters":null,"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"TemplateAddParseTree","Docs":["AddParseTree associates the argument parse tree with the template t, giving","it the specified name. If the template has not been defined, this tree becomes","its definition. If it has been defined and already has that name, the existing","definition is replaced; otherwise a new template is created, defined, and returned."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Template","PkgName":"template","PkgPath":"text/template","QualifiedName":"text/template.Template","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Template-AddParseTree","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"AddParseTree","Signature":"func (*Template).AddParseTree(name string, tree *text/template/parse.Tree) (*Template, error)","ID":"FunctionAddParseTree","Docs":["AddParseTree associates the argument parse tree with the template t, giving","it the specified name. If the template has not been defined, this tree becomes","its definition. If it has been defined and already has that name, the existing","definition is replaced; otherwise a new template is created, defined, and returned."],"Name":"AddParseTree","PkgPath":"text/template","PkgName":"template","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"name","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"VarName":"tree","TypeName":"Tree","PkgName":"parse","PkgPath":"text/template/parse","QualifiedName":"text/template/parse.Tree","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":true,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult(0)","Element":"result","Index":0},"VarName":"","TypeName":"Template","PkgName":"template","PkgPath":"text/template","QualifiedName":"text/template.Template","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":true,"IsRepeated":false},{"Identity":{"Placeholder":"isResult(1)","Element":"result","Index":1},"VarName":"","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"TemplateClone","Docs":["Clone returns a duplicate of the template, including all associated","templates. The actual representation is not copied, but the name space of","associated templates is, so further calls to Parse in the copy will add","templates to the copy but not to the original. Clone can be used to prepare","common templates and use them with variant definitions for other templates","by adding the variants after the clone is made."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Template","PkgName":"template","PkgPath":"text/template","QualifiedName":"text/template.Template","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Template-Clone","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Clone","Signature":"func (*Template).Clone() (*Template, error)","ID":"FunctionClone","Docs":["Clone returns a duplicate of the template, including all associated","templates. The actual representation is not copied, but the name space of","associated templates is, so further calls to Parse in the copy will add","templates to the copy but not to the original. Clone can be used to prepare","common templates and use them with variant definitions for other templates","by adding the variants after the clone is made."],"Name":"Clone","PkgPath":"text/template","PkgName":"template","Parameters":null,"Results":[{"Identity":{"Placeholder":"isResult(0)","Element":"result","Index":0},"VarName":"","TypeName":"Template","PkgName":"template","PkgPath":"text/template","QualifiedName":"text/template.Template","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":true,"IsRepeated":false},{"Identity":{"Placeholder":"isResult(1)","Element":"result","Index":1},"VarName":"","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"TemplateDefinedTemplates","Docs":["DefinedTemplates returns a string listing the defined templates,","prefixed by the string \"; defined templates are: \". If there are none,","it returns the empty string. For generating an error message here","and in html/template."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Template","PkgName":"template","PkgPath":"text/template","QualifiedName":"text/template.Template","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Template-DefinedTemplates","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"DefinedTemplates","Signature":"func (*Template).DefinedTemplates() string","ID":"FunctionDefinedTemplates","Docs":["DefinedTemplates returns a string listing the defined templates,","prefixed by the string \"; defined templates are: \". If there are none,","it returns the empty string. For generating an error message here","and in html/template."],"Name":"DefinedTemplates","PkgPath":"text/template","PkgName":"template","Parameters":null,"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"TemplateDelims","Docs":["Delims sets the action delimiters to the specified strings, to be used in","subsequent calls to Parse, ParseFiles, or ParseGlob. Nested template","definitions will inherit the settings. An empty delimiter stands for the","corresponding default: {{ or }}.","The return value is the template, so calls can be chained."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Template","PkgName":"template","PkgPath":"text/template","QualifiedName":"text/template.Template","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Template-Delims","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Delims","Signature":"func (*Template).Delims(left string, right string) *Template","ID":"FunctionDelims","Docs":["Delims sets the action delimiters to the specified strings, to be used in","subsequent calls to Parse, ParseFiles, or ParseGlob. Nested template","definitions will inherit the settings. An empty delimiter stands for the","corresponding default: {{ or }}.","The return value is the template, so calls can be chained."],"Name":"Delims","PkgPath":"text/template","PkgName":"template","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"left","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"VarName":"right","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"Template","PkgName":"template","PkgPath":"text/template","QualifiedName":"text/template.Template","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":true,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":true,"Pointers":{"Inp":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"Outp":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0}}},"ClassName":"TemplateExecute","Docs":["Execute applies a parsed template to the specified data object,","and writes the output to wr.","If an error occurs executing the template or writing its output,","execution stops, but partial results may already have been written to","the output writer.","A template may be executed safely in parallel, although if parallel","executions share a Writer the output may be interleaved.","","If data is a reflect.Value, the template applies to the concrete","value that the reflect.Value holds, as in fmt.Print."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Template","PkgName":"template","PkgPath":"text/template","QualifiedName":"text/template.Template","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Template-Execute","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Execute","Signature":"func (*Template).Execute(wr io.Writer, data interface{}) error","ID":"FunctionExecute","Docs":["Execute applies a parsed template to the specified data object,","and writes the output to wr.","If an error occurs executing the template or writing its output,","execution stops, but partial results may already have been written to","the output writer.","A template may be executed safely in parallel, although if parallel","executions share a Writer the output may be interleaved.","","If data is a reflect.Value, the template applies to the concrete","value that the reflect.Value holds, as in fmt.Print."],"Name":"Execute","PkgPath":"text/template","PkgName":"template","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"wr","TypeName":"Writer","PkgName":"io","PkgPath":"io","QualifiedName":"io.Writer","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"VarName":"data","TypeName":"interface{}","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":true,"Pointers":{"Inp":{"Placeholder":"isParameter(2)","Element":"parameter","Index":2},"Outp":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0}}},"ClassName":"TemplateExecuteTemplate","Docs":["ExecuteTemplate applies the template associated with t that has the given name","to the specified data object and writes the output to wr.","If an error occurs executing the template or writing its output,","execution stops, but partial results may already have been written to","the output writer.","A template may be executed safely in parallel, although if parallel","executions share a Writer the output may be interleaved."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Template","PkgName":"template","PkgPath":"text/template","QualifiedName":"text/template.Template","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Template-ExecuteTemplate","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"ExecuteTemplate","Signature":"func (*Template).ExecuteTemplate(wr io.Writer, name string, data interface{}) error","ID":"FunctionExecuteTemplate","Docs":["ExecuteTemplate applies the template associated with t that has the given name","to the specified data object and writes the output to wr.","If an error occurs executing the template or writing its output,","execution stops, but partial results may already have been written to","the output writer.","A template may be executed safely in parallel, although if parallel","executions share a Writer the output may be interleaved."],"Name":"ExecuteTemplate","PkgPath":"text/template","PkgName":"template","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"wr","TypeName":"Writer","PkgName":"io","PkgPath":"io","QualifiedName":"io.Writer","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"VarName":"name","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(2)","Element":"parameter","Index":2},"VarName":"data","TypeName":"interface{}","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"TemplateFuncs","Docs":["Funcs adds the elements of the argument map to the template's function map.","It must be called before the template is parsed.","It panics if a value in the map is not a function with appropriate return","type or if the name cannot be used syntactically as a function in a template.","It is legal to overwrite elements of the map. The return value is the template,","so calls can be chained."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Template","PkgName":"template","PkgPath":"text/template","QualifiedName":"text/template.Template","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Template-Funcs","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Funcs","Signature":"func (*Template).Funcs(funcMap FuncMap) *Template","ID":"FunctionFuncs","Docs":["Funcs adds the elements of the argument map to the template's function map.","It must be called before the template is parsed.","It panics if a value in the map is not a function with appropriate return","type or if the name cannot be used syntactically as a function in a template.","It is legal to overwrite elements of the map. The return value is the template,","so calls can be chained."],"Name":"Funcs","PkgPath":"text/template","PkgName":"template","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"funcMap","TypeName":"FuncMap","PkgName":"template","PkgPath":"text/template","QualifiedName":"text/template.FuncMap","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"Template","PkgName":"template","PkgPath":"text/template","QualifiedName":"text/template.Template","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":true,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"TemplateLookup","Docs":["Lookup returns the template with the given name that is associated with t.","It returns nil if there is no such template or the template has no definition."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Template","PkgName":"template","PkgPath":"text/template","QualifiedName":"text/template.Template","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Template-Lookup","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Lookup","Signature":"func (*Template).Lookup(name string) *Template","ID":"FunctionLookup","Docs":["Lookup returns the template with the given name that is associated with t.","It returns nil if there is no such template or the template has no definition."],"Name":"Lookup","PkgPath":"text/template","PkgName":"template","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"name","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"Template","PkgName":"template","PkgPath":"text/template","QualifiedName":"text/template.Template","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":true,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"TemplateName","Docs":["Name returns the name of the template."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Template","PkgName":"template","PkgPath":"text/template","QualifiedName":"text/template.Template","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Template-Name","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Name","Signature":"func (*Template).Name() string","ID":"FunctionName","Docs":["Name returns the name of the template."],"Name":"Name","PkgPath":"text/template","PkgName":"template","Parameters":null,"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"TemplateNew","Docs":["New allocates a new, undefined template associated with the given one and with the same","delimiters. The association, which is transitive, allows one template to","invoke another with a {{template}} action.","","Because associated templates share underlying data, template construction","cannot be done safely in parallel. Once the templates are constructed, they","can be executed in parallel."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Template","PkgName":"template","PkgPath":"text/template","QualifiedName":"text/template.Template","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Template-New","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"New","Signature":"func (*Template).New(name string) *Template","ID":"FunctionNew","Docs":["New allocates a new, undefined template associated with the given one and with the same","delimiters. The association, which is transitive, allows one template to","invoke another with a {{template}} action.","","Because associated templates share underlying data, template construction","cannot be done safely in parallel. Once the templates are constructed, they","can be executed in parallel."],"Name":"New","PkgPath":"text/template","PkgName":"template","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"name","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"Template","PkgName":"template","PkgPath":"text/template","QualifiedName":"text/template.Template","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":true,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"TemplateOption","Docs":["Option sets options for the template. Options are described by","strings, either a simple string or \"key=value\". There can be at","most one equals sign in an option string. If the option string","is unrecognized or otherwise invalid, Option panics.","","Known options:","","missingkey: Control the behavior during execution if a map is","indexed with a key that is not present in the map.","\t\"missingkey=default\" or \"missingkey=invalid\"","\t\tThe default behavior: Do nothing and continue execution.","\t\tIf printed, the result of the index operation is the string","\t\t\"\u003cno value\u003e\".","\t\"missingkey=zero\"","\t\tThe operation returns the zero value for the map type's element.","\t\"missingkey=error\"","\t\tExecution stops immediately with an error."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Template","PkgName":"template","PkgPath":"text/template","QualifiedName":"text/template.Template","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Template-Option","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Option","Signature":"func (*Template).Option(opt ...string) *Template","ID":"FunctionOption","Docs":["Option sets options for the template. Options are described by","strings, either a simple string or \"key=value\". There can be at","most one equals sign in an option string. If the option string","is unrecognized or otherwise invalid, Option panics.","","Known options:","","missingkey: Control the behavior during execution if a map is","indexed with a key that is not present in the map.","\t\"missingkey=default\" or \"missingkey=invalid\"","\t\tThe default behavior: Do nothing and continue execution.","\t\tIf printed, the result of the index operation is the string","\t\t\"\u003cno value\u003e\".","\t\"missingkey=zero\"","\t\tThe operation returns the zero value for the map type's element.","\t\"missingkey=error\"","\t\tExecution stops immediately with an error."],"Name":"Option","PkgPath":"text/template","PkgName":"template","Parameters":[{"Identity":{"Placeholder":"isParameter(_)","Element":"parameter","Index":0},"VarName":"opt","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":true,"IsNullable":true,"IsStruct":false,"IsRepeated":true}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"Template","PkgName":"template","PkgPath":"text/template","QualifiedName":"text/template.Template","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":true,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"TemplateParse","Docs":["Parse parses text as a template body for t.","Named template definitions ({{define ...}} or {{block ...}} statements) in text","define additional templates associated with t and are removed from the","definition of t itself.","","Templates can be redefined in successive calls to Parse.","A template definition with a body containing only white space and comments","is considered empty and will not replace an existing template's body.","This allows using Parse to add new named template definitions without","overwriting the main template body."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Template","PkgName":"template","PkgPath":"text/template","QualifiedName":"text/template.Template","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Template-Parse","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Parse","Signature":"func (*Template).Parse(text string) (*Template, error)","ID":"FunctionParse","Docs":["Parse parses text as a template body for t.","Named template definitions ({{define ...}} or {{block ...}} statements) in text","define additional templates associated with t and are removed from the","definition of t itself.","","Templates can be redefined in successive calls to Parse.","A template definition with a body containing only white space and comments","is considered empty and will not replace an existing template's body.","This allows using Parse to add new named template definitions without","overwriting the main template body."],"Name":"Parse","PkgPath":"text/template","PkgName":"template","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"text","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult(0)","Element":"result","Index":0},"VarName":"","TypeName":"Template","PkgName":"template","PkgPath":"text/template","QualifiedName":"text/template.Template","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":true,"IsRepeated":false},{"Identity":{"Placeholder":"isResult(1)","Element":"result","Index":1},"VarName":"","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"TemplateParseFiles","Docs":["ParseFiles parses the named files and associates the resulting templates with","t. If an error occurs, parsing stops and the returned template is nil;","otherwise it is t. There must be at least one file.","Since the templates created by ParseFiles are named by the base","names of the argument files, t should usually have the name of one","of the (base) names of the files. If it does not, depending on t's","contents before calling ParseFiles, t.Execute may fail. In that","case use t.ExecuteTemplate to execute a valid template.","","When parsing multiple files with the same name in different directories,","the last one mentioned will be the one that results."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Template","PkgName":"template","PkgPath":"text/template","QualifiedName":"text/template.Template","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Template-ParseFiles","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"ParseFiles","Signature":"func (*Template).ParseFiles(filenames ...string) (*Template, error)","ID":"FunctionParseFiles","Docs":["ParseFiles parses the named files and associates the resulting templates with","t. If an error occurs, parsing stops and the returned template is nil;","otherwise it is t. There must be at least one file.","Since the templates created by ParseFiles are named by the base","names of the argument files, t should usually have the name of one","of the (base) names of the files. If it does not, depending on t's","contents before calling ParseFiles, t.Execute may fail. In that","case use t.ExecuteTemplate to execute a valid template.","","When parsing multiple files with the same name in different directories,","the last one mentioned will be the one that results."],"Name":"ParseFiles","PkgPath":"text/template","PkgName":"template","Parameters":[{"Identity":{"Placeholder":"isParameter(_)","Element":"parameter","Index":0},"VarName":"filenames","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":true,"IsNullable":true,"IsStruct":false,"IsRepeated":true}],"Results":[{"Identity":{"Placeholder":"isResult(0)","Element":"result","Index":0},"VarName":"","TypeName":"Template","PkgName":"template","PkgPath":"text/template","QualifiedName":"text/template.Template","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":true,"IsRepeated":false},{"Identity":{"Placeholder":"isResult(1)","Element":"result","Index":1},"VarName":"","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"TemplateParseGlob","Docs":["ParseGlob parses the template definitions in the files identified by the","pattern and associates the resulting templates with t. The files are matched","according to the semantics of filepath.Match, and the pattern must match at","least one file. ParseGlob is equivalent to calling t.ParseFiles with the","list of files matched by the pattern.","","When parsing multiple files with the same name in different directories,","the last one mentioned will be the one that results."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Template","PkgName":"template","PkgPath":"text/template","QualifiedName":"text/template.Template","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Template-ParseGlob","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"ParseGlob","Signature":"func (*Template).ParseGlob(pattern string) (*Template, error)","ID":"FunctionParseGlob","Docs":["ParseGlob parses the template definitions in the files identified by the","pattern and associates the resulting templates with t. The files are matched","according to the semantics of filepath.Match, and the pattern must match at","least one file. ParseGlob is equivalent to calling t.ParseFiles with the","list of files matched by the pattern.","","When parsing multiple files with the same name in different directories,","the last one mentioned will be the one that results."],"Name":"ParseGlob","PkgPath":"text/template","PkgName":"template","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"pattern","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult(0)","Element":"result","Index":0},"VarName":"","TypeName":"Template","PkgName":"template","PkgPath":"text/template","QualifiedName":"text/template.Template","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":true,"IsRepeated":false},{"Identity":{"Placeholder":"isResult(1)","Element":"result","Index":1},"VarName":"","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"TemplateTemplates","Docs":["Templates returns a slice of defined templates associated with t."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Template","PkgName":"template","PkgPath":"text/template","QualifiedName":"text/template.Template","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Template-Templates","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Templates","Signature":"func (*Template).Templates() []*Template","ID":"FunctionTemplates","Docs":["Templates returns a slice of defined templates associated with t."],"Name":"Templates","PkgPath":"text/template","PkgName":"template","Parameters":null,"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"Template","PkgName":"template","PkgPath":"text/template","QualifiedName":"text/template.Template","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":true}]}}],"InterfaceMethods":[]}