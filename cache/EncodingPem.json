{"Name":"pem","PkgPath":"encoding/pem","PkgName":"pem","ID":"encoding/pem","Funcs":[{"CodeQL":{"IsEnabled":true,"Pointers":{"Inp":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"Outp":{"Placeholder":"isResult(0)","Element":"result","Index":0}}},"ClassName":"Decode","Signature":"func Decode(data []byte) (p *Block, rest []byte)","ID":"FunctionDecode","Docs":["Decode will find the next PEM formatted block (certificate, private key","etc) in the input. It returns that block and the remainder of the input. If","no PEM data is found, p is nil and the whole of the input is returned in","rest."],"Name":"Decode","PkgPath":"encoding/pem","PkgName":"pem","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"data","TypeName":"byte","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":true}],"Results":[{"Identity":{"Placeholder":"isResult(0)","Element":"result","Index":0},"VarName":"p","TypeName":"Block","PkgName":"pem","PkgPath":"encoding/pem","QualifiedName":"encoding/pem.Block","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":true,"IsRepeated":false},{"Identity":{"Placeholder":"isResult(1)","Element":"result","Index":1},"VarName":"rest","TypeName":"byte","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":true}]},{"CodeQL":{"IsEnabled":true,"Pointers":{"Inp":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"Outp":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0}}},"ClassName":"Encode","Signature":"func Encode(out io.Writer, b *Block) error","ID":"FunctionEncode","Docs":["Encode writes the PEM encoding of b to out."],"Name":"Encode","PkgPath":"encoding/pem","PkgName":"pem","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"out","TypeName":"Writer","PkgName":"io","PkgPath":"io","QualifiedName":"io.Writer","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"VarName":"b","TypeName":"Block","PkgName":"pem","PkgPath":"encoding/pem","QualifiedName":"encoding/pem.Block","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":true,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]},{"CodeQL":{"IsEnabled":true,"Pointers":{"Inp":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"Outp":{"Placeholder":"isResult()","Element":"result","Index":0}}},"ClassName":"EncodeToMemory","Signature":"func EncodeToMemory(b *Block) []byte","ID":"FunctionEncodeToMemory","Docs":["EncodeToMemory returns the PEM encoding of b.","","If b has invalid headers and cannot be encoded,","EncodeToMemory returns nil. If it is important to","report details about this error case, use Encode instead."],"Name":"EncodeToMemory","PkgPath":"encoding/pem","PkgName":"pem","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"b","TypeName":"Block","PkgName":"pem","PkgPath":"encoding/pem","QualifiedName":"encoding/pem.Block","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":true,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"into478","TypeName":"byte","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":true}]}],"TypeMethods":[],"InterfaceMethods":[]}