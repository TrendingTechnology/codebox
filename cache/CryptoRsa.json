{"Name":"rsa","PkgPath":"crypto/rsa","PkgName":"rsa","ID":"crypto/rsa","Funcs":[{"CodeQL":{"IsEnabled":true,"Pointers":{"Inp":{"Placeholder":"isParameter(3)","Element":"parameter","Index":3},"Outp":{"Placeholder":"isResult(0)","Element":"result","Index":0}}},"ClassName":"DecryptOAEP","Signature":"func DecryptOAEP(hash hash.Hash, random io.Reader, priv *PrivateKey, ciphertext []byte, label []byte) ([]byte, error)","ID":"FunctionDecryptOAEP","Docs":["DecryptOAEP decrypts ciphertext using RSA-OAEP.","","OAEP is parameterised by a hash function that is used as a random oracle.","Encryption and decryption of a given message must use the same hash function","and sha256.New() is a reasonable choice.","","The random parameter, if not nil, is used to blind the private-key operation","and avoid timing side-channel attacks. Blinding is purely internal to this","function â€“ the random data need not match that used when encrypting.","","The label parameter must match the value given when encrypting. See","EncryptOAEP for details."],"Name":"DecryptOAEP","PkgPath":"crypto/rsa","PkgName":"rsa","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"hash","TypeName":"Hash","PkgName":"hash","PkgPath":"hash","QualifiedName":"hash.Hash","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"VarName":"random","TypeName":"Reader","PkgName":"io","PkgPath":"io","QualifiedName":"io.Reader","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(2)","Element":"parameter","Index":2},"VarName":"priv","TypeName":"PrivateKey","PkgName":"rsa","PkgPath":"crypto/rsa","QualifiedName":"crypto/rsa.PrivateKey","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":true,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(3)","Element":"parameter","Index":3},"VarName":"ciphertext","TypeName":"byte","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":true},{"Identity":{"Placeholder":"isParameter(4)","Element":"parameter","Index":4},"VarName":"label","TypeName":"byte","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":true}],"Results":[{"Identity":{"Placeholder":"isResult(0)","Element":"result","Index":0},"VarName":"into492","TypeName":"byte","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":true},{"Identity":{"Placeholder":"isResult(1)","Element":"result","Index":1},"VarName":"","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]},{"CodeQL":{"IsEnabled":true,"Pointers":{"Inp":{"Placeholder":"isParameter(2)","Element":"parameter","Index":2},"Outp":{"Placeholder":"isResult(0)","Element":"result","Index":0}}},"ClassName":"DecryptPKCS1V15","Signature":"func DecryptPKCS1v15(rand io.Reader, priv *PrivateKey, ciphertext []byte) ([]byte, error)","ID":"FunctionDecryptPKCS1V15","Docs":["DecryptPKCS1v15 decrypts a plaintext using RSA and the padding scheme from PKCS#1 v1.5.","If rand != nil, it uses RSA blinding to avoid timing side-channel attacks.","","Note that whether this function returns an error or not discloses secret","information. If an attacker can cause this function to run repeatedly and","learn whether each instance returned an error then they can decrypt and","forge signatures as if they had the private key. See","DecryptPKCS1v15SessionKey for a way of solving this problem."],"Name":"DecryptPKCS1v15","PkgPath":"crypto/rsa","PkgName":"rsa","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"rand","TypeName":"Reader","PkgName":"io","PkgPath":"io","QualifiedName":"io.Reader","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"VarName":"priv","TypeName":"PrivateKey","PkgName":"rsa","PkgPath":"crypto/rsa","QualifiedName":"crypto/rsa.PrivateKey","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":true,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(2)","Element":"parameter","Index":2},"VarName":"ciphertext","TypeName":"byte","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":true}],"Results":[{"Identity":{"Placeholder":"isResult(0)","Element":"result","Index":0},"VarName":"into768","TypeName":"byte","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":true},{"Identity":{"Placeholder":"isResult(1)","Element":"result","Index":1},"VarName":"","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]},{"CodeQL":{"IsEnabled":true,"Pointers":{"Inp":{"Placeholder":"isParameter(2)","Element":"parameter","Index":2},"Outp":{"Placeholder":"isParameter(3)","Element":"parameter","Index":3}}},"ClassName":"DecryptPKCS1V15SessionKey","Signature":"func DecryptPKCS1v15SessionKey(rand io.Reader, priv *PrivateKey, ciphertext []byte, key []byte) error","ID":"FunctionDecryptPKCS1V15SessionKey","Docs":["DecryptPKCS1v15SessionKey decrypts a session key using RSA and the padding scheme from PKCS#1 v1.5.","If rand != nil, it uses RSA blinding to avoid timing side-channel attacks.","It returns an error if the ciphertext is the wrong length or if the","ciphertext is greater than the public modulus. Otherwise, no error is","returned. If the padding is valid, the resulting plaintext message is copied","into key. Otherwise, key is unchanged. These alternatives occur in constant","time. It is intended that the user of this function generate a random","session key beforehand and continue the protocol with the resulting value.","This will remove any possibility that an attacker can learn any information","about the plaintext.","See ``Chosen Ciphertext Attacks Against Protocols Based on the RSA","Encryption Standard PKCS #1'', Daniel Bleichenbacher, Advances in Cryptology","(Crypto '98).","","Note that if the session key is too small then it may be possible for an","attacker to brute-force it. If they can do that then they can learn whether","a random value was used (because it'll be different for the same ciphertext)","and thus whether the padding was correct. This defeats the point of this","function. Using at least a 16-byte key will protect against this attack."],"Name":"DecryptPKCS1v15SessionKey","PkgPath":"crypto/rsa","PkgName":"rsa","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"rand","TypeName":"Reader","PkgName":"io","PkgPath":"io","QualifiedName":"io.Reader","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"VarName":"priv","TypeName":"PrivateKey","PkgName":"rsa","PkgPath":"crypto/rsa","QualifiedName":"crypto/rsa.PrivateKey","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":true,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(2)","Element":"parameter","Index":2},"VarName":"ciphertext","TypeName":"byte","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":true},{"Identity":{"Placeholder":"isParameter(3)","Element":"parameter","Index":3},"VarName":"key","TypeName":"byte","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":true}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]},{"CodeQL":{"IsEnabled":true,"Pointers":{"Inp":{"Placeholder":"isParameter(3)","Element":"parameter","Index":3},"Outp":{"Placeholder":"isResult(0)","Element":"result","Index":0}}},"ClassName":"EncryptOAEP","Signature":"func EncryptOAEP(hash hash.Hash, random io.Reader, pub *PublicKey, msg []byte, label []byte) ([]byte, error)","ID":"FunctionEncryptOAEP","Docs":["EncryptOAEP encrypts the given message with RSA-OAEP.","","OAEP is parameterised by a hash function that is used as a random oracle.","Encryption and decryption of a given message must use the same hash function","and sha256.New() is a reasonable choice.","","The random parameter is used as a source of entropy to ensure that","encrypting the same message twice doesn't result in the same ciphertext.","","The label parameter may contain arbitrary data that will not be encrypted,","but which gives important context to the message. For example, if a given","public key is used to decrypt two types of messages then distinct label","values could be used to ensure that a ciphertext for one purpose cannot be","used for another by an attacker. If not required it can be empty.","","The message must be no longer than the length of the public modulus minus","twice the hash length, minus a further 2."],"Name":"EncryptOAEP","PkgPath":"crypto/rsa","PkgName":"rsa","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"hash","TypeName":"Hash","PkgName":"hash","PkgPath":"hash","QualifiedName":"hash.Hash","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"VarName":"random","TypeName":"Reader","PkgName":"io","PkgPath":"io","QualifiedName":"io.Reader","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(2)","Element":"parameter","Index":2},"VarName":"pub","TypeName":"PublicKey","PkgName":"rsa","PkgPath":"crypto/rsa","QualifiedName":"crypto/rsa.PublicKey","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":true,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(3)","Element":"parameter","Index":3},"VarName":"msg","TypeName":"byte","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":true},{"Identity":{"Placeholder":"isParameter(4)","Element":"parameter","Index":4},"VarName":"label","TypeName":"byte","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":true}],"Results":[{"Identity":{"Placeholder":"isResult(0)","Element":"result","Index":0},"VarName":"into739","TypeName":"byte","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":true},{"Identity":{"Placeholder":"isResult(1)","Element":"result","Index":1},"VarName":"","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]},{"CodeQL":{"IsEnabled":true,"Pointers":{"Inp":{"Placeholder":"isParameter(2)","Element":"parameter","Index":2},"Outp":{"Placeholder":"isResult(0)","Element":"result","Index":0}}},"ClassName":"EncryptPKCS1V15","Signature":"func EncryptPKCS1v15(rand io.Reader, pub *PublicKey, msg []byte) ([]byte, error)","ID":"FunctionEncryptPKCS1V15","Docs":["EncryptPKCS1v15 encrypts the given message with RSA and the padding","scheme from PKCS#1 v1.5.  The message must be no longer than the","length of the public modulus minus 11 bytes.","","The rand parameter is used as a source of entropy to ensure that","encrypting the same message twice doesn't result in the same","ciphertext.","","WARNING: use of this function to encrypt plaintexts other than","session keys is dangerous. Use RSA OAEP in new protocols."],"Name":"EncryptPKCS1v15","PkgPath":"crypto/rsa","PkgName":"rsa","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"rand","TypeName":"Reader","PkgName":"io","PkgPath":"io","QualifiedName":"io.Reader","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"VarName":"pub","TypeName":"PublicKey","PkgName":"rsa","PkgPath":"crypto/rsa","QualifiedName":"crypto/rsa.PublicKey","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":true,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(2)","Element":"parameter","Index":2},"VarName":"msg","TypeName":"byte","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":true}],"Results":[{"Identity":{"Placeholder":"isResult(0)","Element":"result","Index":0},"VarName":"into234","TypeName":"byte","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":true},{"Identity":{"Placeholder":"isResult(1)","Element":"result","Index":1},"VarName":"","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"GenerateKey","Signature":"func GenerateKey(random io.Reader, bits int) (*PrivateKey, error)","ID":"FunctionGenerateKey","Docs":["GenerateKey generates an RSA keypair of the given bit size using the","random source random (for example, crypto/rand.Reader)."],"Name":"GenerateKey","PkgPath":"crypto/rsa","PkgName":"rsa","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"random","TypeName":"Reader","PkgName":"io","PkgPath":"io","QualifiedName":"io.Reader","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"VarName":"bits","TypeName":"int","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult(0)","Element":"result","Index":0},"VarName":"","TypeName":"PrivateKey","PkgName":"rsa","PkgPath":"crypto/rsa","QualifiedName":"crypto/rsa.PrivateKey","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":true,"IsRepeated":false},{"Identity":{"Placeholder":"isResult(1)","Element":"result","Index":1},"VarName":"","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"GenerateMultiPrimeKey","Signature":"func GenerateMultiPrimeKey(random io.Reader, nprimes int, bits int) (*PrivateKey, error)","ID":"FunctionGenerateMultiPrimeKey","Docs":["GenerateMultiPrimeKey generates a multi-prime RSA keypair of the given bit","size and the given random source, as suggested in [1]. Although the public","keys are compatible (actually, indistinguishable) from the 2-prime case,","the private keys are not. Thus it may not be possible to export multi-prime","private keys in certain formats or to subsequently import them into other","code.","","Table 1 in [2] suggests maximum numbers of primes for a given size.","","[1] US patent 4405829 (1972, expired)","[2] http://www.cacr.math.uwaterloo.ca/techreports/2006/cacr2006-16.pdf"],"Name":"GenerateMultiPrimeKey","PkgPath":"crypto/rsa","PkgName":"rsa","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"random","TypeName":"Reader","PkgName":"io","PkgPath":"io","QualifiedName":"io.Reader","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"VarName":"nprimes","TypeName":"int","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(2)","Element":"parameter","Index":2},"VarName":"bits","TypeName":"int","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult(0)","Element":"result","Index":0},"VarName":"","TypeName":"PrivateKey","PkgName":"rsa","PkgPath":"crypto/rsa","QualifiedName":"crypto/rsa.PrivateKey","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":true,"IsRepeated":false},{"Identity":{"Placeholder":"isResult(1)","Element":"result","Index":1},"VarName":"","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]},{"CodeQL":{"IsEnabled":true,"Pointers":{"Inp":{"Placeholder":"isParameter(3)","Element":"parameter","Index":3},"Outp":{"Placeholder":"isResult(0)","Element":"result","Index":0}}},"ClassName":"SignPKCS1V15","Signature":"func SignPKCS1v15(rand io.Reader, priv *PrivateKey, hash crypto.Hash, hashed []byte) ([]byte, error)","ID":"FunctionSignPKCS1V15","Docs":["SignPKCS1v15 calculates the signature of hashed using","RSASSA-PKCS1-V1_5-SIGN from RSA PKCS#1 v1.5.  Note that hashed must","be the result of hashing the input message using the given hash","function. If hash is zero, hashed is signed directly. This isn't","advisable except for interoperability.","","If rand is not nil then RSA blinding will be used to avoid timing","side-channel attacks.","","This function is deterministic. Thus, if the set of possible","messages is small, an attacker may be able to build a map from","messages to signatures and identify the signed messages. As ever,","signatures provide authenticity, not confidentiality."],"Name":"SignPKCS1v15","PkgPath":"crypto/rsa","PkgName":"rsa","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"rand","TypeName":"Reader","PkgName":"io","PkgPath":"io","QualifiedName":"io.Reader","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"VarName":"priv","TypeName":"PrivateKey","PkgName":"rsa","PkgPath":"crypto/rsa","QualifiedName":"crypto/rsa.PrivateKey","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":true,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(2)","Element":"parameter","Index":2},"VarName":"hash","TypeName":"Hash","PkgName":"crypto","PkgPath":"crypto","QualifiedName":"crypto.Hash","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(3)","Element":"parameter","Index":3},"VarName":"hashed","TypeName":"byte","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":true}],"Results":[{"Identity":{"Placeholder":"isResult(0)","Element":"result","Index":0},"VarName":"into852","TypeName":"byte","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":true},{"Identity":{"Placeholder":"isResult(1)","Element":"result","Index":1},"VarName":"","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"SignPSS","Signature":"func SignPSS(rand io.Reader, priv *PrivateKey, hash crypto.Hash, hashed []byte, opts *PSSOptions) ([]byte, error)","ID":"FunctionSignPSS","Docs":["SignPSS calculates the signature of hashed using RSASSA-PSS [1].","Note that hashed must be the result of hashing the input message using the","given hash function. The opts argument may be nil, in which case sensible","defaults are used."],"Name":"SignPSS","PkgPath":"crypto/rsa","PkgName":"rsa","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"rand","TypeName":"Reader","PkgName":"io","PkgPath":"io","QualifiedName":"io.Reader","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"VarName":"priv","TypeName":"PrivateKey","PkgName":"rsa","PkgPath":"crypto/rsa","QualifiedName":"crypto/rsa.PrivateKey","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":true,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(2)","Element":"parameter","Index":2},"VarName":"hash","TypeName":"Hash","PkgName":"crypto","PkgPath":"crypto","QualifiedName":"crypto.Hash","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(3)","Element":"parameter","Index":3},"VarName":"hashed","TypeName":"byte","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":true},{"Identity":{"Placeholder":"isParameter(4)","Element":"parameter","Index":4},"VarName":"opts","TypeName":"PSSOptions","PkgName":"rsa","PkgPath":"crypto/rsa","QualifiedName":"crypto/rsa.PSSOptions","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":true,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult(0)","Element":"result","Index":0},"VarName":"","TypeName":"byte","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":true},{"Identity":{"Placeholder":"isResult(1)","Element":"result","Index":1},"VarName":"","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"VerifyPKCS1V15","Signature":"func VerifyPKCS1v15(pub *PublicKey, hash crypto.Hash, hashed []byte, sig []byte) error","ID":"FunctionVerifyPKCS1V15","Docs":["VerifyPKCS1v15 verifies an RSA PKCS#1 v1.5 signature.","hashed is the result of hashing the input message using the given hash","function and sig is the signature. A valid signature is indicated by","returning a nil error. If hash is zero then hashed is used directly. This","isn't advisable except for interoperability."],"Name":"VerifyPKCS1v15","PkgPath":"crypto/rsa","PkgName":"rsa","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"pub","TypeName":"PublicKey","PkgName":"rsa","PkgPath":"crypto/rsa","QualifiedName":"crypto/rsa.PublicKey","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":true,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"VarName":"hash","TypeName":"Hash","PkgName":"crypto","PkgPath":"crypto","QualifiedName":"crypto.Hash","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(2)","Element":"parameter","Index":2},"VarName":"hashed","TypeName":"byte","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":true},{"Identity":{"Placeholder":"isParameter(3)","Element":"parameter","Index":3},"VarName":"sig","TypeName":"byte","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":true}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"VerifyPSS","Signature":"func VerifyPSS(pub *PublicKey, hash crypto.Hash, hashed []byte, sig []byte, opts *PSSOptions) error","ID":"FunctionVerifyPSS","Docs":["VerifyPSS verifies a PSS signature.","hashed is the result of hashing the input message using the given hash","function and sig is the signature. A valid signature is indicated by","returning a nil error. The opts argument may be nil, in which case sensible","defaults are used."],"Name":"VerifyPSS","PkgPath":"crypto/rsa","PkgName":"rsa","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"pub","TypeName":"PublicKey","PkgName":"rsa","PkgPath":"crypto/rsa","QualifiedName":"crypto/rsa.PublicKey","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":true,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"VarName":"hash","TypeName":"Hash","PkgName":"crypto","PkgPath":"crypto","QualifiedName":"crypto.Hash","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(2)","Element":"parameter","Index":2},"VarName":"hashed","TypeName":"byte","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":true},{"Identity":{"Placeholder":"isParameter(3)","Element":"parameter","Index":3},"VarName":"sig","TypeName":"byte","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":true},{"Identity":{"Placeholder":"isParameter(4)","Element":"parameter","Index":4},"VarName":"opts","TypeName":"PSSOptions","PkgName":"rsa","PkgPath":"crypto/rsa","QualifiedName":"crypto/rsa.PSSOptions","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":true,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]}],"TypeMethods":[{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"PSSOptionsHashFunc","Docs":["HashFunc returns pssOpts.Hash so that PSSOptions implements","crypto.SignerOpts."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"PSSOptions","PkgName":"rsa","PkgPath":"crypto/rsa","QualifiedName":"crypto/rsa.PSSOptions","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-PSSOptions-HashFunc","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"HashFunc","Signature":"func (*PSSOptions).HashFunc() crypto.Hash","ID":"FunctionHashFunc","Docs":["HashFunc returns pssOpts.Hash so that PSSOptions implements","crypto.SignerOpts."],"Name":"HashFunc","PkgPath":"crypto/rsa","PkgName":"rsa","Parameters":null,"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"Hash","PkgName":"crypto","PkgPath":"crypto","QualifiedName":"crypto.Hash","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":true,"Pointers":{"Inp":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"Outp":{"Placeholder":"isResult(0)","Element":"result","Index":0}}},"ClassName":"PrivateKeyDecrypt","Docs":["Decrypt decrypts ciphertext with priv. If opts is nil or of type","*PKCS1v15DecryptOptions then PKCS#1 v1.5 decryption is performed. Otherwise","opts must have type *OAEPOptions and OAEP decryption is done."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"PrivateKey","PkgName":"rsa","PkgPath":"crypto/rsa","QualifiedName":"crypto/rsa.PrivateKey","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-PrivateKey-Decrypt","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Decrypt","Signature":"func (*PrivateKey).Decrypt(rand io.Reader, ciphertext []byte, opts crypto.DecrypterOpts) (plaintext []byte, err error)","ID":"FunctionDecrypt","Docs":["Decrypt decrypts ciphertext with priv. If opts is nil or of type","*PKCS1v15DecryptOptions then PKCS#1 v1.5 decryption is performed. Otherwise","opts must have type *OAEPOptions and OAEP decryption is done."],"Name":"Decrypt","PkgPath":"crypto/rsa","PkgName":"rsa","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"rand","TypeName":"Reader","PkgName":"io","PkgPath":"io","QualifiedName":"io.Reader","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"VarName":"ciphertext","TypeName":"byte","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":true},{"Identity":{"Placeholder":"isParameter(2)","Element":"parameter","Index":2},"VarName":"opts","TypeName":"DecrypterOpts","PkgName":"crypto","PkgPath":"crypto","QualifiedName":"crypto.DecrypterOpts","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult(0)","Element":"result","Index":0},"VarName":"plaintext","TypeName":"byte","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":true},{"Identity":{"Placeholder":"isResult(1)","Element":"result","Index":1},"VarName":"err","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"PrivateKeyPrecompute","Docs":["Precompute performs some calculations that speed up private key operations","in the future."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"PrivateKey","PkgName":"rsa","PkgPath":"crypto/rsa","QualifiedName":"crypto/rsa.PrivateKey","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-PrivateKey-Precompute","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Precompute","Signature":"func (*PrivateKey).Precompute()","ID":"FunctionPrecompute","Docs":["Precompute performs some calculations that speed up private key operations","in the future."],"Name":"Precompute","PkgPath":"crypto/rsa","PkgName":"rsa","Parameters":null,"Results":null}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"PrivateKeyPublic","Docs":["Public returns the public key corresponding to priv."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"PrivateKey","PkgName":"rsa","PkgPath":"crypto/rsa","QualifiedName":"crypto/rsa.PrivateKey","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-PrivateKey-Public","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Public","Signature":"func (*PrivateKey).Public() crypto.PublicKey","ID":"FunctionPublic","Docs":["Public returns the public key corresponding to priv."],"Name":"Public","PkgPath":"crypto/rsa","PkgName":"rsa","Parameters":null,"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"PublicKey","PkgName":"crypto","PkgPath":"crypto","QualifiedName":"crypto.PublicKey","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":true,"Pointers":{"Inp":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"Outp":{"Placeholder":"isResult(0)","Element":"result","Index":0}}},"ClassName":"PrivateKeySign","Docs":["Sign signs digest with priv, reading randomness from rand. If opts is a","*PSSOptions then the PSS algorithm will be used, otherwise PKCS#1 v1.5 will","be used.","","This method implements crypto.Signer, which is an interface to support keys","where the private part is kept in, for example, a hardware module. Common","uses should use the Sign* functions in this package directly."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"PrivateKey","PkgName":"rsa","PkgPath":"crypto/rsa","QualifiedName":"crypto/rsa.PrivateKey","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-PrivateKey-Sign","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Sign","Signature":"func (*PrivateKey).Sign(rand io.Reader, digest []byte, opts crypto.SignerOpts) ([]byte, error)","ID":"FunctionSign","Docs":["Sign signs digest with priv, reading randomness from rand. If opts is a","*PSSOptions then the PSS algorithm will be used, otherwise PKCS#1 v1.5 will","be used.","","This method implements crypto.Signer, which is an interface to support keys","where the private part is kept in, for example, a hardware module. Common","uses should use the Sign* functions in this package directly."],"Name":"Sign","PkgPath":"crypto/rsa","PkgName":"rsa","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"rand","TypeName":"Reader","PkgName":"io","PkgPath":"io","QualifiedName":"io.Reader","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"VarName":"digest","TypeName":"byte","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":true},{"Identity":{"Placeholder":"isParameter(2)","Element":"parameter","Index":2},"VarName":"opts","TypeName":"SignerOpts","PkgName":"crypto","PkgPath":"crypto","QualifiedName":"crypto.SignerOpts","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult(0)","Element":"result","Index":0},"VarName":"into128","TypeName":"byte","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":true},{"Identity":{"Placeholder":"isResult(1)","Element":"result","Index":1},"VarName":"","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"PrivateKeyValidate","Docs":["Validate performs basic sanity checks on the key.","It returns nil if the key is valid, or else an error describing a problem."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"PrivateKey","PkgName":"rsa","PkgPath":"crypto/rsa","QualifiedName":"crypto/rsa.PrivateKey","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-PrivateKey-Validate","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Validate","Signature":"func (*PrivateKey).Validate() error","ID":"FunctionValidate","Docs":["Validate performs basic sanity checks on the key.","It returns nil if the key is valid, or else an error describing a problem."],"Name":"Validate","PkgPath":"crypto/rsa","PkgName":"rsa","Parameters":null,"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"PublicKeySize","Docs":["Size returns the modulus size in bytes. Raw signatures and ciphertexts","for or by this public key will have the same size."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"PublicKey","PkgName":"rsa","PkgPath":"crypto/rsa","QualifiedName":"crypto/rsa.PublicKey","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-PublicKey-Size","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Size","Signature":"func (*PublicKey).Size() int","ID":"FunctionSize","Docs":["Size returns the modulus size in bytes. Raw signatures and ciphertexts","for or by this public key will have the same size."],"Name":"Size","PkgPath":"crypto/rsa","PkgName":"rsa","Parameters":null,"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"int","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}]}}],"InterfaceMethods":[]}