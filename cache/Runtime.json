{"Name":"runtime","PkgPath":"runtime","PkgName":"runtime","ID":"runtime","Funcs":[{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"BlockProfile","Signature":"func BlockProfile(p []BlockProfileRecord) (n int, ok bool)","ID":"FunctionBlockProfile","Docs":["BlockProfile returns n, the number of records in the current blocking profile.","If len(p) \u003e= n, BlockProfile copies the profile into p and returns n, true.","If len(p) \u003c n, BlockProfile does not change p and returns n, false.","","Most clients should use the runtime/pprof package or","the testing package's -test.blockprofile flag instead","of calling BlockProfile directly."],"Name":"BlockProfile","PkgPath":"runtime","PkgName":"runtime","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"p","TypeName":"BlockProfileRecord","PkgName":"runtime","PkgPath":"runtime","QualifiedName":"runtime.BlockProfileRecord","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":true}],"Results":[{"Identity":{"Placeholder":"isResult(0)","Element":"result","Index":0},"VarName":"n","TypeName":"int","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isResult(1)","Element":"result","Index":1},"VarName":"ok","TypeName":"bool","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}]},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Breakpoint","Signature":"func Breakpoint()","ID":"FunctionBreakpoint","Docs":["Breakpoint executes a breakpoint trap."],"Name":"Breakpoint","PkgPath":"runtime","PkgName":"runtime","Parameters":null,"Results":null},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"CPUProfile","Signature":"func CPUProfile() []byte","ID":"FunctionCPUProfile","Docs":["CPUProfile panics.","It formerly provided raw access to chunks of","a pprof-format profile generated by the runtime.","The details of generating that format have changed,","so this functionality has been removed.","","Deprecated: Use the runtime/pprof package,","or the handlers in the net/http/pprof package,","or the testing package's -test.cpuprofile flag instead."],"Name":"CPUProfile","PkgPath":"runtime","PkgName":"runtime","Parameters":null,"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"byte","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":true}]},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Caller","Signature":"func Caller(skip int) (pc uintptr, file string, line int, ok bool)","ID":"FunctionCaller","Docs":["Caller reports file and line number information about function invocations on","the calling goroutine's stack. The argument skip is the number of stack frames","to ascend, with 0 identifying the caller of Caller.  (For historical reasons the","meaning of skip differs between Caller and Callers.) The return values report the","program counter, file name, and line number within the file of the corresponding","call. The boolean ok is false if it was not possible to recover the information."],"Name":"Caller","PkgPath":"runtime","PkgName":"runtime","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"skip","TypeName":"int","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult(0)","Element":"result","Index":0},"VarName":"pc","TypeName":"uintptr","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isResult(1)","Element":"result","Index":1},"VarName":"file","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isResult(2)","Element":"result","Index":2},"VarName":"line","TypeName":"int","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isResult(3)","Element":"result","Index":3},"VarName":"ok","TypeName":"bool","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}]},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Callers","Signature":"func Callers(skip int, pc []uintptr) int","ID":"FunctionCallers","Docs":["Callers fills the slice pc with the return program counters of function invocations","on the calling goroutine's stack. The argument skip is the number of stack frames","to skip before recording in pc, with 0 identifying the frame for Callers itself and","1 identifying the caller of Callers.","It returns the number of entries written to pc.","","To translate these PCs into symbolic information such as function","names and line numbers, use CallersFrames. CallersFrames accounts","for inlined functions and adjusts the return program counters into","call program counters. Iterating over the returned slice of PCs","directly is discouraged, as is using FuncForPC on any of the","returned PCs, since these cannot account for inlining or return","program counter adjustment."],"Name":"Callers","PkgPath":"runtime","PkgName":"runtime","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"skip","TypeName":"int","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"VarName":"pc","TypeName":"uintptr","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":true}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"int","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}]},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"CallersFrames","Signature":"func CallersFrames(callers []uintptr) *Frames","ID":"FunctionCallersFrames","Docs":["CallersFrames takes a slice of PC values returned by Callers and","prepares to return function/file/line information.","Do not change the slice until you are done with the Frames."],"Name":"CallersFrames","PkgPath":"runtime","PkgName":"runtime","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"callers","TypeName":"uintptr","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":true}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"Frames","PkgName":"runtime","PkgPath":"runtime","QualifiedName":"runtime.Frames","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":true,"IsRepeated":false}]},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"FuncForPC","Signature":"func FuncForPC(pc uintptr) *Func","ID":"FunctionFuncForPC","Docs":["FuncForPC returns a *Func describing the function that contains the","given program counter address, or else nil.","","If pc represents multiple functions because of inlining, it returns","the a *Func describing the innermost function, but with an entry","of the outermost function."],"Name":"FuncForPC","PkgPath":"runtime","PkgName":"runtime","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"pc","TypeName":"uintptr","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"Func","PkgName":"runtime","PkgPath":"runtime","QualifiedName":"runtime.Func","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":true,"IsRepeated":false}]},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"GC","Signature":"func GC()","ID":"FunctionGC","Docs":["GC runs a garbage collection and blocks the caller until the","garbage collection is complete. It may also block the entire","program."],"Name":"GC","PkgPath":"runtime","PkgName":"runtime","Parameters":null,"Results":null},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"GOMAXPROCS","Signature":"func GOMAXPROCS(n int) int","ID":"FunctionGOMAXPROCS","Docs":["GOMAXPROCS sets the maximum number of CPUs that can be executing","simultaneously and returns the previous setting. If n \u003c 1, it does not","change the current setting.","The number of logical CPUs on the local machine can be queried with NumCPU.","This call will go away when the scheduler improves."],"Name":"GOMAXPROCS","PkgPath":"runtime","PkgName":"runtime","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"n","TypeName":"int","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"int","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}]},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"GOROOT","Signature":"func GOROOT() string","ID":"FunctionGOROOT","Docs":["GOROOT returns the root of the Go tree. It uses the","GOROOT environment variable, if set at process start,","or else the root used during the Go build."],"Name":"GOROOT","PkgPath":"runtime","PkgName":"runtime","Parameters":null,"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}]},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Goexit","Signature":"func Goexit()","ID":"FunctionGoexit","Docs":["Goexit terminates the goroutine that calls it. No other goroutine is affected.","Goexit runs all deferred calls before terminating the goroutine. Because Goexit","is not a panic, any recover calls in those deferred functions will return nil.","","Calling Goexit from the main goroutine terminates that goroutine","without func main returning. Since func main has not returned,","the program continues execution of other goroutines.","If all other goroutines exit, the program crashes."],"Name":"Goexit","PkgPath":"runtime","PkgName":"runtime","Parameters":null,"Results":null},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"GoroutineProfile","Signature":"func GoroutineProfile(p []StackRecord) (n int, ok bool)","ID":"FunctionGoroutineProfile","Docs":["GoroutineProfile returns n, the number of records in the active goroutine stack profile.","If len(p) \u003e= n, GoroutineProfile copies the profile into p and returns n, true.","If len(p) \u003c n, GoroutineProfile does not change p and returns n, false.","","Most clients should use the runtime/pprof package instead","of calling GoroutineProfile directly."],"Name":"GoroutineProfile","PkgPath":"runtime","PkgName":"runtime","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"p","TypeName":"StackRecord","PkgName":"runtime","PkgPath":"runtime","QualifiedName":"runtime.StackRecord","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":true}],"Results":[{"Identity":{"Placeholder":"isResult(0)","Element":"result","Index":0},"VarName":"n","TypeName":"int","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isResult(1)","Element":"result","Index":1},"VarName":"ok","TypeName":"bool","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}]},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Gosched","Signature":"func Gosched()","ID":"FunctionGosched","Docs":["Gosched yields the processor, allowing other goroutines to run. It does not","suspend the current goroutine, so execution resumes automatically."],"Name":"Gosched","PkgPath":"runtime","PkgName":"runtime","Parameters":null,"Results":null},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"KeepAlive","Signature":"func KeepAlive(x interface{})","ID":"FunctionKeepAlive","Docs":["KeepAlive marks its argument as currently reachable.","This ensures that the object is not freed, and its finalizer is not run,","before the point in the program where KeepAlive is called.","","A very simplified example showing where KeepAlive is required:","\ttype File struct { d int }","\td, err := syscall.Open(\"/file/path\", syscall.O_RDONLY, 0)","\t// ... do something if err != nil ...","\tp := \u0026File{d}","\truntime.SetFinalizer(p, func(p *File) { syscall.Close(p.d) })","\tvar buf [10]byte","\tn, err := syscall.Read(p.d, buf[:])","\t// Ensure p is not finalized until Read returns.","\truntime.KeepAlive(p)","\t// No more uses of p after this point.","","Without the KeepAlive call, the finalizer could run at the start of","syscall.Read, closing the file descriptor before syscall.Read makes","the actual system call."],"Name":"KeepAlive","PkgPath":"runtime","PkgName":"runtime","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"x","TypeName":"interface{}","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}],"Results":null},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"LockOSThread","Signature":"func LockOSThread()","ID":"FunctionLockOSThread","Docs":["LockOSThread wires the calling goroutine to its current operating system thread.","The calling goroutine will always execute in that thread,","and no other goroutine will execute in it,","until the calling goroutine has made as many calls to","UnlockOSThread as to LockOSThread.","If the calling goroutine exits without unlocking the thread,","the thread will be terminated.","","All init functions are run on the startup thread. Calling LockOSThread","from an init function will cause the main function to be invoked on","that thread.","","A goroutine should call LockOSThread before calling OS services or","non-Go library functions that depend on per-thread state."],"Name":"LockOSThread","PkgPath":"runtime","PkgName":"runtime","Parameters":null,"Results":null},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"MemProfile","Signature":"func MemProfile(p []MemProfileRecord, inuseZero bool) (n int, ok bool)","ID":"FunctionMemProfile","Docs":["MemProfile returns a profile of memory allocated and freed per allocation","site.","","MemProfile returns n, the number of records in the current memory profile.","If len(p) \u003e= n, MemProfile copies the profile into p and returns n, true.","If len(p) \u003c n, MemProfile does not change p and returns n, false.","","If inuseZero is true, the profile includes allocation records","where r.AllocBytes \u003e 0 but r.AllocBytes == r.FreeBytes.","These are sites where memory was allocated, but it has all","been released back to the runtime.","","The returned profile may be up to two garbage collection cycles old.","This is to avoid skewing the profile toward allocations; because","allocations happen in real time but frees are delayed until the garbage","collector performs sweeping, the profile only accounts for allocations","that have had a chance to be freed by the garbage collector.","","Most clients should use the runtime/pprof package or","the testing package's -test.memprofile flag instead","of calling MemProfile directly."],"Name":"MemProfile","PkgPath":"runtime","PkgName":"runtime","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"p","TypeName":"MemProfileRecord","PkgName":"runtime","PkgPath":"runtime","QualifiedName":"runtime.MemProfileRecord","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":true},{"Identity":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"VarName":"inuseZero","TypeName":"bool","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult(0)","Element":"result","Index":0},"VarName":"n","TypeName":"int","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isResult(1)","Element":"result","Index":1},"VarName":"ok","TypeName":"bool","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}]},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"MutexProfile","Signature":"func MutexProfile(p []BlockProfileRecord) (n int, ok bool)","ID":"FunctionMutexProfile","Docs":["MutexProfile returns n, the number of records in the current mutex profile.","If len(p) \u003e= n, MutexProfile copies the profile into p and returns n, true.","Otherwise, MutexProfile does not change p, and returns n, false.","","Most clients should use the runtime/pprof package","instead of calling MutexProfile directly."],"Name":"MutexProfile","PkgPath":"runtime","PkgName":"runtime","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"p","TypeName":"BlockProfileRecord","PkgName":"runtime","PkgPath":"runtime","QualifiedName":"runtime.BlockProfileRecord","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":true}],"Results":[{"Identity":{"Placeholder":"isResult(0)","Element":"result","Index":0},"VarName":"n","TypeName":"int","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isResult(1)","Element":"result","Index":1},"VarName":"ok","TypeName":"bool","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}]},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"NumCPU","Signature":"func NumCPU() int","ID":"FunctionNumCPU","Docs":["NumCPU returns the number of logical CPUs usable by the current process.","","The set of available CPUs is checked by querying the operating system","at process startup. Changes to operating system CPU allocation after","process startup are not reflected."],"Name":"NumCPU","PkgPath":"runtime","PkgName":"runtime","Parameters":null,"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"int","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}]},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"NumCgoCall","Signature":"func NumCgoCall() int64","ID":"FunctionNumCgoCall","Docs":["NumCgoCall returns the number of cgo calls made by the current process."],"Name":"NumCgoCall","PkgPath":"runtime","PkgName":"runtime","Parameters":null,"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"int64","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}]},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"NumGoroutine","Signature":"func NumGoroutine() int","ID":"FunctionNumGoroutine","Docs":["NumGoroutine returns the number of goroutines that currently exist."],"Name":"NumGoroutine","PkgPath":"runtime","PkgName":"runtime","Parameters":null,"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"int","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}]},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"ReadMemStats","Signature":"func ReadMemStats(m *MemStats)","ID":"FunctionReadMemStats","Docs":["ReadMemStats populates m with memory allocator statistics.","","The returned memory allocator statistics are up to date as of the","call to ReadMemStats. This is in contrast with a heap profile,","which is a snapshot as of the most recently completed garbage","collection cycle."],"Name":"ReadMemStats","PkgPath":"runtime","PkgName":"runtime","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"m","TypeName":"MemStats","PkgName":"runtime","PkgPath":"runtime","QualifiedName":"runtime.MemStats","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":true,"IsRepeated":false}],"Results":null},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"ReadTrace","Signature":"func ReadTrace() []byte","ID":"FunctionReadTrace","Docs":["ReadTrace returns the next chunk of binary tracing data, blocking until data","is available. If tracing is turned off and all the data accumulated while it","was on has been returned, ReadTrace returns nil. The caller must copy the","returned data before calling ReadTrace again.","ReadTrace must be called from one goroutine at a time."],"Name":"ReadTrace","PkgPath":"runtime","PkgName":"runtime","Parameters":null,"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"byte","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":true}]},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"SetBlockProfileRate","Signature":"func SetBlockProfileRate(rate int)","ID":"FunctionSetBlockProfileRate","Docs":["SetBlockProfileRate controls the fraction of goroutine blocking events","that are reported in the blocking profile. The profiler aims to sample","an average of one blocking event per rate nanoseconds spent blocked.","","To include every blocking event in the profile, pass rate = 1.","To turn off profiling entirely, pass rate \u003c= 0."],"Name":"SetBlockProfileRate","PkgPath":"runtime","PkgName":"runtime","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"rate","TypeName":"int","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}],"Results":null},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"SetCPUProfileRate","Signature":"func SetCPUProfileRate(hz int)","ID":"FunctionSetCPUProfileRate","Docs":["SetCPUProfileRate sets the CPU profiling rate to hz samples per second.","If hz \u003c= 0, SetCPUProfileRate turns off profiling.","If the profiler is on, the rate cannot be changed without first turning it off.","","Most clients should use the runtime/pprof package or","the testing package's -test.cpuprofile flag instead of calling","SetCPUProfileRate directly."],"Name":"SetCPUProfileRate","PkgPath":"runtime","PkgName":"runtime","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"hz","TypeName":"int","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}],"Results":null},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"SetCgoTraceback","Signature":"func SetCgoTraceback(version int, traceback unsafe.Pointer, context unsafe.Pointer, symbolizer unsafe.Pointer)","ID":"FunctionSetCgoTraceback","Docs":["SetCgoTraceback records three C functions to use to gather","traceback information from C code and to convert that traceback","information into symbolic information. These are used when printing","stack traces for a program that uses cgo.","","The traceback and context functions may be called from a signal","handler, and must therefore use only async-signal safe functions.","The symbolizer function may be called while the program is","crashing, and so must be cautious about using memory.  None of the","functions may call back into Go.","","The context function will be called with a single argument, a","pointer to a struct:","","\tstruct {","\t\tContext uintptr","\t}","","In C syntax, this struct will be","","\tstruct {","\t\tuintptr_t Context;","\t};","","If the Context field is 0, the context function is being called to","record the current traceback context. It should record in the","Context field whatever information is needed about the current","point of execution to later produce a stack trace, probably the","stack pointer and PC. In this case the context function will be","called from C code.","","If the Context field is not 0, then it is a value returned by a","previous call to the context function. This case is called when the","context is no longer needed; that is, when the Go code is returning","to its C code caller. This permits the context function to release","any associated resources.","","While it would be correct for the context function to record a","complete a stack trace whenever it is called, and simply copy that","out in the traceback function, in a typical program the context","function will be called many times without ever recording a","traceback for that context. Recording a complete stack trace in a","call to the context function is likely to be inefficient.","","The traceback function will be called with a single argument, a","pointer to a struct:","","\tstruct {","\t\tContext    uintptr","\t\tSigContext uintptr","\t\tBuf        *uintptr","\t\tMax        uintptr","\t}","","In C syntax, this struct will be","","\tstruct {","\t\tuintptr_t  Context;","\t\tuintptr_t  SigContext;","\t\tuintptr_t* Buf;","\t\tuintptr_t  Max;","\t};","","The Context field will be zero to gather a traceback from the","current program execution point. In this case, the traceback","function will be called from C code.","","Otherwise Context will be a value previously returned by a call to","the context function. The traceback function should gather a stack","trace from that saved point in the program execution. The traceback","function may be called from an execution thread other than the one","that recorded the context, but only when the context is known to be","valid and unchanging. The traceback function may also be called","deeper in the call stack on the same thread that recorded the","context. The traceback function may be called multiple times with","the same Context value; it will usually be appropriate to cache the","result, if possible, the first time this is called for a specific","context value.","","If the traceback function is called from a signal handler on a Unix","system, SigContext will be the signal context argument passed to","the signal handler (a C ucontext_t* cast to uintptr_t). This may be","used to start tracing at the point where the signal occurred. If","the traceback function is not called from a signal handler,","SigContext will be zero.","","Buf is where the traceback information should be stored. It should","be PC values, such that Buf[0] is the PC of the caller, Buf[1] is","the PC of that function's caller, and so on.  Max is the maximum","number of entries to store.  The function should store a zero to","indicate the top of the stack, or that the caller is on a different","stack, presumably a Go stack.","","Unlike runtime.Callers, the PC values returned should, when passed","to the symbolizer function, return the file/line of the call","instruction.  No additional subtraction is required or appropriate.","","On all platforms, the traceback function is invoked when a call from","Go to C to Go requests a stack trace. On linux/amd64, linux/ppc64le,","and freebsd/amd64, the traceback function is also invoked when a","signal is received by a thread that is executing a cgo call. The","traceback function should not make assumptions about when it is","called, as future versions of Go may make additional calls.","","The symbolizer function will be called with a single argument, a","pointer to a struct:","","\tstruct {","\t\tPC      uintptr // program counter to fetch information for","\t\tFile    *byte   // file name (NUL terminated)","\t\tLineno  uintptr // line number","\t\tFunc    *byte   // function name (NUL terminated)","\t\tEntry   uintptr // function entry point","\t\tMore    uintptr // set non-zero if more info for this PC","\t\tData    uintptr // unused by runtime, available for function","\t}","","In C syntax, this struct will be","","\tstruct {","\t\tuintptr_t PC;","\t\tchar*     File;","\t\tuintptr_t Lineno;","\t\tchar*     Func;","\t\tuintptr_t Entry;","\t\tuintptr_t More;","\t\tuintptr_t Data;","\t};","","The PC field will be a value returned by a call to the traceback","function.","","The first time the function is called for a particular traceback,","all the fields except PC will be 0. The function should fill in the","other fields if possible, setting them to 0/nil if the information","is not available. The Data field may be used to store any useful","information across calls. The More field should be set to non-zero","if there is more information for this PC, zero otherwise. If More","is set non-zero, the function will be called again with the same","PC, and may return different information (this is intended for use","with inlined functions). If More is zero, the function will be","called with the next PC value in the traceback. When the traceback","is complete, the function will be called once more with PC set to","zero; this may be used to free any information. Each call will","leave the fields of the struct set to the same values they had upon","return, except for the PC field when the More field is zero. The","function must not keep a copy of the struct pointer between calls.","","When calling SetCgoTraceback, the version argument is the version","number of the structs that the functions expect to receive.","Currently this must be zero.","","The symbolizer function may be nil, in which case the results of","the traceback function will be displayed as numbers. If the","traceback function is nil, the symbolizer function will never be","called. The context function may be nil, in which case the","traceback function will only be called with the context field set","to zero.  If the context function is nil, then calls from Go to C","to Go will not show a traceback for the C portion of the call stack.","","SetCgoTraceback should be called only once, ideally from an init function."],"Name":"SetCgoTraceback","PkgPath":"runtime","PkgName":"runtime","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"version","TypeName":"int","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"VarName":"traceback","TypeName":"Pointer","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(2)","Element":"parameter","Index":2},"VarName":"context","TypeName":"Pointer","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(3)","Element":"parameter","Index":3},"VarName":"symbolizer","TypeName":"Pointer","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}],"Results":null},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"SetFinalizer","Signature":"func SetFinalizer(obj interface{}, finalizer interface{})","ID":"FunctionSetFinalizer","Docs":["SetFinalizer sets the finalizer associated with obj to the provided","finalizer function. When the garbage collector finds an unreachable block","with an associated finalizer, it clears the association and runs","finalizer(obj) in a separate goroutine. This makes obj reachable again,","but now without an associated finalizer. Assuming that SetFinalizer","is not called again, the next time the garbage collector sees","that obj is unreachable, it will free obj.","","SetFinalizer(obj, nil) clears any finalizer associated with obj.","","The argument obj must be a pointer to an object allocated by calling","new, by taking the address of a composite literal, or by taking the","address of a local variable.","The argument finalizer must be a function that takes a single argument","to which obj's type can be assigned, and can have arbitrary ignored return","values. If either of these is not true, SetFinalizer may abort the","program.","","Finalizers are run in dependency order: if A points at B, both have","finalizers, and they are otherwise unreachable, only the finalizer","for A runs; once A is freed, the finalizer for B can run.","If a cyclic structure includes a block with a finalizer, that","cycle is not guaranteed to be garbage collected and the finalizer","is not guaranteed to run, because there is no ordering that","respects the dependencies.","","The finalizer is scheduled to run at some arbitrary time after the","program can no longer reach the object to which obj points.","There is no guarantee that finalizers will run before a program exits,","so typically they are useful only for releasing non-memory resources","associated with an object during a long-running program.","For example, an os.File object could use a finalizer to close the","associated operating system file descriptor when a program discards","an os.File without calling Close, but it would be a mistake","to depend on a finalizer to flush an in-memory I/O buffer such as a","bufio.Writer, because the buffer would not be flushed at program exit.","","It is not guaranteed that a finalizer will run if the size of *obj is","zero bytes.","","It is not guaranteed that a finalizer will run for objects allocated","in initializers for package-level variables. Such objects may be","linker-allocated, not heap-allocated.","","A finalizer may run as soon as an object becomes unreachable.","In order to use finalizers correctly, the program must ensure that","the object is reachable until it is no longer required.","Objects stored in global variables, or that can be found by tracing","pointers from a global variable, are reachable. For other objects,","pass the object to a call of the KeepAlive function to mark the","last point in the function where the object must be reachable.","","For example, if p points to a struct that contains a file descriptor d,","and p has a finalizer that closes that file descriptor, and if the last","use of p in a function is a call to syscall.Write(p.d, buf, size), then","p may be unreachable as soon as the program enters syscall.Write. The","finalizer may run at that moment, closing p.d, causing syscall.Write","to fail because it is writing to a closed file descriptor (or, worse,","to an entirely different file descriptor opened by a different goroutine).","To avoid this problem, call runtime.KeepAlive(p) after the call to","syscall.Write.","","A single goroutine runs all finalizers for a program, sequentially.","If a finalizer must run for a long time, it should do so by starting","a new goroutine."],"Name":"SetFinalizer","PkgPath":"runtime","PkgName":"runtime","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"obj","TypeName":"interface{}","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"VarName":"finalizer","TypeName":"interface{}","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}],"Results":null},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"SetMutexProfileFraction","Signature":"func SetMutexProfileFraction(rate int) int","ID":"FunctionSetMutexProfileFraction","Docs":["SetMutexProfileFraction controls the fraction of mutex contention events","that are reported in the mutex profile. On average 1/rate events are","reported. The previous rate is returned.","","To turn off profiling entirely, pass rate 0.","To just read the current rate, pass rate \u003c 0.","(For n\u003e1 the details of sampling may change.)"],"Name":"SetMutexProfileFraction","PkgPath":"runtime","PkgName":"runtime","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"rate","TypeName":"int","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"int","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}]},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Stack","Signature":"func Stack(buf []byte, all bool) int","ID":"FunctionStack","Docs":["Stack formats a stack trace of the calling goroutine into buf","and returns the number of bytes written to buf.","If all is true, Stack formats stack traces of all other goroutines","into buf after the trace for the current goroutine."],"Name":"Stack","PkgPath":"runtime","PkgName":"runtime","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"buf","TypeName":"byte","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":true},{"Identity":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"VarName":"all","TypeName":"bool","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"int","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}]},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"StartTrace","Signature":"func StartTrace() error","ID":"FunctionStartTrace","Docs":["StartTrace enables tracing for the current process.","While tracing, the data will be buffered and available via ReadTrace.","StartTrace returns an error if tracing is already enabled.","Most clients should use the runtime/trace package or the testing package's","-test.trace flag instead of calling StartTrace directly."],"Name":"StartTrace","PkgPath":"runtime","PkgName":"runtime","Parameters":null,"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"StopTrace","Signature":"func StopTrace()","ID":"FunctionStopTrace","Docs":["StopTrace stops tracing, if it was previously enabled.","StopTrace only returns after all the reads for the trace have completed."],"Name":"StopTrace","PkgPath":"runtime","PkgName":"runtime","Parameters":null,"Results":null},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"ThreadCreateProfile","Signature":"func ThreadCreateProfile(p []StackRecord) (n int, ok bool)","ID":"FunctionThreadCreateProfile","Docs":["ThreadCreateProfile returns n, the number of records in the thread creation profile.","If len(p) \u003e= n, ThreadCreateProfile copies the profile into p and returns n, true.","If len(p) \u003c n, ThreadCreateProfile does not change p and returns n, false.","","Most clients should use the runtime/pprof package instead","of calling ThreadCreateProfile directly."],"Name":"ThreadCreateProfile","PkgPath":"runtime","PkgName":"runtime","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"p","TypeName":"StackRecord","PkgName":"runtime","PkgPath":"runtime","QualifiedName":"runtime.StackRecord","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":true}],"Results":[{"Identity":{"Placeholder":"isResult(0)","Element":"result","Index":0},"VarName":"n","TypeName":"int","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isResult(1)","Element":"result","Index":1},"VarName":"ok","TypeName":"bool","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}]},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"UnlockOSThread","Signature":"func UnlockOSThread()","ID":"FunctionUnlockOSThread","Docs":["UnlockOSThread undoes an earlier call to LockOSThread.","If this drops the number of active LockOSThread calls on the","calling goroutine to zero, it unwires the calling goroutine from","its fixed operating system thread.","If there are no active LockOSThread calls, this is a no-op.","","Before calling UnlockOSThread, the caller must ensure that the OS","thread is suitable for running other goroutines. If the caller made","any permanent changes to the state of the thread that would affect","other goroutines, it should not call this function and thus leave","the goroutine locked to the OS thread until the goroutine (and","hence the thread) exits."],"Name":"UnlockOSThread","PkgPath":"runtime","PkgName":"runtime","Parameters":null,"Results":null},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Version","Signature":"func Version() string","ID":"FunctionVersion","Docs":["Version returns the Go tree's version string.","It is either the commit hash and date at the time of the build or,","when possible, a release tag like \"go1.3\"."],"Name":"Version","PkgPath":"runtime","PkgName":"runtime","Parameters":null,"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}]}],"TypeMethods":[{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"FramesNext","Docs":["Next returns frame information for the next caller.","If more is false, there are no more callers (the Frame value is valid)."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Frames","PkgName":"runtime","PkgPath":"runtime","QualifiedName":"runtime.Frames","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Frames-Next","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Next","Signature":"func (*Frames).Next() (frame Frame, more bool)","ID":"FunctionNext","Docs":["Next returns frame information for the next caller.","If more is false, there are no more callers (the Frame value is valid)."],"Name":"Next","PkgPath":"runtime","PkgName":"runtime","Parameters":null,"Results":[{"Identity":{"Placeholder":"isResult(0)","Element":"result","Index":0},"VarName":"frame","TypeName":"Frame","PkgName":"runtime","PkgPath":"runtime","QualifiedName":"runtime.Frame","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":true,"IsRepeated":false},{"Identity":{"Placeholder":"isResult(1)","Element":"result","Index":1},"VarName":"more","TypeName":"bool","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"FuncEntry","Docs":["Entry returns the entry address of the function."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Func","PkgName":"runtime","PkgPath":"runtime","QualifiedName":"runtime.Func","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Func-Entry","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Entry","Signature":"func (*Func).Entry() uintptr","ID":"FunctionEntry","Docs":["Entry returns the entry address of the function."],"Name":"Entry","PkgPath":"runtime","PkgName":"runtime","Parameters":null,"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"uintptr","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"FuncFileLine","Docs":["FileLine returns the file name and line number of the","source code corresponding to the program counter pc.","The result will not be accurate if pc is not a program","counter within f."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Func","PkgName":"runtime","PkgPath":"runtime","QualifiedName":"runtime.Func","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Func-FileLine","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"FileLine","Signature":"func (*Func).FileLine(pc uintptr) (file string, line int)","ID":"FunctionFileLine","Docs":["FileLine returns the file name and line number of the","source code corresponding to the program counter pc.","The result will not be accurate if pc is not a program","counter within f."],"Name":"FileLine","PkgPath":"runtime","PkgName":"runtime","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"pc","TypeName":"uintptr","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult(0)","Element":"result","Index":0},"VarName":"file","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isResult(1)","Element":"result","Index":1},"VarName":"line","TypeName":"int","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"FuncName","Docs":["Name returns the name of the function."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Func","PkgName":"runtime","PkgPath":"runtime","QualifiedName":"runtime.Func","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Func-Name","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Name","Signature":"func (*Func).Name() string","ID":"FunctionName","Docs":["Name returns the name of the function."],"Name":"Name","PkgPath":"runtime","PkgName":"runtime","Parameters":null,"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"MemProfileRecordInUseBytes","Docs":["InUseBytes returns the number of bytes in use (AllocBytes - FreeBytes)."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"MemProfileRecord","PkgName":"runtime","PkgPath":"runtime","QualifiedName":"runtime.MemProfileRecord","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-MemProfileRecord-InUseBytes","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"InUseBytes","Signature":"func (*MemProfileRecord).InUseBytes() int64","ID":"FunctionInUseBytes","Docs":["InUseBytes returns the number of bytes in use (AllocBytes - FreeBytes)."],"Name":"InUseBytes","PkgPath":"runtime","PkgName":"runtime","Parameters":null,"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"int64","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"MemProfileRecordInUseObjects","Docs":["InUseObjects returns the number of objects in use (AllocObjects - FreeObjects)."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"MemProfileRecord","PkgName":"runtime","PkgPath":"runtime","QualifiedName":"runtime.MemProfileRecord","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-MemProfileRecord-InUseObjects","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"InUseObjects","Signature":"func (*MemProfileRecord).InUseObjects() int64","ID":"FunctionInUseObjects","Docs":["InUseObjects returns the number of objects in use (AllocObjects - FreeObjects)."],"Name":"InUseObjects","PkgPath":"runtime","PkgName":"runtime","Parameters":null,"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"int64","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"MemProfileRecordStack","Docs":["Stack returns the stack trace associated with the record,","a prefix of r.Stack0."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"MemProfileRecord","PkgName":"runtime","PkgPath":"runtime","QualifiedName":"runtime.MemProfileRecord","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-MemProfileRecord-Stack","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Stack","Signature":"func (*MemProfileRecord).Stack() []uintptr","ID":"FunctionStack","Docs":["Stack returns the stack trace associated with the record,","a prefix of r.Stack0."],"Name":"Stack","PkgPath":"runtime","PkgName":"runtime","Parameters":null,"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"uintptr","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":true}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"StackRecordStack","Docs":["Stack returns the stack trace associated with the record,","a prefix of r.Stack0."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"StackRecord","PkgName":"runtime","PkgPath":"runtime","QualifiedName":"runtime.StackRecord","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-StackRecord-Stack","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Stack","Signature":"func (*StackRecord).Stack() []uintptr","ID":"FunctionStack","Docs":["Stack returns the stack trace associated with the record,","a prefix of r.Stack0."],"Name":"Stack","PkgPath":"runtime","PkgName":"runtime","Parameters":null,"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"uintptr","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":true}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"TypeAssertionErrorError","Docs":[],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"TypeAssertionError","PkgName":"runtime","PkgPath":"runtime","QualifiedName":"runtime.TypeAssertionError","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-TypeAssertionError-Error","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Error","Signature":"func (*TypeAssertionError).Error() string","ID":"FunctionError","Docs":[],"Name":"Error","PkgPath":"runtime","PkgName":"runtime","Parameters":null,"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"TypeAssertionErrorRuntimeError","Docs":[],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"TypeAssertionError","PkgName":"runtime","PkgPath":"runtime","QualifiedName":"runtime.TypeAssertionError","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-TypeAssertionError-RuntimeError","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"RuntimeError","Signature":"func (*TypeAssertionError).RuntimeError()","ID":"FunctionRuntimeError","Docs":[],"Name":"RuntimeError","PkgPath":"runtime","PkgName":"runtime","Parameters":null,"Results":null}}],"InterfaceMethods":[{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"ErrorRuntimeError","Docs":["RuntimeError is a no-op function but","serves to distinguish types that are run time","errors from ordinary errors: a type is a","run time error if it has a RuntimeError method."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Error","PkgName":"runtime","PkgPath":"runtime","QualifiedName":"runtime.RuntimeError","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"interface-method-Error-RuntimeError","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"RuntimeError","Signature":"func (Error).RuntimeError()","ID":"FunctionRuntimeError","Docs":["RuntimeError is a no-op function but","serves to distinguish types that are run time","errors from ordinary errors: a type is a","run time error if it has a RuntimeError method."],"Name":"RuntimeError","PkgPath":"runtime","PkgName":"runtime","Parameters":null,"Results":null}}]}