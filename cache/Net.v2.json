{
   "func (*AddrError).Error() string": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false
            ],
            "Outp": [
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func (*AddrError).Temporary() bool": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false
            ],
            "Outp": [
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func (*AddrError).Timeout() bool": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false
            ],
            "Outp": [
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func (*Buffers).Read(p []byte) (n int, err error)": {
      "GeneratedClass": "\n    private class BuffersRead extends TaintTracking::FunctionModel, Method {\n      // signature: func (*Buffers).Read(p []byte) (n int, err error)\n      BuffersRead() { this.(Method).hasQualifiedName(\"net\", \"Buffers\", \"Read\") }\n\n      override predicate hasTaintFlow(FunctionInput inp, FunctionOutput outp) {\n        ((inp.isReceiver()) and (outp.isParameter(0)))\n      }\n    }",
      "GeneratedConditions": "((inp.isReceiver()) and (outp.isParameter(0)))",
      "Blocks": [
         {
            "Inp": [
               true,
               false,
               false,
               false
            ],
            "Outp": [
               false,
               true,
               false,
               false
            ]
         }
      ],
      "IsEnabled": true
   },
   "func (*Buffers).WriteTo(w io.Writer) (n int64, err error)": {
      "GeneratedClass": "\n    private class BuffersWriteTo extends TaintTracking::FunctionModel, Method {\n      // signature: func (*Buffers).WriteTo(w io.Writer) (n int64, err error)\n      BuffersWriteTo() { this.(Method).hasQualifiedName(\"net\", \"Buffers\", \"WriteTo\") }\n\n      override predicate hasTaintFlow(FunctionInput inp, FunctionOutput outp) {\n        ((inp.isReceiver()) and (outp.isParameter(0)))\n      }\n    }",
      "GeneratedConditions": "((inp.isReceiver()) and (outp.isParameter(0)))",
      "Blocks": [
         {
            "Inp": [
               true,
               false,
               false,
               false
            ],
            "Outp": [
               false,
               true,
               false,
               false
            ]
         }
      ],
      "IsEnabled": true
   },
   "func (*DNSConfigError).Error() string": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false
            ],
            "Outp": [
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func (*DNSConfigError).Temporary() bool": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false
            ],
            "Outp": [
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func (*DNSConfigError).Timeout() bool": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false
            ],
            "Outp": [
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func (*DNSConfigError).Unwrap() error": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false
            ],
            "Outp": [
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func (*DNSError).Error() string": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false
            ],
            "Outp": [
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func (*DNSError).Temporary() bool": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false
            ],
            "Outp": [
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func (*DNSError).Timeout() bool": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false
            ],
            "Outp": [
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func (*Dialer).Dial(network string, address string) (Conn, error)": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false,
               false,
               false,
               false
            ],
            "Outp": [
               false,
               false,
               false,
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func (*Dialer).DialContext(ctx context.Context, network string, address string) (Conn, error)": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false,
               false,
               false,
               false,
               false
            ],
            "Outp": [
               false,
               false,
               false,
               false,
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func (*IP).UnmarshalText(text []byte) error": {
      "GeneratedClass": "\n    private class IPUnmarshalText extends TaintTracking::FunctionModel, Method {\n      // signature: func (*IP).UnmarshalText(text []byte) error\n      IPUnmarshalText() { this.(Method).hasQualifiedName(\"net\", \"IP\", \"UnmarshalText\") }\n\n      override predicate hasTaintFlow(FunctionInput inp, FunctionOutput outp) {\n        ((inp.isParameter(0)) and (outp.isReceiver()))\n      }\n    }",
      "GeneratedConditions": "((inp.isParameter(0)) and (outp.isReceiver()))",
      "Blocks": [
         {
            "Inp": [
               false,
               true,
               false
            ],
            "Outp": [
               true,
               false,
               false
            ]
         }
      ],
      "IsEnabled": true
   },
   "func (*IPAddr).Network() string": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false
            ],
            "Outp": [
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func (*IPAddr).String() string": {
      "GeneratedClass": "\n    private class IPAddrString extends TaintTracking::FunctionModel, Method {\n      // signature: func (*IPAddr).String() string\n      IPAddrString() { this.(Method).hasQualifiedName(\"net\", \"IPAddr\", \"String\") }\n\n      override predicate hasTaintFlow(FunctionInput inp, FunctionOutput outp) {\n        ((inp.isReceiver()) and (outp.isResult()))\n      }\n    }",
      "GeneratedConditions": "((inp.isReceiver()) and (outp.isResult()))",
      "Blocks": [
         {
            "Inp": [
               true,
               false
            ],
            "Outp": [
               false,
               true
            ]
         }
      ],
      "IsEnabled": true
   },
   "func (*IPConn).ReadFrom(b []byte) (int, Addr, error)": {
      "GeneratedClass": "\n    private class IPConnReadFrom extends TaintTracking::FunctionModel, Method {\n      // signature: func (*IPConn).ReadFrom(b []byte) (int, Addr, error)\n      IPConnReadFrom() { this.(Method).hasQualifiedName(\"net\", \"IPConn\", \"ReadFrom\") }\n\n      override predicate hasTaintFlow(FunctionInput inp, FunctionOutput outp) {\n        ((inp.isReceiver()) and (outp.isParameter(0)))\n      }\n    }",
      "GeneratedConditions": "((inp.isReceiver()) and (outp.isParameter(0)))",
      "Blocks": [
         {
            "Inp": [
               true,
               false,
               false,
               false,
               false
            ],
            "Outp": [
               false,
               true,
               false,
               false,
               false
            ]
         }
      ],
      "IsEnabled": true
   },
   "func (*IPConn).ReadFromIP(b []byte) (int, *IPAddr, error)": {
      "GeneratedClass": "\n    private class IPConnReadFromIP extends TaintTracking::FunctionModel, Method {\n      // signature: func (*IPConn).ReadFromIP(b []byte) (int, *IPAddr, error)\n      IPConnReadFromIP() { this.(Method).hasQualifiedName(\"net\", \"IPConn\", \"ReadFromIP\") }\n\n      override predicate hasTaintFlow(FunctionInput inp, FunctionOutput outp) {\n        ((inp.isReceiver()) and (outp.isParameter(0)))\n      }\n    }",
      "GeneratedConditions": "((inp.isReceiver()) and (outp.isParameter(0)))",
      "Blocks": [
         {
            "Inp": [
               true,
               false,
               false,
               false,
               false
            ],
            "Outp": [
               false,
               true,
               false,
               false,
               false
            ]
         }
      ],
      "IsEnabled": true
   },
   "func (*IPConn).ReadMsgIP(b []byte, oob []byte) (n int, oobn int, flags int, addr *IPAddr, err error)": {
      "GeneratedClass": "\n    private class IPConnReadMsgIP extends TaintTracking::FunctionModel, Method {\n      // signature: func (*IPConn).ReadMsgIP(b []byte, oob []byte) (n int, oobn int, flags int, addr *IPAddr, err error)\n      IPConnReadMsgIP() { this.(Method).hasQualifiedName(\"net\", \"IPConn\", \"ReadMsgIP\") }\n\n      override predicate hasTaintFlow(FunctionInput inp, FunctionOutput outp) {\n        ((inp.isReceiver()) and (outp.isParameter(_)))\n      }\n    }",
      "GeneratedConditions": "((inp.isReceiver()) and (outp.isParameter(_)))",
      "Blocks": [
         {
            "Inp": [
               true,
               false,
               false,
               false,
               false,
               false,
               false,
               false
            ],
            "Outp": [
               false,
               true,
               true,
               false,
               false,
               false,
               false,
               false
            ]
         }
      ],
      "IsEnabled": true
   },
   "func (*IPConn).SyscallConn() (syscall.RawConn, error)": {
      "GeneratedClass": "\n    private class IPConnSyscallConn extends TaintTracking::FunctionModel, Method {\n      // signature: func (*IPConn).SyscallConn() (syscall.RawConn, error)\n      IPConnSyscallConn() { this.(Method).hasQualifiedName(\"net\", \"IPConn\", \"SyscallConn\") }\n\n      override predicate hasTaintFlow(FunctionInput inp, FunctionOutput outp) {\n        ((inp.isReceiver()) and (outp.isResult(0)))\n        or\n        ((inp.isResult(0)) and (outp.isReceiver()))\n      }\n    }",
      "GeneratedConditions": "((inp.isReceiver()) and (outp.isResult(0)))\n        or\n        ((inp.isResult(0)) and (outp.isReceiver()))",
      "Blocks": [
         {
            "Inp": [
               true,
               false,
               false
            ],
            "Outp": [
               false,
               true,
               false
            ]
         },
         {
            "Inp": [
               false,
               true,
               false
            ],
            "Outp": [
               true,
               false,
               false
            ]
         }
      ],
      "IsEnabled": true
   },
   "func (*IPConn).WriteMsgIP(b []byte, oob []byte, addr *IPAddr) (n int, oobn int, err error)": {
      "GeneratedClass": "\n    private class IPConnWriteMsgIP extends TaintTracking::FunctionModel, Method {\n      // signature: func (*IPConn).WriteMsgIP(b []byte, oob []byte, addr *IPAddr) (n int, oobn int, err error)\n      IPConnWriteMsgIP() { this.(Method).hasQualifiedName(\"net\", \"IPConn\", \"WriteMsgIP\") }\n\n      override predicate hasTaintFlow(FunctionInput inp, FunctionOutput outp) {\n        ((inp.isParameter([0, 1])) and (outp.isReceiver()))\n      }\n    }",
      "GeneratedConditions": "((inp.isParameter([0, 1])) and (outp.isReceiver()))",
      "Blocks": [
         {
            "Inp": [
               false,
               true,
               true,
               false,
               false,
               false,
               false
            ],
            "Outp": [
               true,
               false,
               false,
               false,
               false,
               false,
               false
            ]
         }
      ],
      "IsEnabled": true
   },
   "func (*IPConn).WriteTo(b []byte, addr Addr) (int, error)": {
      "GeneratedClass": "\n    private class IPConnWriteTo extends TaintTracking::FunctionModel, Method {\n      // signature: func (*IPConn).WriteTo(b []byte, addr Addr) (int, error)\n      IPConnWriteTo() { this.(Method).hasQualifiedName(\"net\", \"IPConn\", \"WriteTo\") }\n\n      override predicate hasTaintFlow(FunctionInput inp, FunctionOutput outp) {\n        ((inp.isParameter(0)) and (outp.isReceiver()))\n      }\n    }",
      "GeneratedConditions": "((inp.isParameter(0)) and (outp.isReceiver()))",
      "Blocks": [
         {
            "Inp": [
               false,
               true,
               false,
               false,
               false
            ],
            "Outp": [
               true,
               false,
               false,
               false,
               false
            ]
         }
      ],
      "IsEnabled": true
   },
   "func (*IPConn).WriteToIP(b []byte, addr *IPAddr) (int, error)": {
      "GeneratedClass": "\n    private class IPConnWriteToIP extends TaintTracking::FunctionModel, Method {\n      // signature: func (*IPConn).WriteToIP(b []byte, addr *IPAddr) (int, error)\n      IPConnWriteToIP() { this.(Method).hasQualifiedName(\"net\", \"IPConn\", \"WriteToIP\") }\n\n      override predicate hasTaintFlow(FunctionInput inp, FunctionOutput outp) {\n        ((inp.isParameter(0)) and (outp.isReceiver()))\n      }\n    }",
      "GeneratedConditions": "((inp.isParameter(0)) and (outp.isReceiver()))",
      "Blocks": [
         {
            "Inp": [
               false,
               true,
               false,
               false,
               false
            ],
            "Outp": [
               true,
               false,
               false,
               false,
               false
            ]
         }
      ],
      "IsEnabled": true
   },
   "func (*IPNet).Contains(ip IP) bool": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false,
               false
            ],
            "Outp": [
               false,
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func (*IPNet).Network() string": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false
            ],
            "Outp": [
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func (*IPNet).String() string": {
      "GeneratedClass": "\n    private class IPNetString extends TaintTracking::FunctionModel, Method {\n      // signature: func (*IPNet).String() string\n      IPNetString() { this.(Method).hasQualifiedName(\"net\", \"IPNet\", \"String\") }\n\n      override predicate hasTaintFlow(FunctionInput inp, FunctionOutput outp) {\n        ((inp.isReceiver()) and (outp.isResult()))\n      }\n    }",
      "GeneratedConditions": "((inp.isReceiver()) and (outp.isResult()))",
      "Blocks": [
         {
            "Inp": [
               true,
               false
            ],
            "Outp": [
               false,
               true
            ]
         }
      ],
      "IsEnabled": true
   },
   "func (*Interface).Addrs() ([]Addr, error)": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false,
               false
            ],
            "Outp": [
               false,
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func (*Interface).MulticastAddrs() ([]Addr, error)": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false,
               false
            ],
            "Outp": [
               false,
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func (*ListenConfig).Listen(ctx context.Context, network string, address string) (Listener, error)": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false,
               false,
               false,
               false,
               false
            ],
            "Outp": [
               false,
               false,
               false,
               false,
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func (*ListenConfig).ListenPacket(ctx context.Context, network string, address string) (PacketConn, error)": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false,
               false,
               false,
               false,
               false
            ],
            "Outp": [
               false,
               false,
               false,
               false,
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func (*OpError).Error() string": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false
            ],
            "Outp": [
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func (*OpError).Temporary() bool": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false
            ],
            "Outp": [
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func (*OpError).Timeout() bool": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false
            ],
            "Outp": [
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func (*OpError).Unwrap() error": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false
            ],
            "Outp": [
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func (*ParseError).Error() string": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false
            ],
            "Outp": [
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func (*Resolver).LookupAddr(ctx context.Context, addr string) (names []string, err error)": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false,
               false,
               false,
               false
            ],
            "Outp": [
               false,
               false,
               false,
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func (*Resolver).LookupCNAME(ctx context.Context, host string) (cname string, err error)": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false,
               false,
               false,
               false
            ],
            "Outp": [
               false,
               false,
               false,
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func (*Resolver).LookupHost(ctx context.Context, host string) (addrs []string, err error)": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false,
               false,
               false,
               false
            ],
            "Outp": [
               false,
               false,
               false,
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func (*Resolver).LookupIPAddr(ctx context.Context, host string) ([]IPAddr, error)": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false,
               false,
               false,
               false
            ],
            "Outp": [
               false,
               false,
               false,
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func (*Resolver).LookupMX(ctx context.Context, name string) ([]*MX, error)": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false,
               false,
               false,
               false
            ],
            "Outp": [
               false,
               false,
               false,
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func (*Resolver).LookupNS(ctx context.Context, name string) ([]*NS, error)": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false,
               false,
               false,
               false
            ],
            "Outp": [
               false,
               false,
               false,
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func (*Resolver).LookupPort(ctx context.Context, network string, service string) (port int, err error)": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false,
               false,
               false,
               false,
               false
            ],
            "Outp": [
               false,
               false,
               false,
               false,
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func (*Resolver).LookupSRV(ctx context.Context, service string, proto string, name string) (cname string, addrs []*SRV, err error)": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false,
               false,
               false,
               false,
               false,
               false,
               false
            ],
            "Outp": [
               false,
               false,
               false,
               false,
               false,
               false,
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func (*Resolver).LookupTXT(ctx context.Context, name string) ([]string, error)": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false,
               false,
               false,
               false
            ],
            "Outp": [
               false,
               false,
               false,
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func (*TCPAddr).Network() string": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false
            ],
            "Outp": [
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func (*TCPAddr).String() string": {
      "GeneratedClass": "\n    private class TCPAddrString extends TaintTracking::FunctionModel, Method {\n      // signature: func (*TCPAddr).String() string\n      TCPAddrString() { this.(Method).hasQualifiedName(\"net\", \"TCPAddr\", \"String\") }\n\n      override predicate hasTaintFlow(FunctionInput inp, FunctionOutput outp) {\n        ((inp.isReceiver()) and (outp.isResult()))\n      }\n    }",
      "GeneratedConditions": "((inp.isReceiver()) and (outp.isResult()))",
      "Blocks": [
         {
            "Inp": [
               true,
               false
            ],
            "Outp": [
               false,
               true
            ]
         }
      ],
      "IsEnabled": true
   },
   "func (*TCPConn).CloseRead() error": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false
            ],
            "Outp": [
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func (*TCPConn).CloseWrite() error": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false
            ],
            "Outp": [
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func (*TCPConn).ReadFrom(r io.Reader) (int64, error)": {
      "GeneratedClass": "\n    private class TCPConnReadFrom extends TaintTracking::FunctionModel, Method {\n      // signature: func (*TCPConn).ReadFrom(r io.Reader) (int64, error)\n      TCPConnReadFrom() { this.(Method).hasQualifiedName(\"net\", \"TCPConn\", \"ReadFrom\") }\n\n      override predicate hasTaintFlow(FunctionInput inp, FunctionOutput outp) {\n        ((inp.isParameter(0)) and (outp.isReceiver()))\n      }\n    }",
      "GeneratedConditions": "((inp.isParameter(0)) and (outp.isReceiver()))",
      "Blocks": [
         {
            "Inp": [
               false,
               true,
               false,
               false
            ],
            "Outp": [
               true,
               false,
               false,
               false
            ]
         }
      ],
      "IsEnabled": true
   },
   "func (*TCPConn).SetKeepAlive(keepalive bool) error": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false,
               false
            ],
            "Outp": [
               false,
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func (*TCPConn).SetKeepAlivePeriod(d time.Duration) error": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false,
               false
            ],
            "Outp": [
               false,
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func (*TCPConn).SetLinger(sec int) error": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false,
               false
            ],
            "Outp": [
               false,
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func (*TCPConn).SetNoDelay(noDelay bool) error": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false,
               false
            ],
            "Outp": [
               false,
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func (*TCPConn).SyscallConn() (syscall.RawConn, error)": {
      "GeneratedClass": "\n    private class TCPConnSyscallConn extends TaintTracking::FunctionModel, Method {\n      // signature: func (*TCPConn).SyscallConn() (syscall.RawConn, error)\n      TCPConnSyscallConn() { this.(Method).hasQualifiedName(\"net\", \"TCPConn\", \"SyscallConn\") }\n\n      override predicate hasTaintFlow(FunctionInput inp, FunctionOutput outp) {\n        ((inp.isReceiver()) and (outp.isResult(0)))\n        or\n        ((inp.isResult(0)) and (outp.isReceiver()))\n      }\n    }",
      "GeneratedConditions": "((inp.isReceiver()) and (outp.isResult(0)))\n        or\n        ((inp.isResult(0)) and (outp.isReceiver()))",
      "Blocks": [
         {
            "Inp": [
               true,
               false,
               false
            ],
            "Outp": [
               false,
               true,
               false
            ]
         },
         {
            "Inp": [
               false,
               true,
               false
            ],
            "Outp": [
               true,
               false,
               false
            ]
         }
      ],
      "IsEnabled": true
   },
   "func (*TCPListener).Accept() (Conn, error)": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false,
               false
            ],
            "Outp": [
               false,
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func (*TCPListener).AcceptTCP() (*TCPConn, error)": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false,
               false
            ],
            "Outp": [
               false,
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func (*TCPListener).Addr() Addr": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false
            ],
            "Outp": [
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func (*TCPListener).Close() error": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false
            ],
            "Outp": [
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func (*TCPListener).File() (f *os.File, err error)": {
      "GeneratedClass": "\n    private class TCPListenerFile extends TaintTracking::FunctionModel, Method {\n      // signature: func (*TCPListener).File() (f *os.File, err error)\n      TCPListenerFile() { this.(Method).hasQualifiedName(\"net\", \"TCPListener\", \"File\") }\n\n      override predicate hasTaintFlow(FunctionInput inp, FunctionOutput outp) {\n        ((inp.isReceiver()) and (outp.isResult(0)))\n        or\n        ((inp.isResult(0)) and (outp.isReceiver()))\n      }\n    }",
      "GeneratedConditions": "((inp.isReceiver()) and (outp.isResult(0)))\n        or\n        ((inp.isResult(0)) and (outp.isReceiver()))",
      "Blocks": [
         {
            "Inp": [
               true,
               false,
               false
            ],
            "Outp": [
               false,
               true,
               false
            ]
         },
         {
            "Inp": [
               false,
               true,
               false
            ],
            "Outp": [
               true,
               false,
               false
            ]
         }
      ],
      "IsEnabled": true
   },
   "func (*TCPListener).SetDeadline(t time.Time) error": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false,
               false
            ],
            "Outp": [
               false,
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func (*TCPListener).SyscallConn() (syscall.RawConn, error)": {
      "GeneratedClass": "\n    private class TCPListenerSyscallConn extends TaintTracking::FunctionModel, Method {\n      // signature: func (*TCPListener).SyscallConn() (syscall.RawConn, error)\n      TCPListenerSyscallConn() { this.(Method).hasQualifiedName(\"net\", \"TCPListener\", \"SyscallConn\") }\n\n      override predicate hasTaintFlow(FunctionInput inp, FunctionOutput outp) {\n        ((inp.isReceiver()) and (outp.isResult(0)))\n        or\n        ((inp.isResult(0)) and (outp.isReceiver()))\n      }\n    }",
      "GeneratedConditions": "((inp.isReceiver()) and (outp.isResult(0)))\n        or\n        ((inp.isResult(0)) and (outp.isReceiver()))",
      "Blocks": [
         {
            "Inp": [
               true,
               false,
               false
            ],
            "Outp": [
               false,
               true,
               false
            ]
         },
         {
            "Inp": [
               false,
               true,
               false
            ],
            "Outp": [
               true,
               false,
               false
            ]
         }
      ],
      "IsEnabled": true
   },
   "func (*UDPAddr).Network() string": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false
            ],
            "Outp": [
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func (*UDPAddr).String() string": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false
            ],
            "Outp": [
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func (*UDPConn).ReadFrom(b []byte) (int, Addr, error)": {
      "GeneratedClass": "\n    private class UDPConnReadFrom extends TaintTracking::FunctionModel, Method {\n      // signature: func (*UDPConn).ReadFrom(b []byte) (int, Addr, error)\n      UDPConnReadFrom() { this.(Method).hasQualifiedName(\"net\", \"UDPConn\", \"ReadFrom\") }\n\n      override predicate hasTaintFlow(FunctionInput inp, FunctionOutput outp) {\n        ((inp.isReceiver()) and (outp.isParameter(0)))\n      }\n    }",
      "GeneratedConditions": "((inp.isReceiver()) and (outp.isParameter(0)))",
      "Blocks": [
         {
            "Inp": [
               true,
               false,
               false,
               false,
               false
            ],
            "Outp": [
               false,
               true,
               false,
               false,
               false
            ]
         }
      ],
      "IsEnabled": true
   },
   "func (*UDPConn).ReadFromUDP(b []byte) (int, *UDPAddr, error)": {
      "GeneratedClass": "\n    private class UDPConnReadFromUDP extends TaintTracking::FunctionModel, Method {\n      // signature: func (*UDPConn).ReadFromUDP(b []byte) (int, *UDPAddr, error)\n      UDPConnReadFromUDP() { this.(Method).hasQualifiedName(\"net\", \"UDPConn\", \"ReadFromUDP\") }\n\n      override predicate hasTaintFlow(FunctionInput inp, FunctionOutput outp) {\n        ((inp.isReceiver()) and (outp.isParameter(0)))\n      }\n    }",
      "GeneratedConditions": "((inp.isReceiver()) and (outp.isParameter(0)))",
      "Blocks": [
         {
            "Inp": [
               true,
               false,
               false,
               false,
               false
            ],
            "Outp": [
               false,
               true,
               false,
               false,
               false
            ]
         }
      ],
      "IsEnabled": true
   },
   "func (*UDPConn).ReadMsgUDP(b []byte, oob []byte) (n int, oobn int, flags int, addr *UDPAddr, err error)": {
      "GeneratedClass": "\n    private class UDPConnReadMsgUDP extends TaintTracking::FunctionModel, Method {\n      // signature: func (*UDPConn).ReadMsgUDP(b []byte, oob []byte) (n int, oobn int, flags int, addr *UDPAddr, err error)\n      UDPConnReadMsgUDP() { this.(Method).hasQualifiedName(\"net\", \"UDPConn\", \"ReadMsgUDP\") }\n\n      override predicate hasTaintFlow(FunctionInput inp, FunctionOutput outp) {\n        ((inp.isReceiver()) and (outp.isParameter(_)))\n      }\n    }",
      "GeneratedConditions": "((inp.isReceiver()) and (outp.isParameter(_)))",
      "Blocks": [
         {
            "Inp": [
               true,
               false,
               false,
               false,
               false,
               false,
               false,
               false
            ],
            "Outp": [
               false,
               true,
               true,
               false,
               false,
               false,
               false,
               false
            ]
         }
      ],
      "IsEnabled": true
   },
   "func (*UDPConn).SyscallConn() (syscall.RawConn, error)": {
      "GeneratedClass": "\n    private class UDPConnSyscallConn extends TaintTracking::FunctionModel, Method {\n      // signature: func (*UDPConn).SyscallConn() (syscall.RawConn, error)\n      UDPConnSyscallConn() { this.(Method).hasQualifiedName(\"net\", \"UDPConn\", \"SyscallConn\") }\n\n      override predicate hasTaintFlow(FunctionInput inp, FunctionOutput outp) {\n        ((inp.isReceiver()) and (outp.isResult(0)))\n        or\n        ((inp.isResult(0)) and (outp.isReceiver()))\n      }\n    }",
      "GeneratedConditions": "((inp.isReceiver()) and (outp.isResult(0)))\n        or\n        ((inp.isResult(0)) and (outp.isReceiver()))",
      "Blocks": [
         {
            "Inp": [
               true,
               false,
               false
            ],
            "Outp": [
               false,
               true,
               false
            ]
         },
         {
            "Inp": [
               false,
               true,
               false
            ],
            "Outp": [
               true,
               false,
               false
            ]
         }
      ],
      "IsEnabled": true
   },
   "func (*UDPConn).WriteMsgUDP(b []byte, oob []byte, addr *UDPAddr) (n int, oobn int, err error)": {
      "GeneratedClass": "\n    private class UDPConnWriteMsgUDP extends TaintTracking::FunctionModel, Method {\n      // signature: func (*UDPConn).WriteMsgUDP(b []byte, oob []byte, addr *UDPAddr) (n int, oobn int, err error)\n      UDPConnWriteMsgUDP() { this.(Method).hasQualifiedName(\"net\", \"UDPConn\", \"WriteMsgUDP\") }\n\n      override predicate hasTaintFlow(FunctionInput inp, FunctionOutput outp) {\n        ((inp.isParameter([0, 1])) and (outp.isReceiver()))\n      }\n    }",
      "GeneratedConditions": "((inp.isParameter([0, 1])) and (outp.isReceiver()))",
      "Blocks": [
         {
            "Inp": [
               false,
               true,
               true,
               false,
               false,
               false,
               false
            ],
            "Outp": [
               true,
               false,
               false,
               false,
               false,
               false,
               false
            ]
         }
      ],
      "IsEnabled": true
   },
   "func (*UDPConn).WriteTo(b []byte, addr Addr) (int, error)": {
      "GeneratedClass": "\n    private class UDPConnWriteTo extends TaintTracking::FunctionModel, Method {\n      // signature: func (*UDPConn).WriteTo(b []byte, addr Addr) (int, error)\n      UDPConnWriteTo() { this.(Method).hasQualifiedName(\"net\", \"UDPConn\", \"WriteTo\") }\n\n      override predicate hasTaintFlow(FunctionInput inp, FunctionOutput outp) {\n        ((inp.isParameter(0)) and (outp.isReceiver()))\n      }\n    }",
      "GeneratedConditions": "((inp.isParameter(0)) and (outp.isReceiver()))",
      "Blocks": [
         {
            "Inp": [
               false,
               true,
               false,
               false,
               false
            ],
            "Outp": [
               true,
               false,
               false,
               false,
               false
            ]
         }
      ],
      "IsEnabled": true
   },
   "func (*UDPConn).WriteToUDP(b []byte, addr *UDPAddr) (int, error)": {
      "GeneratedClass": "\n    private class UDPConnWriteToUDP extends TaintTracking::FunctionModel, Method {\n      // signature: func (*UDPConn).WriteToUDP(b []byte, addr *UDPAddr) (int, error)\n      UDPConnWriteToUDP() { this.(Method).hasQualifiedName(\"net\", \"UDPConn\", \"WriteToUDP\") }\n\n      override predicate hasTaintFlow(FunctionInput inp, FunctionOutput outp) {\n        ((inp.isParameter(0)) and (outp.isReceiver()))\n      }\n    }",
      "GeneratedConditions": "((inp.isParameter(0)) and (outp.isReceiver()))",
      "Blocks": [
         {
            "Inp": [
               false,
               true,
               false,
               false,
               false
            ],
            "Outp": [
               true,
               false,
               false,
               false,
               false
            ]
         }
      ],
      "IsEnabled": true
   },
   "func (*UnixAddr).Network() string": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false
            ],
            "Outp": [
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func (*UnixAddr).String() string": {
      "GeneratedClass": "\n    private class UnixAddrString extends TaintTracking::FunctionModel, Method {\n      // signature: func (*UnixAddr).String() string\n      UnixAddrString() { this.(Method).hasQualifiedName(\"net\", \"UnixAddr\", \"String\") }\n\n      override predicate hasTaintFlow(FunctionInput inp, FunctionOutput outp) {\n        ((inp.isReceiver()) and (outp.isResult()))\n      }\n    }",
      "GeneratedConditions": "((inp.isReceiver()) and (outp.isResult()))",
      "Blocks": [
         {
            "Inp": [
               true,
               false
            ],
            "Outp": [
               false,
               true
            ]
         }
      ],
      "IsEnabled": true
   },
   "func (*UnixConn).CloseRead() error": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false
            ],
            "Outp": [
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func (*UnixConn).CloseWrite() error": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false
            ],
            "Outp": [
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func (*UnixConn).ReadFrom(b []byte) (int, Addr, error)": {
      "GeneratedClass": "\n    private class UnixConnReadFrom extends TaintTracking::FunctionModel, Method {\n      // signature: func (*UnixConn).ReadFrom(b []byte) (int, Addr, error)\n      UnixConnReadFrom() { this.(Method).hasQualifiedName(\"net\", \"UnixConn\", \"ReadFrom\") }\n\n      override predicate hasTaintFlow(FunctionInput inp, FunctionOutput outp) {\n        ((inp.isReceiver()) and (outp.isParameter(0)))\n      }\n    }",
      "GeneratedConditions": "((inp.isReceiver()) and (outp.isParameter(0)))",
      "Blocks": [
         {
            "Inp": [
               true,
               false,
               false,
               false,
               false
            ],
            "Outp": [
               false,
               true,
               false,
               false,
               false
            ]
         }
      ],
      "IsEnabled": true
   },
   "func (*UnixConn).ReadFromUnix(b []byte) (int, *UnixAddr, error)": {
      "GeneratedClass": "\n    private class UnixConnReadFromUnix extends TaintTracking::FunctionModel, Method {\n      // signature: func (*UnixConn).ReadFromUnix(b []byte) (int, *UnixAddr, error)\n      UnixConnReadFromUnix() { this.(Method).hasQualifiedName(\"net\", \"UnixConn\", \"ReadFromUnix\") }\n\n      override predicate hasTaintFlow(FunctionInput inp, FunctionOutput outp) {\n        ((inp.isReceiver()) and (outp.isParameter(0)))\n      }\n    }",
      "GeneratedConditions": "((inp.isReceiver()) and (outp.isParameter(0)))",
      "Blocks": [
         {
            "Inp": [
               true,
               false,
               false,
               false,
               false
            ],
            "Outp": [
               false,
               true,
               false,
               false,
               false
            ]
         }
      ],
      "IsEnabled": true
   },
   "func (*UnixConn).ReadMsgUnix(b []byte, oob []byte) (n int, oobn int, flags int, addr *UnixAddr, err error)": {
      "GeneratedClass": "\n    private class UnixConnReadMsgUnix extends TaintTracking::FunctionModel, Method {\n      // signature: func (*UnixConn).ReadMsgUnix(b []byte, oob []byte) (n int, oobn int, flags int, addr *UnixAddr, err error)\n      UnixConnReadMsgUnix() { this.(Method).hasQualifiedName(\"net\", \"UnixConn\", \"ReadMsgUnix\") }\n\n      override predicate hasTaintFlow(FunctionInput inp, FunctionOutput outp) {\n        ((inp.isReceiver()) and (outp.isParameter(_)))\n      }\n    }",
      "GeneratedConditions": "((inp.isReceiver()) and (outp.isParameter(_)))",
      "Blocks": [
         {
            "Inp": [
               true,
               false,
               false,
               false,
               false,
               false,
               false,
               false
            ],
            "Outp": [
               false,
               true,
               true,
               false,
               false,
               false,
               false,
               false
            ]
         }
      ],
      "IsEnabled": true
   },
   "func (*UnixConn).SyscallConn() (syscall.RawConn, error)": {
      "GeneratedClass": "\n    private class UnixConnSyscallConn extends TaintTracking::FunctionModel, Method {\n      // signature: func (*UnixConn).SyscallConn() (syscall.RawConn, error)\n      UnixConnSyscallConn() { this.(Method).hasQualifiedName(\"net\", \"UnixConn\", \"SyscallConn\") }\n\n      override predicate hasTaintFlow(FunctionInput inp, FunctionOutput outp) {\n        ((inp.isReceiver()) and (outp.isResult(0)))\n        or\n        ((inp.isResult(0)) and (outp.isReceiver()))\n      }\n    }",
      "GeneratedConditions": "((inp.isReceiver()) and (outp.isResult(0)))\n        or\n        ((inp.isResult(0)) and (outp.isReceiver()))",
      "Blocks": [
         {
            "Inp": [
               true,
               false,
               false
            ],
            "Outp": [
               false,
               true,
               false
            ]
         },
         {
            "Inp": [
               false,
               true,
               false
            ],
            "Outp": [
               true,
               false,
               false
            ]
         }
      ],
      "IsEnabled": true
   },
   "func (*UnixConn).WriteMsgUnix(b []byte, oob []byte, addr *UnixAddr) (n int, oobn int, err error)": {
      "GeneratedClass": "\n    private class UnixConnWriteMsgUnix extends TaintTracking::FunctionModel, Method {\n      // signature: func (*UnixConn).WriteMsgUnix(b []byte, oob []byte, addr *UnixAddr) (n int, oobn int, err error)\n      UnixConnWriteMsgUnix() { this.(Method).hasQualifiedName(\"net\", \"UnixConn\", \"WriteMsgUnix\") }\n\n      override predicate hasTaintFlow(FunctionInput inp, FunctionOutput outp) {\n        ((inp.isParameter([0, 1])) and (outp.isReceiver()))\n      }\n    }",
      "GeneratedConditions": "((inp.isParameter([0, 1])) and (outp.isReceiver()))",
      "Blocks": [
         {
            "Inp": [
               false,
               true,
               true,
               false,
               false,
               false,
               false
            ],
            "Outp": [
               true,
               false,
               false,
               false,
               false,
               false,
               false
            ]
         }
      ],
      "IsEnabled": true
   },
   "func (*UnixConn).WriteTo(b []byte, addr Addr) (int, error)": {
      "GeneratedClass": "\n    private class UnixConnWriteTo extends TaintTracking::FunctionModel, Method {\n      // signature: func (*UnixConn).WriteTo(b []byte, addr Addr) (int, error)\n      UnixConnWriteTo() { this.(Method).hasQualifiedName(\"net\", \"UnixConn\", \"WriteTo\") }\n\n      override predicate hasTaintFlow(FunctionInput inp, FunctionOutput outp) {\n        ((inp.isParameter(0)) and (outp.isReceiver()))\n      }\n    }",
      "GeneratedConditions": "((inp.isParameter(0)) and (outp.isReceiver()))",
      "Blocks": [
         {
            "Inp": [
               false,
               true,
               false,
               false,
               false
            ],
            "Outp": [
               true,
               false,
               false,
               false,
               false
            ]
         }
      ],
      "IsEnabled": true
   },
   "func (*UnixConn).WriteToUnix(b []byte, addr *UnixAddr) (int, error)": {
      "GeneratedClass": "\n    private class UnixConnWriteToUnix extends TaintTracking::FunctionModel, Method {\n      // signature: func (*UnixConn).WriteToUnix(b []byte, addr *UnixAddr) (int, error)\n      UnixConnWriteToUnix() { this.(Method).hasQualifiedName(\"net\", \"UnixConn\", \"WriteToUnix\") }\n\n      override predicate hasTaintFlow(FunctionInput inp, FunctionOutput outp) {\n        ((inp.isParameter(0)) and (outp.isReceiver()))\n      }\n    }",
      "GeneratedConditions": "((inp.isParameter(0)) and (outp.isReceiver()))",
      "Blocks": [
         {
            "Inp": [
               false,
               true,
               false,
               false,
               false
            ],
            "Outp": [
               true,
               false,
               false,
               false,
               false
            ]
         }
      ],
      "IsEnabled": true
   },
   "func (*UnixListener).Accept() (Conn, error)": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false,
               false
            ],
            "Outp": [
               false,
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func (*UnixListener).AcceptUnix() (*UnixConn, error)": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false,
               false
            ],
            "Outp": [
               false,
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func (*UnixListener).Addr() Addr": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false
            ],
            "Outp": [
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func (*UnixListener).Close() error": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false
            ],
            "Outp": [
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func (*UnixListener).File() (f *os.File, err error)": {
      "GeneratedClass": "\n    private class UnixListenerFile extends TaintTracking::FunctionModel, Method {\n      // signature: func (*UnixListener).File() (f *os.File, err error)\n      UnixListenerFile() { this.(Method).hasQualifiedName(\"net\", \"UnixListener\", \"File\") }\n\n      override predicate hasTaintFlow(FunctionInput inp, FunctionOutput outp) {\n        ((inp.isReceiver()) and (outp.isResult(0)))\n        or\n        ((inp.isResult(0)) and (outp.isReceiver()))\n      }\n    }",
      "GeneratedConditions": "((inp.isReceiver()) and (outp.isResult(0)))\n        or\n        ((inp.isResult(0)) and (outp.isReceiver()))",
      "Blocks": [
         {
            "Inp": [
               true,
               false,
               false
            ],
            "Outp": [
               false,
               true,
               false
            ]
         },
         {
            "Inp": [
               false,
               true,
               false
            ],
            "Outp": [
               true,
               false,
               false
            ]
         }
      ],
      "IsEnabled": true
   },
   "func (*UnixListener).SetDeadline(t time.Time) error": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false,
               false
            ],
            "Outp": [
               false,
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func (*UnixListener).SetUnlinkOnClose(unlink bool)": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false
            ],
            "Outp": [
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func (*UnixListener).SyscallConn() (syscall.RawConn, error)": {
      "GeneratedClass": "\n    private class UnixListenerSyscallConn extends TaintTracking::FunctionModel, Method {\n      // signature: func (*UnixListener).SyscallConn() (syscall.RawConn, error)\n      UnixListenerSyscallConn() { this.(Method).hasQualifiedName(\"net\", \"UnixListener\", \"SyscallConn\") }\n\n      override predicate hasTaintFlow(FunctionInput inp, FunctionOutput outp) {\n        ((inp.isReceiver()) and (outp.isResult(0)))\n        or\n        ((inp.isResult(0)) and (outp.isReceiver()))\n      }\n    }",
      "GeneratedConditions": "((inp.isReceiver()) and (outp.isResult(0)))\n        or\n        ((inp.isResult(0)) and (outp.isReceiver()))",
      "Blocks": [
         {
            "Inp": [
               true,
               false,
               false
            ],
            "Outp": [
               false,
               true,
               false
            ]
         },
         {
            "Inp": [
               false,
               true,
               false
            ],
            "Outp": [
               true,
               false,
               false
            ]
         }
      ],
      "IsEnabled": true
   },
   "func (Addr).Network() string": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false
            ],
            "Outp": [
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func (Addr).String() string": {
      "GeneratedClass": "\n    private class AddrString extends TaintTracking::FunctionModel, Method {\n      // signature: func (Addr).String() string\n      AddrString() {\n        this.implements(\"net\", \"Addr\", \"String\")\n      }\n\n      override predicate hasTaintFlow(FunctionInput inp, FunctionOutput outp) {\n        ((inp.isReceiver()) and (outp.isResult()))\n      }\n    }",
      "GeneratedConditions": "((inp.isReceiver()) and (outp.isResult()))",
      "Blocks": [
         {
            "Inp": [
               true,
               false
            ],
            "Outp": [
               false,
               true
            ]
         }
      ],
      "IsEnabled": true
   },
   "func (Conn).Close() error": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false
            ],
            "Outp": [
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func (Conn).LocalAddr() Addr": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false
            ],
            "Outp": [
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func (Conn).Read(b []byte) (n int, err error)": {
      "GeneratedClass": "\n    private class ConnRead extends TaintTracking::FunctionModel, Method {\n      // signature: func (Conn).Read(b []byte) (n int, err error)\n      ConnRead() {\n        this.implements(\"net\", \"Conn\", \"Read\")\n      }\n\n      override predicate hasTaintFlow(FunctionInput inp, FunctionOutput outp) {\n        ((inp.isReceiver()) and (outp.isParameter(0)))\n      }\n    }",
      "GeneratedConditions": "((inp.isReceiver()) and (outp.isParameter(0)))",
      "Blocks": [
         {
            "Inp": [
               true,
               false,
               false,
               false
            ],
            "Outp": [
               false,
               true,
               false,
               false
            ]
         }
      ],
      "IsEnabled": true
   },
   "func (Conn).RemoteAddr() Addr": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false
            ],
            "Outp": [
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func (Conn).SetDeadline(t time.Time) error": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false,
               false
            ],
            "Outp": [
               false,
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func (Conn).SetReadDeadline(t time.Time) error": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false,
               false
            ],
            "Outp": [
               false,
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func (Conn).SetWriteDeadline(t time.Time) error": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false,
               false
            ],
            "Outp": [
               false,
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func (Conn).Write(b []byte) (n int, err error)": {
      "GeneratedClass": "\n    private class ConnWrite extends TaintTracking::FunctionModel, Method {\n      // signature: func (Conn).Write(b []byte) (n int, err error)\n      ConnWrite() {\n        this.implements(\"net\", \"Conn\", \"Write\")\n      }\n\n      override predicate hasTaintFlow(FunctionInput inp, FunctionOutput outp) {\n        ((inp.isParameter(0)) and (outp.isReceiver()))\n      }\n    }",
      "GeneratedConditions": "((inp.isParameter(0)) and (outp.isReceiver()))",
      "Blocks": [
         {
            "Inp": [
               false,
               true,
               false,
               false
            ],
            "Outp": [
               true,
               false,
               false,
               false
            ]
         }
      ],
      "IsEnabled": true
   },
   "func (Error).Temporary() bool": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false
            ],
            "Outp": [
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func (Error).Timeout() bool": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false
            ],
            "Outp": [
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func (Flags).String() string": {
      "GeneratedClass": "\n    private class FlagsString extends TaintTracking::FunctionModel, Method {\n      // signature: func (Flags).String() string\n      FlagsString() { this.(Method).hasQualifiedName(\"net\", \"Flags\", \"String\") }\n\n      override predicate hasTaintFlow(FunctionInput inp, FunctionOutput outp) {\n        ((inp.isReceiver()) and (outp.isResult()))\n      }\n    }",
      "GeneratedConditions": "((inp.isReceiver()) and (outp.isResult()))",
      "Blocks": [
         {
            "Inp": [
               true,
               false
            ],
            "Outp": [
               false,
               true
            ]
         }
      ],
      "IsEnabled": true
   },
   "func (HardwareAddr).String() string": {
      "GeneratedClass": "\n    private class HardwareAddrString extends TaintTracking::FunctionModel, Method {\n      // signature: func (HardwareAddr).String() string\n      HardwareAddrString() { this.(Method).hasQualifiedName(\"net\", \"HardwareAddr\", \"String\") }\n\n      override predicate hasTaintFlow(FunctionInput inp, FunctionOutput outp) {\n        ((inp.isReceiver()) and (outp.isResult()))\n      }\n    }",
      "GeneratedConditions": "((inp.isReceiver()) and (outp.isResult()))",
      "Blocks": [
         {
            "Inp": [
               true,
               false
            ],
            "Outp": [
               false,
               true
            ]
         }
      ],
      "IsEnabled": true
   },
   "func (IP).DefaultMask() IPMask": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false
            ],
            "Outp": [
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func (IP).Equal(x IP) bool": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false,
               false
            ],
            "Outp": [
               false,
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func (IP).IsGlobalUnicast() bool": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false
            ],
            "Outp": [
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func (IP).IsInterfaceLocalMulticast() bool": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false
            ],
            "Outp": [
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func (IP).IsLinkLocalMulticast() bool": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false
            ],
            "Outp": [
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func (IP).IsLinkLocalUnicast() bool": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false
            ],
            "Outp": [
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func (IP).IsLoopback() bool": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false
            ],
            "Outp": [
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func (IP).IsMulticast() bool": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false
            ],
            "Outp": [
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func (IP).IsUnspecified() bool": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false
            ],
            "Outp": [
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func (IP).MarshalText() ([]byte, error)": {
      "GeneratedClass": "\n    private class IPMarshalText extends TaintTracking::FunctionModel, Method {\n      // signature: func (IP).MarshalText() ([]byte, error)\n      IPMarshalText() { this.(Method).hasQualifiedName(\"net\", \"IP\", \"MarshalText\") }\n\n      override predicate hasTaintFlow(FunctionInput inp, FunctionOutput outp) {\n        ((inp.isReceiver()) and (outp.isResult(0)))\n      }\n    }",
      "GeneratedConditions": "((inp.isReceiver()) and (outp.isResult(0)))",
      "Blocks": [
         {
            "Inp": [
               true,
               false,
               false
            ],
            "Outp": [
               false,
               true,
               false
            ]
         }
      ],
      "IsEnabled": true
   },
   "func (IP).Mask(mask IPMask) IP": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false,
               false
            ],
            "Outp": [
               false,
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func (IP).String() string": {
      "GeneratedClass": "\n    private class IPString extends TaintTracking::FunctionModel, Method {\n      // signature: func (IP).String() string\n      IPString() { this.(Method).hasQualifiedName(\"net\", \"IP\", \"String\") }\n\n      override predicate hasTaintFlow(FunctionInput inp, FunctionOutput outp) {\n        ((inp.isReceiver()) and (outp.isResult()))\n      }\n    }",
      "GeneratedConditions": "((inp.isReceiver()) and (outp.isResult()))",
      "Blocks": [
         {
            "Inp": [
               true,
               false
            ],
            "Outp": [
               false,
               true
            ]
         }
      ],
      "IsEnabled": true
   },
   "func (IP).To16() IP": {
      "GeneratedClass": "\n    private class IPTo16 extends TaintTracking::FunctionModel, Method {\n      // signature: func (IP).To16() IP\n      IPTo16() { this.(Method).hasQualifiedName(\"net\", \"IP\", \"To16\") }\n\n      override predicate hasTaintFlow(FunctionInput inp, FunctionOutput outp) {\n        ((inp.isReceiver()) and (outp.isResult()))\n      }\n    }",
      "GeneratedConditions": "((inp.isReceiver()) and (outp.isResult()))",
      "Blocks": [
         {
            "Inp": [
               true,
               false
            ],
            "Outp": [
               false,
               true
            ]
         }
      ],
      "IsEnabled": true
   },
   "func (IP).To4() IP": {
      "GeneratedClass": "\n    private class IPTo4 extends TaintTracking::FunctionModel, Method {\n      // signature: func (IP).To4() IP\n      IPTo4() { this.(Method).hasQualifiedName(\"net\", \"IP\", \"To4\") }\n\n      override predicate hasTaintFlow(FunctionInput inp, FunctionOutput outp) {\n        ((inp.isReceiver()) and (outp.isResult()))\n      }\n    }",
      "GeneratedConditions": "((inp.isReceiver()) and (outp.isResult()))",
      "Blocks": [
         {
            "Inp": [
               true,
               false
            ],
            "Outp": [
               false,
               true
            ]
         }
      ],
      "IsEnabled": true
   },
   "func (IPMask).Size() (ones int, bits int)": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false,
               false
            ],
            "Outp": [
               false,
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func (IPMask).String() string": {
      "GeneratedClass": "\n    private class IPMaskString extends TaintTracking::FunctionModel, Method {\n      // signature: func (IPMask).String() string\n      IPMaskString() { this.(Method).hasQualifiedName(\"net\", \"IPMask\", \"String\") }\n\n      override predicate hasTaintFlow(FunctionInput inp, FunctionOutput outp) {\n        ((inp.isReceiver()) and (outp.isResult()))\n      }\n    }",
      "GeneratedConditions": "((inp.isReceiver()) and (outp.isResult()))",
      "Blocks": [
         {
            "Inp": [
               true,
               false
            ],
            "Outp": [
               false,
               true
            ]
         }
      ],
      "IsEnabled": true
   },
   "func (InvalidAddrError).Error() string": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false
            ],
            "Outp": [
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func (InvalidAddrError).Temporary() bool": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false
            ],
            "Outp": [
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func (InvalidAddrError).Timeout() bool": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false
            ],
            "Outp": [
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func (Listener).Accept() (Conn, error)": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false,
               false
            ],
            "Outp": [
               false,
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func (Listener).Addr() Addr": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false
            ],
            "Outp": [
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func (Listener).Close() error": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false
            ],
            "Outp": [
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func (PacketConn).Close() error": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false
            ],
            "Outp": [
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func (PacketConn).LocalAddr() Addr": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false
            ],
            "Outp": [
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func (PacketConn).ReadFrom(p []byte) (n int, addr Addr, err error)": {
      "GeneratedClass": "\n    private class PacketConnReadFrom extends TaintTracking::FunctionModel, Method {\n      // signature: func (PacketConn).ReadFrom(p []byte) (n int, addr Addr, err error)\n      PacketConnReadFrom() {\n        this.implements(\"net\", \"PacketConn\", \"ReadFrom\")\n      }\n\n      override predicate hasTaintFlow(FunctionInput inp, FunctionOutput outp) {\n        ((inp.isReceiver()) and (outp.isParameter(0)))\n      }\n    }",
      "GeneratedConditions": "((inp.isReceiver()) and (outp.isParameter(0)))",
      "Blocks": [
         {
            "Inp": [
               true,
               false,
               false,
               false,
               false
            ],
            "Outp": [
               false,
               true,
               false,
               false,
               false
            ]
         }
      ],
      "IsEnabled": true
   },
   "func (PacketConn).SetDeadline(t time.Time) error": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false,
               false
            ],
            "Outp": [
               false,
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func (PacketConn).SetReadDeadline(t time.Time) error": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false,
               false
            ],
            "Outp": [
               false,
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func (PacketConn).SetWriteDeadline(t time.Time) error": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false,
               false
            ],
            "Outp": [
               false,
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func (PacketConn).WriteTo(p []byte, addr Addr) (n int, err error)": {
      "GeneratedClass": "\n    private class PacketConnWriteTo extends TaintTracking::FunctionModel, Method {\n      // signature: func (PacketConn).WriteTo(p []byte, addr Addr) (n int, err error)\n      PacketConnWriteTo() {\n        this.implements(\"net\", \"PacketConn\", \"WriteTo\")\n      }\n\n      override predicate hasTaintFlow(FunctionInput inp, FunctionOutput outp) {\n        ((inp.isParameter(0)) and (outp.isReceiver()))\n      }\n    }",
      "GeneratedConditions": "((inp.isParameter(0)) and (outp.isReceiver()))",
      "Blocks": [
         {
            "Inp": [
               false,
               true,
               false,
               false,
               false
            ],
            "Outp": [
               true,
               false,
               false,
               false,
               false
            ]
         }
      ],
      "IsEnabled": true
   },
   "func (UnknownNetworkError).Error() string": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false
            ],
            "Outp": [
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func (UnknownNetworkError).Temporary() bool": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false
            ],
            "Outp": [
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func (UnknownNetworkError).Timeout() bool": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false
            ],
            "Outp": [
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func CIDRMask(ones int, bits int) IPMask": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false,
               false
            ],
            "Outp": [
               false,
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func Dial(network string, address string) (Conn, error)": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false,
               false,
               false
            ],
            "Outp": [
               false,
               false,
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func DialIP(network string, laddr *IPAddr, raddr *IPAddr) (*IPConn, error)": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false,
               false,
               false,
               false
            ],
            "Outp": [
               false,
               false,
               false,
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func DialTCP(network string, laddr *TCPAddr, raddr *TCPAddr) (*TCPConn, error)": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false,
               false,
               false,
               false
            ],
            "Outp": [
               false,
               false,
               false,
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func DialTimeout(network string, address string, timeout time.Duration) (Conn, error)": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false,
               false,
               false,
               false
            ],
            "Outp": [
               false,
               false,
               false,
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func DialUDP(network string, laddr *UDPAddr, raddr *UDPAddr) (*UDPConn, error)": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false,
               false,
               false,
               false
            ],
            "Outp": [
               false,
               false,
               false,
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func DialUnix(network string, laddr *UnixAddr, raddr *UnixAddr) (*UnixConn, error)": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false,
               false,
               false,
               false
            ],
            "Outp": [
               false,
               false,
               false,
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func FileConn(f *os.File) (c Conn, err error)": {
      "GeneratedClass": "\n    private class FileConn extends TaintTracking::FunctionModel {\n      // signature: func FileConn(f *os.File) (c Conn, err error)\n      FileConn() { hasQualifiedName(\"net\", \"FileConn\") }\n\n      override predicate hasTaintFlow(FunctionInput inp, FunctionOutput outp) {\n        ((inp.isParameter(0)) and (outp.isResult(0)))\n        or\n        ((inp.isResult(0)) and (outp.isParameter(0)))\n      }\n    }",
      "GeneratedConditions": "((inp.isParameter(0)) and (outp.isResult(0)))\n        or\n        ((inp.isResult(0)) and (outp.isParameter(0)))",
      "Blocks": [
         {
            "Inp": [
               true,
               false,
               false
            ],
            "Outp": [
               false,
               true,
               false
            ]
         },
         {
            "Inp": [
               false,
               true,
               false
            ],
            "Outp": [
               true,
               false,
               false
            ]
         }
      ],
      "IsEnabled": true
   },
   "func FileListener(f *os.File) (ln Listener, err error)": {
      "GeneratedClass": "\n    private class FileListener extends TaintTracking::FunctionModel {\n      // signature: func FileListener(f *os.File) (ln Listener, err error)\n      FileListener() { hasQualifiedName(\"net\", \"FileListener\") }\n\n      override predicate hasTaintFlow(FunctionInput inp, FunctionOutput outp) {\n        ((inp.isParameter(0)) and (outp.isResult(0)))\n        or\n        ((inp.isResult(0)) and (outp.isParameter(0)))\n      }\n    }",
      "GeneratedConditions": "((inp.isParameter(0)) and (outp.isResult(0)))\n        or\n        ((inp.isResult(0)) and (outp.isParameter(0)))",
      "Blocks": [
         {
            "Inp": [
               true,
               false,
               false
            ],
            "Outp": [
               false,
               true,
               false
            ]
         },
         {
            "Inp": [
               false,
               true,
               false
            ],
            "Outp": [
               true,
               false,
               false
            ]
         }
      ],
      "IsEnabled": true
   },
   "func FilePacketConn(f *os.File) (c PacketConn, err error)": {
      "GeneratedClass": "\n    private class FilePacketConn extends TaintTracking::FunctionModel {\n      // signature: func FilePacketConn(f *os.File) (c PacketConn, err error)\n      FilePacketConn() { hasQualifiedName(\"net\", \"FilePacketConn\") }\n\n      override predicate hasTaintFlow(FunctionInput inp, FunctionOutput outp) {\n        ((inp.isParameter(0)) and (outp.isResult(0)))\n        or\n        ((inp.isResult(0)) and (outp.isParameter(0)))\n      }\n    }",
      "GeneratedConditions": "((inp.isParameter(0)) and (outp.isResult(0)))\n        or\n        ((inp.isResult(0)) and (outp.isParameter(0)))",
      "Blocks": [
         {
            "Inp": [
               true,
               false,
               false
            ],
            "Outp": [
               false,
               true,
               false
            ]
         },
         {
            "Inp": [
               false,
               true,
               false
            ],
            "Outp": [
               true,
               false,
               false
            ]
         }
      ],
      "IsEnabled": true
   },
   "func IPv4(a byte, b byte, c byte, d byte) IP": {
      "GeneratedClass": "\n    private class IPv4 extends TaintTracking::FunctionModel {\n      // signature: func IPv4(a byte, b byte, c byte, d byte) IP\n      IPv4() { hasQualifiedName(\"net\", \"IPv4\") }\n\n      override predicate hasTaintFlow(FunctionInput inp, FunctionOutput outp) {\n        ((inp.isParameter(_)) and (outp.isResult()))\n      }\n    }",
      "GeneratedConditions": "((inp.isParameter(_)) and (outp.isResult()))",
      "Blocks": [
         {
            "Inp": [
               true,
               true,
               true,
               true,
               false
            ],
            "Outp": [
               false,
               false,
               false,
               false,
               true
            ]
         }
      ],
      "IsEnabled": true
   },
   "func IPv4Mask(a byte, b byte, c byte, d byte) IPMask": {
      "GeneratedClass": "\n    private class IPv4Mask extends TaintTracking::FunctionModel {\n      // signature: func IPv4Mask(a byte, b byte, c byte, d byte) IPMask\n      IPv4Mask() { hasQualifiedName(\"net\", \"IPv4Mask\") }\n\n      override predicate hasTaintFlow(FunctionInput inp, FunctionOutput outp) {\n        ((inp.isParameter(_)) and (outp.isResult()))\n      }\n    }",
      "GeneratedConditions": "((inp.isParameter(_)) and (outp.isResult()))",
      "Blocks": [
         {
            "Inp": [
               true,
               true,
               true,
               true,
               false
            ],
            "Outp": [
               false,
               false,
               false,
               false,
               true
            ]
         }
      ],
      "IsEnabled": true
   },
   "func InterfaceAddrs() ([]Addr, error)": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false
            ],
            "Outp": [
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func InterfaceByIndex(index int) (*Interface, error)": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false,
               false
            ],
            "Outp": [
               false,
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func InterfaceByName(name string) (*Interface, error)": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false,
               false
            ],
            "Outp": [
               false,
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func Interfaces() ([]Interface, error)": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false
            ],
            "Outp": [
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func JoinHostPort(host string, port string) string": {
      "GeneratedClass": "\n    private class JoinHostPort extends TaintTracking::FunctionModel {\n      // signature: func JoinHostPort(host string, port string) string\n      JoinHostPort() { hasQualifiedName(\"net\", \"JoinHostPort\") }\n\n      override predicate hasTaintFlow(FunctionInput inp, FunctionOutput outp) {\n        ((inp.isParameter(_)) and (outp.isResult()))\n      }\n    }",
      "GeneratedConditions": "((inp.isParameter(_)) and (outp.isResult()))",
      "Blocks": [
         {
            "Inp": [
               true,
               true,
               false
            ],
            "Outp": [
               false,
               false,
               true
            ]
         }
      ],
      "IsEnabled": true
   },
   "func Listen(network string, address string) (Listener, error)": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false,
               false,
               false
            ],
            "Outp": [
               false,
               false,
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func ListenIP(network string, laddr *IPAddr) (*IPConn, error)": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false,
               false,
               false
            ],
            "Outp": [
               false,
               false,
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func ListenMulticastUDP(network string, ifi *Interface, gaddr *UDPAddr) (*UDPConn, error)": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false,
               false,
               false,
               false
            ],
            "Outp": [
               false,
               false,
               false,
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func ListenPacket(network string, address string) (PacketConn, error)": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false,
               false,
               false
            ],
            "Outp": [
               false,
               false,
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func ListenTCP(network string, laddr *TCPAddr) (*TCPListener, error)": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false,
               false,
               false
            ],
            "Outp": [
               false,
               false,
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func ListenUDP(network string, laddr *UDPAddr) (*UDPConn, error)": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false,
               false,
               false
            ],
            "Outp": [
               false,
               false,
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func ListenUnix(network string, laddr *UnixAddr) (*UnixListener, error)": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false,
               false,
               false
            ],
            "Outp": [
               false,
               false,
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func ListenUnixgram(network string, laddr *UnixAddr) (*UnixConn, error)": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false,
               false,
               false
            ],
            "Outp": [
               false,
               false,
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func LookupAddr(addr string) (names []string, err error)": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false,
               false
            ],
            "Outp": [
               false,
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func LookupCNAME(host string) (cname string, err error)": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false,
               false
            ],
            "Outp": [
               false,
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func LookupHost(host string) (addrs []string, err error)": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false,
               false
            ],
            "Outp": [
               false,
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func LookupIP(host string) ([]IP, error)": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false,
               false
            ],
            "Outp": [
               false,
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func LookupMX(name string) ([]*MX, error)": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false,
               false
            ],
            "Outp": [
               false,
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func LookupNS(name string) ([]*NS, error)": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false,
               false
            ],
            "Outp": [
               false,
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func LookupPort(network string, service string) (port int, err error)": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false,
               false,
               false
            ],
            "Outp": [
               false,
               false,
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func LookupSRV(service string, proto string, name string) (cname string, addrs []*SRV, err error)": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false,
               false,
               false,
               false,
               false
            ],
            "Outp": [
               false,
               false,
               false,
               false,
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func LookupTXT(name string) ([]string, error)": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false,
               false
            ],
            "Outp": [
               false,
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func ParseCIDR(s string) (IP, *IPNet, error)": {
      "GeneratedClass": "\n    private class ParseCIDR extends TaintTracking::FunctionModel {\n      // signature: func ParseCIDR(s string) (IP, *IPNet, error)\n      ParseCIDR() { hasQualifiedName(\"net\", \"ParseCIDR\") }\n\n      override predicate hasTaintFlow(FunctionInput inp, FunctionOutput outp) {\n        ((inp.isParameter(0)) and (outp.isResult([0, 1])))\n      }\n    }",
      "GeneratedConditions": "((inp.isParameter(0)) and (outp.isResult([0, 1])))",
      "Blocks": [
         {
            "Inp": [
               true,
               false,
               false,
               false
            ],
            "Outp": [
               false,
               true,
               true,
               false
            ]
         }
      ],
      "IsEnabled": true
   },
   "func ParseIP(s string) IP": {
      "GeneratedClass": "\n    private class ParseIP extends TaintTracking::FunctionModel {\n      // signature: func ParseIP(s string) IP\n      ParseIP() { hasQualifiedName(\"net\", \"ParseIP\") }\n\n      override predicate hasTaintFlow(FunctionInput inp, FunctionOutput outp) {\n        ((inp.isParameter(0)) and (outp.isResult()))\n      }\n    }",
      "GeneratedConditions": "((inp.isParameter(0)) and (outp.isResult()))",
      "Blocks": [
         {
            "Inp": [
               true,
               false
            ],
            "Outp": [
               false,
               true
            ]
         }
      ],
      "IsEnabled": true
   },
   "func ParseMAC(s string) (hw HardwareAddr, err error)": {
      "GeneratedClass": "\n    private class ParseMAC extends TaintTracking::FunctionModel {\n      // signature: func ParseMAC(s string) (hw HardwareAddr, err error)\n      ParseMAC() { hasQualifiedName(\"net\", \"ParseMAC\") }\n\n      override predicate hasTaintFlow(FunctionInput inp, FunctionOutput outp) {\n        ((inp.isParameter(0)) and (outp.isResult(0)))\n      }\n    }",
      "GeneratedConditions": "((inp.isParameter(0)) and (outp.isResult(0)))",
      "Blocks": [
         {
            "Inp": [
               true,
               false,
               false
            ],
            "Outp": [
               false,
               true,
               false
            ]
         }
      ],
      "IsEnabled": true
   },
   "func Pipe() (Conn, Conn)": {
      "GeneratedClass": "\n    private class Pipe extends TaintTracking::FunctionModel {\n      // signature: func Pipe() (Conn, Conn)\n      Pipe() { hasQualifiedName(\"net\", \"Pipe\") }\n\n      override predicate hasTaintFlow(FunctionInput inp, FunctionOutput outp) {\n        ((inp.isResult(0)) and (outp.isResult(1)))\n        or\n        ((inp.isResult(1)) and (outp.isResult(0)))\n      }\n    }",
      "GeneratedConditions": "((inp.isResult(0)) and (outp.isResult(1)))\n        or\n        ((inp.isResult(1)) and (outp.isResult(0)))",
      "Blocks": [
         {
            "Inp": [
               true,
               false
            ],
            "Outp": [
               false,
               true
            ]
         },
         {
            "Inp": [
               false,
               true
            ],
            "Outp": [
               true,
               false
            ]
         }
      ],
      "IsEnabled": true
   },
   "func ResolveIPAddr(network string, address string) (*IPAddr, error)": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false,
               false,
               false
            ],
            "Outp": [
               false,
               false,
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func ResolveTCPAddr(network string, address string) (*TCPAddr, error)": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false,
               false,
               false
            ],
            "Outp": [
               false,
               false,
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func ResolveUDPAddr(network string, address string) (*UDPAddr, error)": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false,
               false,
               false
            ],
            "Outp": [
               false,
               false,
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func ResolveUnixAddr(network string, address string) (*UnixAddr, error)": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false,
               false,
               false
            ],
            "Outp": [
               false,
               false,
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func SplitHostPort(hostport string) (host string, port string, err error)": {
      "GeneratedClass": "\n    private class SplitHostPort extends TaintTracking::FunctionModel {\n      // signature: func SplitHostPort(hostport string) (host string, port string, err error)\n      SplitHostPort() { hasQualifiedName(\"net\", \"SplitHostPort\") }\n\n      override predicate hasTaintFlow(FunctionInput inp, FunctionOutput outp) {\n        ((inp.isParameter(0)) and (outp.isResult([0, 1])))\n      }\n    }",
      "GeneratedConditions": "((inp.isParameter(0)) and (outp.isResult([0, 1])))",
      "Blocks": [
         {
            "Inp": [
               true,
               false,
               false,
               false
            ],
            "Outp": [
               false,
               true,
               true,
               false
            ]
         }
      ],
      "IsEnabled": true
   }
}
