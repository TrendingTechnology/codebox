{"Name":"regexp","PkgPath":"regexp","PkgName":"regexp","ID":"regexp","Funcs":[{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Compile","Signature":"func Compile(expr string) (*Regexp, error)","ID":"FunctionCompile","Docs":["Compile parses a regular expression and returns, if successful,","a Regexp object that can be used to match against text.","","When matching against text, the regexp returns a match that","begins as early as possible in the input (leftmost), and among those","it chooses the one that a backtracking search would have found first.","This so-called leftmost-first matching is the same semantics","that Perl, Python, and other implementations use, although this","package implements it without the expense of backtracking.","For POSIX leftmost-longest matching, see CompilePOSIX."],"Name":"Compile","PkgPath":"regexp","PkgName":"regexp","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"expr","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult(0)","Element":"result","Index":0},"VarName":"","TypeName":"Regexp","PkgName":"regexp","PkgPath":"regexp","QualifiedName":"regexp.Regexp","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":true,"IsRepeated":false},{"Identity":{"Placeholder":"isResult(1)","Element":"result","Index":1},"VarName":"","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"CompilePOSIX","Signature":"func CompilePOSIX(expr string) (*Regexp, error)","ID":"FunctionCompilePOSIX","Docs":["CompilePOSIX is like Compile but restricts the regular expression","to POSIX ERE (egrep) syntax and changes the match semantics to","leftmost-longest.","","That is, when matching against text, the regexp returns a match that","begins as early as possible in the input (leftmost), and among those","it chooses a match that is as long as possible.","This so-called leftmost-longest matching is the same semantics","that early regular expression implementations used and that POSIX","specifies.","","However, there can be multiple leftmost-longest matches, with different","submatch choices, and here this package diverges from POSIX.","Among the possible leftmost-longest matches, this package chooses","the one that a backtracking search would have found first, while POSIX","specifies that the match be chosen to maximize the length of the first","subexpression, then the second, and so on from left to right.","The POSIX rule is computationally prohibitive and not even well-defined.","See https://swtch.com/~rsc/regexp/regexp2.html#posix for details."],"Name":"CompilePOSIX","PkgPath":"regexp","PkgName":"regexp","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"expr","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult(0)","Element":"result","Index":0},"VarName":"","TypeName":"Regexp","PkgName":"regexp","PkgPath":"regexp","QualifiedName":"regexp.Regexp","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":true,"IsRepeated":false},{"Identity":{"Placeholder":"isResult(1)","Element":"result","Index":1},"VarName":"","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Match","Signature":"func Match(pattern string, b []byte) (matched bool, err error)","ID":"FunctionMatch","Docs":["Match reports whether the byte slice b","contains any match of the regular expression pattern.","More complicated queries need to use Compile and the full Regexp interface."],"Name":"Match","PkgPath":"regexp","PkgName":"regexp","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"pattern","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"VarName":"b","TypeName":"byte","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":true}],"Results":[{"Identity":{"Placeholder":"isResult(0)","Element":"result","Index":0},"VarName":"matched","TypeName":"bool","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isResult(1)","Element":"result","Index":1},"VarName":"err","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"MatchReader","Signature":"func MatchReader(pattern string, r io.RuneReader) (matched bool, err error)","ID":"FunctionMatchReader","Docs":["MatchReader reports whether the text returned by the RuneReader","contains any match of the regular expression pattern.","More complicated queries need to use Compile and the full Regexp interface."],"Name":"MatchReader","PkgPath":"regexp","PkgName":"regexp","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"pattern","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"VarName":"r","TypeName":"RuneReader","PkgName":"io","PkgPath":"io","QualifiedName":"io.RuneReader","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult(0)","Element":"result","Index":0},"VarName":"matched","TypeName":"bool","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isResult(1)","Element":"result","Index":1},"VarName":"err","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"MatchString","Signature":"func MatchString(pattern string, s string) (matched bool, err error)","ID":"FunctionMatchString","Docs":["MatchString reports whether the string s","contains any match of the regular expression pattern.","More complicated queries need to use Compile and the full Regexp interface."],"Name":"MatchString","PkgPath":"regexp","PkgName":"regexp","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"pattern","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"VarName":"s","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult(0)","Element":"result","Index":0},"VarName":"matched","TypeName":"bool","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isResult(1)","Element":"result","Index":1},"VarName":"err","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"MustCompile","Signature":"func MustCompile(str string) *Regexp","ID":"FunctionMustCompile","Docs":["MustCompile is like Compile but panics if the expression cannot be parsed.","It simplifies safe initialization of global variables holding compiled regular","expressions."],"Name":"MustCompile","PkgPath":"regexp","PkgName":"regexp","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"str","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"Regexp","PkgName":"regexp","PkgPath":"regexp","QualifiedName":"regexp.Regexp","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":true,"IsRepeated":false}]},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"MustCompilePOSIX","Signature":"func MustCompilePOSIX(str string) *Regexp","ID":"FunctionMustCompilePOSIX","Docs":["MustCompilePOSIX is like CompilePOSIX but panics if the expression cannot be parsed.","It simplifies safe initialization of global variables holding compiled regular","expressions."],"Name":"MustCompilePOSIX","PkgPath":"regexp","PkgName":"regexp","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"str","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"Regexp","PkgName":"regexp","PkgPath":"regexp","QualifiedName":"regexp.Regexp","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":true,"IsRepeated":false}]},{"CodeQL":{"IsEnabled":true,"Pointers":{"Inp":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"Outp":{"Placeholder":"isResult()","Element":"result","Index":0}}},"ClassName":"QuoteMeta","Signature":"func QuoteMeta(s string) string","ID":"FunctionQuoteMeta","Docs":["QuoteMeta returns a string that escapes all regular expression metacharacters","inside the argument text; the returned string is a regular expression matching","the literal text."],"Name":"QuoteMeta","PkgPath":"regexp","PkgName":"regexp","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"s","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"into273","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}]}],"TypeMethods":[{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"RegexpCopy","Docs":["Copy returns a new Regexp object copied from re.","Calling Longest on one copy does not affect another.","","Deprecated: In earlier releases, when using a Regexp in multiple goroutines,","giving each goroutine its own copy helped to avoid lock contention.","As of Go 1.12, using Copy is no longer necessary to avoid lock contention.","Copy may still be appropriate if the reason for its use is to make","two copies with different Longest settings."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Regexp","PkgName":"regexp","PkgPath":"regexp","QualifiedName":"regexp.Regexp","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Regexp-Copy","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Copy","Signature":"func (*Regexp).Copy() *Regexp","ID":"FunctionCopy","Docs":["Copy returns a new Regexp object copied from re.","Calling Longest on one copy does not affect another.","","Deprecated: In earlier releases, when using a Regexp in multiple goroutines,","giving each goroutine its own copy helped to avoid lock contention.","As of Go 1.12, using Copy is no longer necessary to avoid lock contention.","Copy may still be appropriate if the reason for its use is to make","two copies with different Longest settings."],"Name":"Copy","PkgPath":"regexp","PkgName":"regexp","Parameters":null,"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"Regexp","PkgName":"regexp","PkgPath":"regexp","QualifiedName":"regexp.Regexp","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":true,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"RegexpExpand","Docs":["Expand appends template to dst and returns the result; during the","append, Expand replaces variables in the template with corresponding","matches drawn from src. The match slice should have been returned by","FindSubmatchIndex.","","In the template, a variable is denoted by a substring of the form","$name or ${name}, where name is a non-empty sequence of letters,","digits, and underscores. A purely numeric name like $1 refers to","the submatch with the corresponding index; other names refer to","capturing parentheses named with the (?P\u003cname\u003e...) syntax. A","reference to an out of range or unmatched index or a name that is not","present in the regular expression is replaced with an empty slice.","","In the $name form, name is taken to be as long as possible: $1x is","equivalent to ${1x}, not ${1}x, and, $10 is equivalent to ${10}, not ${1}0.","","To insert a literal $ in the output, use $$ in the template."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Regexp","PkgName":"regexp","PkgPath":"regexp","QualifiedName":"regexp.Regexp","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Regexp-Expand","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Expand","Signature":"func (*Regexp).Expand(dst []byte, template []byte, src []byte, match []int) []byte","ID":"FunctionExpand","Docs":["Expand appends template to dst and returns the result; during the","append, Expand replaces variables in the template with corresponding","matches drawn from src. The match slice should have been returned by","FindSubmatchIndex.","","In the template, a variable is denoted by a substring of the form","$name or ${name}, where name is a non-empty sequence of letters,","digits, and underscores. A purely numeric name like $1 refers to","the submatch with the corresponding index; other names refer to","capturing parentheses named with the (?P\u003cname\u003e...) syntax. A","reference to an out of range or unmatched index or a name that is not","present in the regular expression is replaced with an empty slice.","","In the $name form, name is taken to be as long as possible: $1x is","equivalent to ${1x}, not ${1}x, and, $10 is equivalent to ${10}, not ${1}0.","","To insert a literal $ in the output, use $$ in the template."],"Name":"Expand","PkgPath":"regexp","PkgName":"regexp","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"dst","TypeName":"byte","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":true},{"Identity":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"VarName":"template","TypeName":"byte","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":true},{"Identity":{"Placeholder":"isParameter(2)","Element":"parameter","Index":2},"VarName":"src","TypeName":"byte","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":true},{"Identity":{"Placeholder":"isParameter(3)","Element":"parameter","Index":3},"VarName":"match","TypeName":"int","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":true}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"byte","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":true}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"RegexpExpandString","Docs":["ExpandString is like Expand but the template and source are strings.","It appends to and returns a byte slice in order to give the calling","code control over allocation."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Regexp","PkgName":"regexp","PkgPath":"regexp","QualifiedName":"regexp.Regexp","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Regexp-ExpandString","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"ExpandString","Signature":"func (*Regexp).ExpandString(dst []byte, template string, src string, match []int) []byte","ID":"FunctionExpandString","Docs":["ExpandString is like Expand but the template and source are strings.","It appends to and returns a byte slice in order to give the calling","code control over allocation."],"Name":"ExpandString","PkgPath":"regexp","PkgName":"regexp","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"dst","TypeName":"byte","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":true},{"Identity":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"VarName":"template","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(2)","Element":"parameter","Index":2},"VarName":"src","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(3)","Element":"parameter","Index":3},"VarName":"match","TypeName":"int","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":true}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"byte","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":true}]}},{"CodeQL":{"IsEnabled":true,"Pointers":{"Inp":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"Outp":{"Placeholder":"isResult()","Element":"result","Index":0}}},"ClassName":"RegexpFind","Docs":["Find returns a slice holding the text of the leftmost match in b of the regular expression.","A return value of nil indicates no match."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Regexp","PkgName":"regexp","PkgPath":"regexp","QualifiedName":"regexp.Regexp","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Regexp-Find","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Find","Signature":"func (*Regexp).Find(b []byte) []byte","ID":"FunctionFind","Docs":["Find returns a slice holding the text of the leftmost match in b of the regular expression.","A return value of nil indicates no match."],"Name":"Find","PkgPath":"regexp","PkgName":"regexp","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"b","TypeName":"byte","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":true}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"into538","TypeName":"byte","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":true}]}},{"CodeQL":{"IsEnabled":true,"Pointers":{"Inp":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"Outp":{"Placeholder":"isResult()","Element":"result","Index":0}}},"ClassName":"RegexpFindAll","Docs":["FindAll is the 'All' version of Find; it returns a slice of all successive","matches of the expression, as defined by the 'All' description in the","package comment.","A return value of nil indicates no match."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Regexp","PkgName":"regexp","PkgPath":"regexp","QualifiedName":"regexp.Regexp","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Regexp-FindAll","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"FindAll","Signature":"func (*Regexp).FindAll(b []byte, n int) [][]byte","ID":"FunctionFindAll","Docs":["FindAll is the 'All' version of Find; it returns a slice of all successive","matches of the expression, as defined by the 'All' description in the","package comment.","A return value of nil indicates no match."],"Name":"FindAll","PkgPath":"regexp","PkgName":"regexp","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"b","TypeName":"byte","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":true},{"Identity":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"VarName":"n","TypeName":"int","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"into473","TypeName":"byte","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":true}]}},{"CodeQL":{"IsEnabled":true,"Pointers":{"Inp":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"Outp":{"Placeholder":"isResult()","Element":"result","Index":0}}},"ClassName":"RegexpFindAllIndex","Docs":["FindAllIndex is the 'All' version of FindIndex; it returns a slice of all","successive matches of the expression, as defined by the 'All' description","in the package comment.","A return value of nil indicates no match."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Regexp","PkgName":"regexp","PkgPath":"regexp","QualifiedName":"regexp.Regexp","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Regexp-FindAllIndex","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"FindAllIndex","Signature":"func (*Regexp).FindAllIndex(b []byte, n int) [][]int","ID":"FunctionFindAllIndex","Docs":["FindAllIndex is the 'All' version of FindIndex; it returns a slice of all","successive matches of the expression, as defined by the 'All' description","in the package comment.","A return value of nil indicates no match."],"Name":"FindAllIndex","PkgPath":"regexp","PkgName":"regexp","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"b","TypeName":"byte","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":true},{"Identity":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"VarName":"n","TypeName":"int","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"into404","TypeName":"int","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":true}]}},{"CodeQL":{"IsEnabled":true,"Pointers":{"Inp":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"Outp":{"Placeholder":"isResult()","Element":"result","Index":0}}},"ClassName":"RegexpFindAllString","Docs":["FindAllString is the 'All' version of FindString; it returns a slice of all","successive matches of the expression, as defined by the 'All' description","in the package comment.","A return value of nil indicates no match."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Regexp","PkgName":"regexp","PkgPath":"regexp","QualifiedName":"regexp.Regexp","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Regexp-FindAllString","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"FindAllString","Signature":"func (*Regexp).FindAllString(s string, n int) []string","ID":"FunctionFindAllString","Docs":["FindAllString is the 'All' version of FindString; it returns a slice of all","successive matches of the expression, as defined by the 'All' description","in the package comment.","A return value of nil indicates no match."],"Name":"FindAllString","PkgPath":"regexp","PkgName":"regexp","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"s","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"VarName":"n","TypeName":"int","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"into644","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":true}]}},{"CodeQL":{"IsEnabled":true,"Pointers":{"Inp":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"Outp":{"Placeholder":"isResult()","Element":"result","Index":0}}},"ClassName":"RegexpFindAllStringIndex","Docs":["FindAllStringIndex is the 'All' version of FindStringIndex; it returns a","slice of all successive matches of the expression, as defined by the 'All'","description in the package comment.","A return value of nil indicates no match."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Regexp","PkgName":"regexp","PkgPath":"regexp","QualifiedName":"regexp.Regexp","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Regexp-FindAllStringIndex","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"FindAllStringIndex","Signature":"func (*Regexp).FindAllStringIndex(s string, n int) [][]int","ID":"FunctionFindAllStringIndex","Docs":["FindAllStringIndex is the 'All' version of FindStringIndex; it returns a","slice of all successive matches of the expression, as defined by the 'All'","description in the package comment.","A return value of nil indicates no match."],"Name":"FindAllStringIndex","PkgPath":"regexp","PkgName":"regexp","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"s","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"VarName":"n","TypeName":"int","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"into482","TypeName":"int","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":true}]}},{"CodeQL":{"IsEnabled":true,"Pointers":{"Inp":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"Outp":{"Placeholder":"isResult()","Element":"result","Index":0}}},"ClassName":"RegexpFindAllStringSubmatch","Docs":["FindAllStringSubmatch is the 'All' version of FindStringSubmatch; it","returns a slice of all successive matches of the expression, as defined by","the 'All' description in the package comment.","A return value of nil indicates no match."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Regexp","PkgName":"regexp","PkgPath":"regexp","QualifiedName":"regexp.Regexp","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Regexp-FindAllStringSubmatch","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"FindAllStringSubmatch","Signature":"func (*Regexp).FindAllStringSubmatch(s string, n int) [][]string","ID":"FunctionFindAllStringSubmatch","Docs":["FindAllStringSubmatch is the 'All' version of FindStringSubmatch; it","returns a slice of all successive matches of the expression, as defined by","the 'All' description in the package comment.","A return value of nil indicates no match."],"Name":"FindAllStringSubmatch","PkgPath":"regexp","PkgName":"regexp","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"s","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"VarName":"n","TypeName":"int","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"into579","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":true}]}},{"CodeQL":{"IsEnabled":true,"Pointers":{"Inp":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"Outp":{"Placeholder":"isResult()","Element":"result","Index":0}}},"ClassName":"RegexpFindAllStringSubmatchIndex","Docs":["FindAllStringSubmatchIndex is the 'All' version of","FindStringSubmatchIndex; it returns a slice of all successive matches of","the expression, as defined by the 'All' description in the package","comment.","A return value of nil indicates no match."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Regexp","PkgName":"regexp","PkgPath":"regexp","QualifiedName":"regexp.Regexp","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Regexp-FindAllStringSubmatchIndex","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"FindAllStringSubmatchIndex","Signature":"func (*Regexp).FindAllStringSubmatchIndex(s string, n int) [][]int","ID":"FunctionFindAllStringSubmatchIndex","Docs":["FindAllStringSubmatchIndex is the 'All' version of","FindStringSubmatchIndex; it returns a slice of all successive matches of","the expression, as defined by the 'All' description in the package","comment.","A return value of nil indicates no match."],"Name":"FindAllStringSubmatchIndex","PkgPath":"regexp","PkgName":"regexp","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"s","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"VarName":"n","TypeName":"int","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"into808","TypeName":"int","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":true}]}},{"CodeQL":{"IsEnabled":true,"Pointers":{"Inp":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"Outp":{"Placeholder":"isResult()","Element":"result","Index":0}}},"ClassName":"RegexpFindAllSubmatch","Docs":["FindAllSubmatch is the 'All' version of FindSubmatch; it returns a slice","of all successive matches of the expression, as defined by the 'All'","description in the package comment.","A return value of nil indicates no match."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Regexp","PkgName":"regexp","PkgPath":"regexp","QualifiedName":"regexp.Regexp","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Regexp-FindAllSubmatch","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"FindAllSubmatch","Signature":"func (*Regexp).FindAllSubmatch(b []byte, n int) [][][]byte","ID":"FunctionFindAllSubmatch","Docs":["FindAllSubmatch is the 'All' version of FindSubmatch; it returns a slice","of all successive matches of the expression, as defined by the 'All'","description in the package comment.","A return value of nil indicates no match."],"Name":"FindAllSubmatch","PkgPath":"regexp","PkgName":"regexp","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"b","TypeName":"byte","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":true},{"Identity":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"VarName":"n","TypeName":"int","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"into322","TypeName":"byte","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":true}]}},{"CodeQL":{"IsEnabled":true,"Pointers":{"Inp":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"Outp":{"Placeholder":"isResult()","Element":"result","Index":0}}},"ClassName":"RegexpFindAllSubmatchIndex","Docs":["FindAllSubmatchIndex is the 'All' version of FindSubmatchIndex; it returns","a slice of all successive matches of the expression, as defined by the","'All' description in the package comment.","A return value of nil indicates no match."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Regexp","PkgName":"regexp","PkgPath":"regexp","QualifiedName":"regexp.Regexp","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Regexp-FindAllSubmatchIndex","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"FindAllSubmatchIndex","Signature":"func (*Regexp).FindAllSubmatchIndex(b []byte, n int) [][]int","ID":"FunctionFindAllSubmatchIndex","Docs":["FindAllSubmatchIndex is the 'All' version of FindSubmatchIndex; it returns","a slice of all successive matches of the expression, as defined by the","'All' description in the package comment.","A return value of nil indicates no match."],"Name":"FindAllSubmatchIndex","PkgPath":"regexp","PkgName":"regexp","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"b","TypeName":"byte","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":true},{"Identity":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"VarName":"n","TypeName":"int","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"into565","TypeName":"int","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":true}]}},{"CodeQL":{"IsEnabled":true,"Pointers":{"Inp":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"Outp":{"Placeholder":"isResult()","Element":"result","Index":0}}},"ClassName":"RegexpFindIndex","Docs":["FindIndex returns a two-element slice of integers defining the location of","the leftmost match in b of the regular expression. The match itself is at","b[loc[0]:loc[1]].","A return value of nil indicates no match."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Regexp","PkgName":"regexp","PkgPath":"regexp","QualifiedName":"regexp.Regexp","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Regexp-FindIndex","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"FindIndex","Signature":"func (*Regexp).FindIndex(b []byte) (loc []int)","ID":"FunctionFindIndex","Docs":["FindIndex returns a two-element slice of integers defining the location of","the leftmost match in b of the regular expression. The match itself is at","b[loc[0]:loc[1]].","A return value of nil indicates no match."],"Name":"FindIndex","PkgPath":"regexp","PkgName":"regexp","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"b","TypeName":"byte","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":true}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"loc","TypeName":"int","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":true}]}},{"CodeQL":{"IsEnabled":true,"Pointers":{"Inp":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"Outp":{"Placeholder":"isResult()","Element":"result","Index":0}}},"ClassName":"RegexpFindReaderIndex","Docs":["FindReaderIndex returns a two-element slice of integers defining the","location of the leftmost match of the regular expression in text read from","the RuneReader. The match text was found in the input stream at","byte offset loc[0] through loc[1]-1.","A return value of nil indicates no match."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Regexp","PkgName":"regexp","PkgPath":"regexp","QualifiedName":"regexp.Regexp","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Regexp-FindReaderIndex","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"FindReaderIndex","Signature":"func (*Regexp).FindReaderIndex(r io.RuneReader) (loc []int)","ID":"FunctionFindReaderIndex","Docs":["FindReaderIndex returns a two-element slice of integers defining the","location of the leftmost match of the regular expression in text read from","the RuneReader. The match text was found in the input stream at","byte offset loc[0] through loc[1]-1.","A return value of nil indicates no match."],"Name":"FindReaderIndex","PkgPath":"regexp","PkgName":"regexp","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"r","TypeName":"RuneReader","PkgName":"io","PkgPath":"io","QualifiedName":"io.RuneReader","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"loc","TypeName":"int","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":true}]}},{"CodeQL":{"IsEnabled":true,"Pointers":{"Inp":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"Outp":{"Placeholder":"isResult()","Element":"result","Index":0}}},"ClassName":"RegexpFindReaderSubmatchIndex","Docs":["FindReaderSubmatchIndex returns a slice holding the index pairs","identifying the leftmost match of the regular expression of text read by","the RuneReader, and the matches, if any, of its subexpressions, as defined","by the 'Submatch' and 'Index' descriptions in the package comment. A","return value of nil indicates no match."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Regexp","PkgName":"regexp","PkgPath":"regexp","QualifiedName":"regexp.Regexp","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Regexp-FindReaderSubmatchIndex","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"FindReaderSubmatchIndex","Signature":"func (*Regexp).FindReaderSubmatchIndex(r io.RuneReader) []int","ID":"FunctionFindReaderSubmatchIndex","Docs":["FindReaderSubmatchIndex returns a slice holding the index pairs","identifying the leftmost match of the regular expression of text read by","the RuneReader, and the matches, if any, of its subexpressions, as defined","by the 'Submatch' and 'Index' descriptions in the package comment. A","return value of nil indicates no match."],"Name":"FindReaderSubmatchIndex","PkgPath":"regexp","PkgName":"regexp","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"r","TypeName":"RuneReader","PkgName":"io","PkgPath":"io","QualifiedName":"io.RuneReader","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"into208","TypeName":"int","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":true}]}},{"CodeQL":{"IsEnabled":true,"Pointers":{"Inp":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"Outp":{"Placeholder":"isResult()","Element":"result","Index":0}}},"ClassName":"RegexpFindString","Docs":["FindString returns a string holding the text of the leftmost match in s of the regular","expression. If there is no match, the return value is an empty string,","but it will also be empty if the regular expression successfully matches","an empty string. Use FindStringIndex or FindStringSubmatch if it is","necessary to distinguish these cases."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Regexp","PkgName":"regexp","PkgPath":"regexp","QualifiedName":"regexp.Regexp","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Regexp-FindString","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"FindString","Signature":"func (*Regexp).FindString(s string) string","ID":"FunctionFindString","Docs":["FindString returns a string holding the text of the leftmost match in s of the regular","expression. If there is no match, the return value is an empty string,","but it will also be empty if the regular expression successfully matches","an empty string. Use FindStringIndex or FindStringSubmatch if it is","necessary to distinguish these cases."],"Name":"FindString","PkgPath":"regexp","PkgName":"regexp","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"s","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"into749","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":true,"Pointers":{"Inp":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"Outp":{"Placeholder":"isResult()","Element":"result","Index":0}}},"ClassName":"RegexpFindStringIndex","Docs":["FindStringIndex returns a two-element slice of integers defining the","location of the leftmost match in s of the regular expression. The match","itself is at s[loc[0]:loc[1]].","A return value of nil indicates no match."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Regexp","PkgName":"regexp","PkgPath":"regexp","QualifiedName":"regexp.Regexp","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Regexp-FindStringIndex","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"FindStringIndex","Signature":"func (*Regexp).FindStringIndex(s string) (loc []int)","ID":"FunctionFindStringIndex","Docs":["FindStringIndex returns a two-element slice of integers defining the","location of the leftmost match in s of the regular expression. The match","itself is at s[loc[0]:loc[1]].","A return value of nil indicates no match."],"Name":"FindStringIndex","PkgPath":"regexp","PkgName":"regexp","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"s","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"loc","TypeName":"int","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":true}]}},{"CodeQL":{"IsEnabled":true,"Pointers":{"Inp":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"Outp":{"Placeholder":"isResult()","Element":"result","Index":0}}},"ClassName":"RegexpFindStringSubmatch","Docs":["FindStringSubmatch returns a slice of strings holding the text of the","leftmost match of the regular expression in s and the matches, if any, of","its subexpressions, as defined by the 'Submatch' description in the","package comment.","A return value of nil indicates no match."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Regexp","PkgName":"regexp","PkgPath":"regexp","QualifiedName":"regexp.Regexp","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Regexp-FindStringSubmatch","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"FindStringSubmatch","Signature":"func (*Regexp).FindStringSubmatch(s string) []string","ID":"FunctionFindStringSubmatch","Docs":["FindStringSubmatch returns a slice of strings holding the text of the","leftmost match of the regular expression in s and the matches, if any, of","its subexpressions, as defined by the 'Submatch' description in the","package comment.","A return value of nil indicates no match."],"Name":"FindStringSubmatch","PkgPath":"regexp","PkgName":"regexp","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"s","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"into216","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":true}]}},{"CodeQL":{"IsEnabled":true,"Pointers":{"Inp":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"Outp":{"Placeholder":"isResult()","Element":"result","Index":0}}},"ClassName":"RegexpFindStringSubmatchIndex","Docs":["FindStringSubmatchIndex returns a slice holding the index pairs","identifying the leftmost match of the regular expression in s and the","matches, if any, of its subexpressions, as defined by the 'Submatch' and","'Index' descriptions in the package comment.","A return value of nil indicates no match."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Regexp","PkgName":"regexp","PkgPath":"regexp","QualifiedName":"regexp.Regexp","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Regexp-FindStringSubmatchIndex","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"FindStringSubmatchIndex","Signature":"func (*Regexp).FindStringSubmatchIndex(s string) []int","ID":"FunctionFindStringSubmatchIndex","Docs":["FindStringSubmatchIndex returns a slice holding the index pairs","identifying the leftmost match of the regular expression in s and the","matches, if any, of its subexpressions, as defined by the 'Submatch' and","'Index' descriptions in the package comment.","A return value of nil indicates no match."],"Name":"FindStringSubmatchIndex","PkgPath":"regexp","PkgName":"regexp","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"s","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"into440","TypeName":"int","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":true}]}},{"CodeQL":{"IsEnabled":true,"Pointers":{"Inp":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"Outp":{"Placeholder":"isResult()","Element":"result","Index":0}}},"ClassName":"RegexpFindSubmatch","Docs":["FindSubmatch returns a slice of slices holding the text of the leftmost","match of the regular expression in b and the matches, if any, of its","subexpressions, as defined by the 'Submatch' descriptions in the package","comment.","A return value of nil indicates no match."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Regexp","PkgName":"regexp","PkgPath":"regexp","QualifiedName":"regexp.Regexp","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Regexp-FindSubmatch","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"FindSubmatch","Signature":"func (*Regexp).FindSubmatch(b []byte) [][]byte","ID":"FunctionFindSubmatch","Docs":["FindSubmatch returns a slice of slices holding the text of the leftmost","match of the regular expression in b and the matches, if any, of its","subexpressions, as defined by the 'Submatch' descriptions in the package","comment.","A return value of nil indicates no match."],"Name":"FindSubmatch","PkgPath":"regexp","PkgName":"regexp","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"b","TypeName":"byte","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":true}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"into184","TypeName":"byte","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":true}]}},{"CodeQL":{"IsEnabled":true,"Pointers":{"Inp":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"Outp":{"Placeholder":"isResult()","Element":"result","Index":0}}},"ClassName":"RegexpFindSubmatchIndex","Docs":["FindSubmatchIndex returns a slice holding the index pairs identifying the","leftmost match of the regular expression in b and the matches, if any, of","its subexpressions, as defined by the 'Submatch' and 'Index' descriptions","in the package comment.","A return value of nil indicates no match."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Regexp","PkgName":"regexp","PkgPath":"regexp","QualifiedName":"regexp.Regexp","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Regexp-FindSubmatchIndex","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"FindSubmatchIndex","Signature":"func (*Regexp).FindSubmatchIndex(b []byte) []int","ID":"FunctionFindSubmatchIndex","Docs":["FindSubmatchIndex returns a slice holding the index pairs identifying the","leftmost match of the regular expression in b and the matches, if any, of","its subexpressions, as defined by the 'Submatch' and 'Index' descriptions","in the package comment.","A return value of nil indicates no match."],"Name":"FindSubmatchIndex","PkgPath":"regexp","PkgName":"regexp","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"b","TypeName":"byte","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":true}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"into989","TypeName":"int","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":true}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"RegexpLiteralPrefix","Docs":["LiteralPrefix returns a literal string that must begin any match","of the regular expression re. It returns the boolean true if the","literal string comprises the entire regular expression."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Regexp","PkgName":"regexp","PkgPath":"regexp","QualifiedName":"regexp.Regexp","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Regexp-LiteralPrefix","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"LiteralPrefix","Signature":"func (*Regexp).LiteralPrefix() (prefix string, complete bool)","ID":"FunctionLiteralPrefix","Docs":["LiteralPrefix returns a literal string that must begin any match","of the regular expression re. It returns the boolean true if the","literal string comprises the entire regular expression."],"Name":"LiteralPrefix","PkgPath":"regexp","PkgName":"regexp","Parameters":null,"Results":[{"Identity":{"Placeholder":"isResult(0)","Element":"result","Index":0},"VarName":"prefix","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isResult(1)","Element":"result","Index":1},"VarName":"complete","TypeName":"bool","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"RegexpLongest","Docs":["Longest makes future searches prefer the leftmost-longest match.","That is, when matching against text, the regexp returns a match that","begins as early as possible in the input (leftmost), and among those","it chooses a match that is as long as possible.","This method modifies the Regexp and may not be called concurrently","with any other methods."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Regexp","PkgName":"regexp","PkgPath":"regexp","QualifiedName":"regexp.Regexp","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Regexp-Longest","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Longest","Signature":"func (*Regexp).Longest()","ID":"FunctionLongest","Docs":["Longest makes future searches prefer the leftmost-longest match.","That is, when matching against text, the regexp returns a match that","begins as early as possible in the input (leftmost), and among those","it chooses a match that is as long as possible.","This method modifies the Regexp and may not be called concurrently","with any other methods."],"Name":"Longest","PkgPath":"regexp","PkgName":"regexp","Parameters":null,"Results":null}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"RegexpMatch","Docs":["Match reports whether the byte slice b","contains any match of the regular expression re."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Regexp","PkgName":"regexp","PkgPath":"regexp","QualifiedName":"regexp.Regexp","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Regexp-Match","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Match","Signature":"func (*Regexp).Match(b []byte) bool","ID":"FunctionMatch","Docs":["Match reports whether the byte slice b","contains any match of the regular expression re."],"Name":"Match","PkgPath":"regexp","PkgName":"regexp","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"b","TypeName":"byte","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":true}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"bool","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"RegexpMatchReader","Docs":["MatchReader reports whether the text returned by the RuneReader","contains any match of the regular expression re."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Regexp","PkgName":"regexp","PkgPath":"regexp","QualifiedName":"regexp.Regexp","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Regexp-MatchReader","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"MatchReader","Signature":"func (*Regexp).MatchReader(r io.RuneReader) bool","ID":"FunctionMatchReader","Docs":["MatchReader reports whether the text returned by the RuneReader","contains any match of the regular expression re."],"Name":"MatchReader","PkgPath":"regexp","PkgName":"regexp","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"r","TypeName":"RuneReader","PkgName":"io","PkgPath":"io","QualifiedName":"io.RuneReader","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"bool","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"RegexpMatchString","Docs":["MatchString reports whether the string s","contains any match of the regular expression re."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Regexp","PkgName":"regexp","PkgPath":"regexp","QualifiedName":"regexp.Regexp","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Regexp-MatchString","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"MatchString","Signature":"func (*Regexp).MatchString(s string) bool","ID":"FunctionMatchString","Docs":["MatchString reports whether the string s","contains any match of the regular expression re."],"Name":"MatchString","PkgPath":"regexp","PkgName":"regexp","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"s","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"bool","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"RegexpNumSubexp","Docs":["NumSubexp returns the number of parenthesized subexpressions in this Regexp."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Regexp","PkgName":"regexp","PkgPath":"regexp","QualifiedName":"regexp.Regexp","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Regexp-NumSubexp","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"NumSubexp","Signature":"func (*Regexp).NumSubexp() int","ID":"FunctionNumSubexp","Docs":["NumSubexp returns the number of parenthesized subexpressions in this Regexp."],"Name":"NumSubexp","PkgPath":"regexp","PkgName":"regexp","Parameters":null,"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"int","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":true,"Pointers":{"Inp":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"Outp":{"Placeholder":"isResult()","Element":"result","Index":0}}},"ClassName":"RegexpReplaceAll","Docs":["ReplaceAll returns a copy of src, replacing matches of the Regexp","with the replacement text repl. Inside repl, $ signs are interpreted as","in Expand, so for instance $1 represents the text of the first submatch."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Regexp","PkgName":"regexp","PkgPath":"regexp","QualifiedName":"regexp.Regexp","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Regexp-ReplaceAll","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"ReplaceAll","Signature":"func (*Regexp).ReplaceAll(src []byte, repl []byte) []byte","ID":"FunctionReplaceAll","Docs":["ReplaceAll returns a copy of src, replacing matches of the Regexp","with the replacement text repl. Inside repl, $ signs are interpreted as","in Expand, so for instance $1 represents the text of the first submatch."],"Name":"ReplaceAll","PkgPath":"regexp","PkgName":"regexp","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"src","TypeName":"byte","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":true},{"Identity":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"VarName":"repl","TypeName":"byte","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":true}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"into764","TypeName":"byte","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":true}]}},{"CodeQL":{"IsEnabled":true,"Pointers":{"Inp":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"Outp":{"Placeholder":"isResult()","Element":"result","Index":0}}},"ClassName":"RegexpReplaceAllFunc","Docs":["ReplaceAllFunc returns a copy of src in which all matches of the","Regexp have been replaced by the return value of function repl applied","to the matched byte slice. The replacement returned by repl is substituted","directly, without using Expand."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Regexp","PkgName":"regexp","PkgPath":"regexp","QualifiedName":"regexp.Regexp","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Regexp-ReplaceAllFunc","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"ReplaceAllFunc","Signature":"func (*Regexp).ReplaceAllFunc(src []byte, repl func([]byte) []byte) []byte","ID":"FunctionReplaceAllFunc","Docs":["ReplaceAllFunc returns a copy of src in which all matches of the","Regexp have been replaced by the return value of function repl applied","to the matched byte slice. The replacement returned by repl is substituted","directly, without using Expand."],"Name":"ReplaceAllFunc","PkgPath":"regexp","PkgName":"regexp","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"src","TypeName":"byte","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":true},{"Identity":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"VarName":"repl","TypeName":"func([]byte) []byte","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"into372","TypeName":"byte","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":true}]}},{"CodeQL":{"IsEnabled":true,"Pointers":{"Inp":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"Outp":{"Placeholder":"isResult()","Element":"result","Index":0}}},"ClassName":"RegexpReplaceAllLiteral","Docs":["ReplaceAllLiteral returns a copy of src, replacing matches of the Regexp","with the replacement bytes repl. The replacement repl is substituted directly,","without using Expand."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Regexp","PkgName":"regexp","PkgPath":"regexp","QualifiedName":"regexp.Regexp","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Regexp-ReplaceAllLiteral","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"ReplaceAllLiteral","Signature":"func (*Regexp).ReplaceAllLiteral(src []byte, repl []byte) []byte","ID":"FunctionReplaceAllLiteral","Docs":["ReplaceAllLiteral returns a copy of src, replacing matches of the Regexp","with the replacement bytes repl. The replacement repl is substituted directly,","without using Expand."],"Name":"ReplaceAllLiteral","PkgPath":"regexp","PkgName":"regexp","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"src","TypeName":"byte","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":true},{"Identity":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"VarName":"repl","TypeName":"byte","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":true}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"into466","TypeName":"byte","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":true}]}},{"CodeQL":{"IsEnabled":true,"Pointers":{"Inp":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"Outp":{"Placeholder":"isResult()","Element":"result","Index":0}}},"ClassName":"RegexpReplaceAllLiteralString","Docs":["ReplaceAllLiteralString returns a copy of src, replacing matches of the Regexp","with the replacement string repl. The replacement repl is substituted directly,","without using Expand."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Regexp","PkgName":"regexp","PkgPath":"regexp","QualifiedName":"regexp.Regexp","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Regexp-ReplaceAllLiteralString","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"ReplaceAllLiteralString","Signature":"func (*Regexp).ReplaceAllLiteralString(src string, repl string) string","ID":"FunctionReplaceAllLiteralString","Docs":["ReplaceAllLiteralString returns a copy of src, replacing matches of the Regexp","with the replacement string repl. The replacement repl is substituted directly,","without using Expand."],"Name":"ReplaceAllLiteralString","PkgPath":"regexp","PkgName":"regexp","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"src","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"VarName":"repl","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"into889","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":true,"Pointers":{"Inp":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"Outp":{"Placeholder":"isResult()","Element":"result","Index":0}}},"ClassName":"RegexpReplaceAllString","Docs":["ReplaceAllString returns a copy of src, replacing matches of the Regexp","with the replacement string repl. Inside repl, $ signs are interpreted as","in Expand, so for instance $1 represents the text of the first submatch."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Regexp","PkgName":"regexp","PkgPath":"regexp","QualifiedName":"regexp.Regexp","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Regexp-ReplaceAllString","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"ReplaceAllString","Signature":"func (*Regexp).ReplaceAllString(src string, repl string) string","ID":"FunctionReplaceAllString","Docs":["ReplaceAllString returns a copy of src, replacing matches of the Regexp","with the replacement string repl. Inside repl, $ signs are interpreted as","in Expand, so for instance $1 represents the text of the first submatch."],"Name":"ReplaceAllString","PkgPath":"regexp","PkgName":"regexp","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"src","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"VarName":"repl","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"into799","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":true,"Pointers":{"Inp":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"Outp":{"Placeholder":"isResult()","Element":"result","Index":0}}},"ClassName":"RegexpReplaceAllStringFunc","Docs":["ReplaceAllStringFunc returns a copy of src in which all matches of the","Regexp have been replaced by the return value of function repl applied","to the matched substring. The replacement returned by repl is substituted","directly, without using Expand."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Regexp","PkgName":"regexp","PkgPath":"regexp","QualifiedName":"regexp.Regexp","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Regexp-ReplaceAllStringFunc","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"ReplaceAllStringFunc","Signature":"func (*Regexp).ReplaceAllStringFunc(src string, repl func(string) string) string","ID":"FunctionReplaceAllStringFunc","Docs":["ReplaceAllStringFunc returns a copy of src in which all matches of the","Regexp have been replaced by the return value of function repl applied","to the matched substring. The replacement returned by repl is substituted","directly, without using Expand."],"Name":"ReplaceAllStringFunc","PkgPath":"regexp","PkgName":"regexp","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"src","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"VarName":"repl","TypeName":"func(string) string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"into676","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":true,"Pointers":{"Inp":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"Outp":{"Placeholder":"isResult()","Element":"result","Index":0}}},"ClassName":"RegexpSplit","Docs":["Split slices s into substrings separated by the expression and returns a slice of","the substrings between those expression matches.","","The slice returned by this method consists of all the substrings of s","not contained in the slice returned by FindAllString. When called on an expression","that contains no metacharacters, it is equivalent to strings.SplitN.","","Example:","  s := regexp.MustCompile(\"a*\").Split(\"abaabaccadaaae\", 5)","  // s: [\"\", \"b\", \"b\", \"c\", \"cadaaae\"]","","The count determines the number of substrings to return:","  n \u003e 0: at most n substrings; the last substring will be the unsplit remainder.","  n == 0: the result is nil (zero substrings)","  n \u003c 0: all substrings"],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Regexp","PkgName":"regexp","PkgPath":"regexp","QualifiedName":"regexp.Regexp","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Regexp-Split","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Split","Signature":"func (*Regexp).Split(s string, n int) []string","ID":"FunctionSplit","Docs":["Split slices s into substrings separated by the expression and returns a slice of","the substrings between those expression matches.","","The slice returned by this method consists of all the substrings of s","not contained in the slice returned by FindAllString. When called on an expression","that contains no metacharacters, it is equivalent to strings.SplitN.","","Example:","  s := regexp.MustCompile(\"a*\").Split(\"abaabaccadaaae\", 5)","  // s: [\"\", \"b\", \"b\", \"c\", \"cadaaae\"]","","The count determines the number of substrings to return:","  n \u003e 0: at most n substrings; the last substring will be the unsplit remainder.","  n == 0: the result is nil (zero substrings)","  n \u003c 0: all substrings"],"Name":"Split","PkgPath":"regexp","PkgName":"regexp","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"s","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"VarName":"n","TypeName":"int","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"into361","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":true}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"RegexpString","Docs":["String returns the source text used to compile the regular expression."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Regexp","PkgName":"regexp","PkgPath":"regexp","QualifiedName":"regexp.Regexp","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Regexp-String","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"String","Signature":"func (*Regexp).String() string","ID":"FunctionString","Docs":["String returns the source text used to compile the regular expression."],"Name":"String","PkgPath":"regexp","PkgName":"regexp","Parameters":null,"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"RegexpSubexpNames","Docs":["SubexpNames returns the names of the parenthesized subexpressions","in this Regexp. The name for the first sub-expression is names[1],","so that if m is a match slice, the name for m[i] is SubexpNames()[i].","Since the Regexp as a whole cannot be named, names[0] is always","the empty string. The slice should not be modified."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Regexp","PkgName":"regexp","PkgPath":"regexp","QualifiedName":"regexp.Regexp","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Regexp-SubexpNames","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"SubexpNames","Signature":"func (*Regexp).SubexpNames() []string","ID":"FunctionSubexpNames","Docs":["SubexpNames returns the names of the parenthesized subexpressions","in this Regexp. The name for the first sub-expression is names[1],","so that if m is a match slice, the name for m[i] is SubexpNames()[i].","Since the Regexp as a whole cannot be named, names[0] is always","the empty string. The slice should not be modified."],"Name":"SubexpNames","PkgPath":"regexp","PkgName":"regexp","Parameters":null,"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":true}]}}],"InterfaceMethods":[]}