{"Name":"http","PkgPath":"net/http","PkgName":"http","ID":"net/http","Funcs":[{"CodeQL":{"IsEnabled":true,"Pointers":{"Inp":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"Outp":{"Placeholder":"isResult()","Element":"result","Index":0}}},"ClassName":"CanonicalHeaderKey","Signature":"func CanonicalHeaderKey(s string) string","ID":"FunctionCanonicalHeaderKey","Docs":["CanonicalHeaderKey returns the canonical format of the","header key s. The canonicalization converts the first","letter and any letter following a hyphen to upper case;","the rest are converted to lowercase. For example, the","canonical key for \"accept-encoding\" is \"Accept-Encoding\".","If s contains a space or invalid header field bytes, it is","returned without modifications."],"Name":"CanonicalHeaderKey","PkgPath":"net/http","PkgName":"http","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"s","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}]},{"CodeQL":{"IsEnabled":true,"Pointers":{"Inp":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"Outp":{"Placeholder":"isResult()","Element":"result","Index":0}}},"ClassName":"DetectContentType","Signature":"func DetectContentType(data []byte) string","ID":"FunctionDetectContentType","Docs":["DetectContentType implements the algorithm described","at https://mimesniff.spec.whatwg.org/ to determine the","Content-Type of the given data. It considers at most the","first 512 bytes of data. DetectContentType always returns","a valid MIME type: if it cannot determine a more specific one, it","returns \"application/octet-stream\"."],"Name":"DetectContentType","PkgPath":"net/http","PkgName":"http","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"data","TypeName":"byte","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":true}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}]},{"CodeQL":{"IsEnabled":true,"Pointers":{"Inp":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"Outp":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0}}},"ClassName":"Error","Signature":"func Error(w ResponseWriter, error string, code int)","ID":"FunctionError","Docs":["Error replies to the request with the specified error message and HTTP code.","It does not otherwise end the request; the caller should ensure no further","writes are done to w.","The error message should be plain text."],"Name":"Error","PkgPath":"net/http","PkgName":"http","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"w","TypeName":"ResponseWriter","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.ResponseWriter","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"VarName":"error","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(2)","Element":"parameter","Index":2},"VarName":"code","TypeName":"int","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}],"Results":null},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"FileServer","Signature":"func FileServer(root FileSystem) Handler","ID":"FunctionFileServer","Docs":["FileServer returns a handler that serves HTTP requests","with the contents of the file system rooted at root.","","To use the operating system's file system implementation,","use http.Dir:","","    http.Handle(\"/\", http.FileServer(http.Dir(\"/tmp\")))","","As a special case, the returned file server redirects any request","ending in \"/index.html\" to the same path, without the final","\"index.html\"."],"Name":"FileServer","PkgPath":"net/http","PkgName":"http","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"root","TypeName":"FileSystem","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.FileSystem","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"Handler","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.Handler","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Get","Signature":"func Get(url string) (resp *Response, err error)","ID":"FunctionGet","Docs":["Get issues a GET to the specified URL. If the response is one of","the following redirect codes, Get follows the redirect, up to a","maximum of 10 redirects:","","   301 (Moved Permanently)","   302 (Found)","   303 (See Other)","   307 (Temporary Redirect)","   308 (Permanent Redirect)","","An error is returned if there were too many redirects or if there","was an HTTP protocol error. A non-2xx response doesn't cause an","error. Any returned error will be of type *url.Error. The url.Error","value's Timeout method will report true if request timed out or was","canceled.","","When err is nil, resp always contains a non-nil resp.Body.","Caller should close resp.Body when done reading from it.","","Get is a wrapper around DefaultClient.Get.","","To make a request with custom headers, use NewRequest and","DefaultClient.Do."],"Name":"Get","PkgPath":"net/http","PkgName":"http","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"url","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult(0)","Element":"result","Index":0},"VarName":"resp","TypeName":"Response","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.Response","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":true,"IsRepeated":false},{"Identity":{"Placeholder":"isResult(1)","Element":"result","Index":1},"VarName":"err","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Handle","Signature":"func Handle(pattern string, handler Handler)","ID":"FunctionHandle","Docs":["Handle registers the handler for the given pattern","in the DefaultServeMux.","The documentation for ServeMux explains how patterns are matched."],"Name":"Handle","PkgPath":"net/http","PkgName":"http","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"pattern","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"VarName":"handler","TypeName":"Handler","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.Handler","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}],"Results":null},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"HandleFunc","Signature":"func HandleFunc(pattern string, handler func(ResponseWriter, *Request))","ID":"FunctionHandleFunc","Docs":["HandleFunc registers the handler function for the given pattern","in the DefaultServeMux.","The documentation for ServeMux explains how patterns are matched."],"Name":"HandleFunc","PkgPath":"net/http","PkgName":"http","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"pattern","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"VarName":"handler","TypeName":"func(net/http.ResponseWriter, *net/http.Request)","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}],"Results":null},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Head","Signature":"func Head(url string) (resp *Response, err error)","ID":"FunctionHead","Docs":["Head issues a HEAD to the specified URL. If the response is one of","the following redirect codes, Head follows the redirect, up to a","maximum of 10 redirects:","","   301 (Moved Permanently)","   302 (Found)","   303 (See Other)","   307 (Temporary Redirect)","   308 (Permanent Redirect)","","Head is a wrapper around DefaultClient.Head"],"Name":"Head","PkgPath":"net/http","PkgName":"http","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"url","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult(0)","Element":"result","Index":0},"VarName":"resp","TypeName":"Response","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.Response","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":true,"IsRepeated":false},{"Identity":{"Placeholder":"isResult(1)","Element":"result","Index":1},"VarName":"err","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"ListenAndServe","Signature":"func ListenAndServe(addr string, handler Handler) error","ID":"FunctionListenAndServe","Docs":["ListenAndServe listens on the TCP network address addr and then calls","Serve with handler to handle requests on incoming connections.","Accepted connections are configured to enable TCP keep-alives.","","The handler is typically nil, in which case the DefaultServeMux is used.","","ListenAndServe always returns a non-nil error."],"Name":"ListenAndServe","PkgPath":"net/http","PkgName":"http","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"addr","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"VarName":"handler","TypeName":"Handler","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.Handler","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"ListenAndServeTLS","Signature":"func ListenAndServeTLS(addr string, certFile string, keyFile string, handler Handler) error","ID":"FunctionListenAndServeTLS","Docs":["ListenAndServeTLS acts identically to ListenAndServe, except that it","expects HTTPS connections. Additionally, files containing a certificate and","matching private key for the server must be provided. If the certificate","is signed by a certificate authority, the certFile should be the concatenation","of the server's certificate, any intermediates, and the CA's certificate."],"Name":"ListenAndServeTLS","PkgPath":"net/http","PkgName":"http","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"addr","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"VarName":"certFile","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(2)","Element":"parameter","Index":2},"VarName":"keyFile","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(3)","Element":"parameter","Index":3},"VarName":"handler","TypeName":"Handler","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.Handler","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]},{"CodeQL":{"IsEnabled":true,"Pointers":{"Inp":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"Outp":{"Placeholder":"isResult()","Element":"result","Index":0}}},"ClassName":"MaxBytesReader","Signature":"func MaxBytesReader(w ResponseWriter, r io.ReadCloser, n int64) io.ReadCloser","ID":"FunctionMaxBytesReader","Docs":["MaxBytesReader is similar to io.LimitReader but is intended for","limiting the size of incoming request bodies. In contrast to","io.LimitReader, MaxBytesReader's result is a ReadCloser, returns a","non-EOF error for a Read beyond the limit, and closes the","underlying reader when its Close method is called.","","MaxBytesReader prevents clients from accidentally or maliciously","sending a large request and wasting server resources."],"Name":"MaxBytesReader","PkgPath":"net/http","PkgName":"http","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"w","TypeName":"ResponseWriter","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.ResponseWriter","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"VarName":"r","TypeName":"ReadCloser","PkgName":"io","PkgPath":"io","QualifiedName":"io.ReadCloser","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(2)","Element":"parameter","Index":2},"VarName":"n","TypeName":"int64","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"ReadCloser","PkgName":"io","PkgPath":"io","QualifiedName":"io.ReadCloser","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"NewFileTransport","Signature":"func NewFileTransport(fs FileSystem) RoundTripper","ID":"FunctionNewFileTransport","Docs":["NewFileTransport returns a new RoundTripper, serving the provided","FileSystem. The returned RoundTripper ignores the URL host in its","incoming requests, as well as most other properties of the","request.","","The typical use case for NewFileTransport is to register the \"file\"","protocol with a Transport, as in:","","  t := \u0026http.Transport{}","  t.RegisterProtocol(\"file\", http.NewFileTransport(http.Dir(\"/\")))","  c := \u0026http.Client{Transport: t}","  res, err := c.Get(\"file:///etc/passwd\")","  ..."],"Name":"NewFileTransport","PkgPath":"net/http","PkgName":"http","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"fs","TypeName":"FileSystem","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.FileSystem","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"RoundTripper","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.RoundTripper","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]},{"CodeQL":{"IsEnabled":true,"Pointers":{"Inp":{"Placeholder":"isParameter(2)","Element":"parameter","Index":2},"Outp":{"Placeholder":"isResult(0)","Element":"result","Index":0}}},"ClassName":"NewRequest","Signature":"func NewRequest(method string, url string, body io.Reader) (*Request, error)","ID":"FunctionNewRequest","Docs":["NewRequest wraps NewRequestWithContext using the background context."],"Name":"NewRequest","PkgPath":"net/http","PkgName":"http","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"method","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"VarName":"url","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(2)","Element":"parameter","Index":2},"VarName":"body","TypeName":"Reader","PkgName":"io","PkgPath":"io","QualifiedName":"io.Reader","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult(0)","Element":"result","Index":0},"VarName":"","TypeName":"Request","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.Request","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":true,"IsRepeated":false},{"Identity":{"Placeholder":"isResult(1)","Element":"result","Index":1},"VarName":"","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]},{"CodeQL":{"IsEnabled":true,"Pointers":{"Inp":{"Placeholder":"isParameter(3)","Element":"parameter","Index":3},"Outp":{"Placeholder":"isResult(0)","Element":"result","Index":0}}},"ClassName":"NewRequestWithContext","Signature":"func NewRequestWithContext(ctx context.Context, method string, url string, body io.Reader) (*Request, error)","ID":"FunctionNewRequestWithContext","Docs":["NewRequestWithContext returns a new Request given a method, URL, and","optional body.","","If the provided body is also an io.Closer, the returned","Request.Body is set to body and will be closed by the Client","methods Do, Post, and PostForm, and Transport.RoundTrip.","","NewRequestWithContext returns a Request suitable for use with","Client.Do or Transport.RoundTrip. To create a request for use with","testing a Server Handler, either use the NewRequest function in the","net/http/httptest package, use ReadRequest, or manually update the","Request fields. For an outgoing client request, the context","controls the entire lifetime of a request and its response:","obtaining a connection, sending the request, and reading the","response headers and body. See the Request type's documentation for","the difference between inbound and outbound request fields.","","If body is of type *bytes.Buffer, *bytes.Reader, or","*strings.Reader, the returned request's ContentLength is set to its","exact value (instead of -1), GetBody is populated (so 307 and 308","redirects can replay the body), and Body is set to NoBody if the","ContentLength is 0."],"Name":"NewRequestWithContext","PkgPath":"net/http","PkgName":"http","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"ctx","TypeName":"Context","PkgName":"context","PkgPath":"context","QualifiedName":"context.Context","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"VarName":"method","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(2)","Element":"parameter","Index":2},"VarName":"url","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(3)","Element":"parameter","Index":3},"VarName":"body","TypeName":"Reader","PkgName":"io","PkgPath":"io","QualifiedName":"io.Reader","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult(0)","Element":"result","Index":0},"VarName":"","TypeName":"Request","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.Request","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":true,"IsRepeated":false},{"Identity":{"Placeholder":"isResult(1)","Element":"result","Index":1},"VarName":"","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"NewServeMux","Signature":"func NewServeMux() *ServeMux","ID":"FunctionNewServeMux","Docs":["NewServeMux allocates and returns a new ServeMux."],"Name":"NewServeMux","PkgPath":"net/http","PkgName":"http","Parameters":null,"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"ServeMux","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.ServeMux","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":true,"IsRepeated":false}]},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"NotFound","Signature":"func NotFound(w ResponseWriter, r *Request)","ID":"FunctionNotFound","Docs":["NotFound replies to the request with an HTTP 404 not found error."],"Name":"NotFound","PkgPath":"net/http","PkgName":"http","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"w","TypeName":"ResponseWriter","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.ResponseWriter","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"VarName":"r","TypeName":"Request","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.Request","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":true,"IsRepeated":false}],"Results":null},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"NotFoundHandler","Signature":"func NotFoundHandler() Handler","ID":"FunctionNotFoundHandler","Docs":["NotFoundHandler returns a simple request handler","that replies to each request with a ``404 page not found'' reply."],"Name":"NotFoundHandler","PkgPath":"net/http","PkgName":"http","Parameters":null,"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"Handler","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.Handler","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"ParseHTTPVersion","Signature":"func ParseHTTPVersion(vers string) (major int, minor int, ok bool)","ID":"FunctionParseHTTPVersion","Docs":["ParseHTTPVersion parses an HTTP version string.","\"HTTP/1.0\" returns (1, 0, true)."],"Name":"ParseHTTPVersion","PkgPath":"net/http","PkgName":"http","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"vers","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult(0)","Element":"result","Index":0},"VarName":"major","TypeName":"int","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isResult(1)","Element":"result","Index":1},"VarName":"minor","TypeName":"int","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isResult(2)","Element":"result","Index":2},"VarName":"ok","TypeName":"bool","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}]},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"ParseTime","Signature":"func ParseTime(text string) (t time.Time, err error)","ID":"FunctionParseTime","Docs":["ParseTime parses a time header (such as the Date: header),","trying each of the three formats allowed by HTTP/1.1:","TimeFormat, time.RFC850, and time.ANSIC."],"Name":"ParseTime","PkgPath":"net/http","PkgName":"http","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"text","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult(0)","Element":"result","Index":0},"VarName":"t","TypeName":"Time","PkgName":"time","PkgPath":"time","QualifiedName":"time.Time","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":true,"IsRepeated":false},{"Identity":{"Placeholder":"isResult(1)","Element":"result","Index":1},"VarName":"err","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Post","Signature":"func Post(url string, contentType string, body io.Reader) (resp *Response, err error)","ID":"FunctionPost","Docs":["Post issues a POST to the specified URL.","","Caller should close resp.Body when done reading from it.","","If the provided body is an io.Closer, it is closed after the","request.","","Post is a wrapper around DefaultClient.Post.","","To set custom headers, use NewRequest and DefaultClient.Do.","","See the Client.Do method documentation for details on how redirects","are handled."],"Name":"Post","PkgPath":"net/http","PkgName":"http","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"url","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"VarName":"contentType","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(2)","Element":"parameter","Index":2},"VarName":"body","TypeName":"Reader","PkgName":"io","PkgPath":"io","QualifiedName":"io.Reader","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult(0)","Element":"result","Index":0},"VarName":"resp","TypeName":"Response","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.Response","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":true,"IsRepeated":false},{"Identity":{"Placeholder":"isResult(1)","Element":"result","Index":1},"VarName":"err","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"PostForm","Signature":"func PostForm(url string, data net/url.Values) (resp *Response, err error)","ID":"FunctionPostForm","Docs":["PostForm issues a POST to the specified URL, with data's keys and","values URL-encoded as the request body.","","The Content-Type header is set to application/x-www-form-urlencoded.","To set other headers, use NewRequest and DefaultClient.Do.","","When err is nil, resp always contains a non-nil resp.Body.","Caller should close resp.Body when done reading from it.","","PostForm is a wrapper around DefaultClient.PostForm.","","See the Client.Do method documentation for details on how redirects","are handled."],"Name":"PostForm","PkgPath":"net/http","PkgName":"http","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"url","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"VarName":"data","TypeName":"Values","PkgName":"url","PkgPath":"net/url","QualifiedName":"net/url.Values","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult(0)","Element":"result","Index":0},"VarName":"resp","TypeName":"Response","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.Response","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":true,"IsRepeated":false},{"Identity":{"Placeholder":"isResult(1)","Element":"result","Index":1},"VarName":"err","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"ProxyFromEnvironment","Signature":"func ProxyFromEnvironment(req *Request) (*net/url.URL, error)","ID":"FunctionProxyFromEnvironment","Docs":["ProxyFromEnvironment returns the URL of the proxy to use for a","given request, as indicated by the environment variables","HTTP_PROXY, HTTPS_PROXY and NO_PROXY (or the lowercase versions","thereof). HTTPS_PROXY takes precedence over HTTP_PROXY for https","requests.","","The environment values may be either a complete URL or a","\"host[:port]\", in which case the \"http\" scheme is assumed.","An error is returned if the value is a different form.","","A nil URL and nil error are returned if no proxy is defined in the","environment, or a proxy should not be used for the given request,","as defined by NO_PROXY.","","As a special case, if req.URL.Host is \"localhost\" (with or without","a port number), then a nil URL and nil error will be returned."],"Name":"ProxyFromEnvironment","PkgPath":"net/http","PkgName":"http","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"req","TypeName":"Request","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.Request","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":true,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult(0)","Element":"result","Index":0},"VarName":"","TypeName":"URL","PkgName":"url","PkgPath":"net/url","QualifiedName":"net/url.URL","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":true,"IsRepeated":false},{"Identity":{"Placeholder":"isResult(1)","Element":"result","Index":1},"VarName":"","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"ProxyURL","Signature":"func ProxyURL(fixedURL *net/url.URL) func(*Request) (*net/url.URL, error)","ID":"FunctionProxyURL","Docs":["ProxyURL returns a proxy function (for use in a Transport)","that always returns the same URL."],"Name":"ProxyURL","PkgPath":"net/http","PkgName":"http","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"fixedURL","TypeName":"URL","PkgName":"url","PkgPath":"net/url","QualifiedName":"net/url.URL","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":true,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"func(*net/http.Request) (*net/url.URL, error)","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]},{"CodeQL":{"IsEnabled":true,"Pointers":{"Inp":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"Outp":{"Placeholder":"isResult(0)","Element":"result","Index":0}}},"ClassName":"ReadRequest","Signature":"func ReadRequest(b *bufio.Reader) (*Request, error)","ID":"FunctionReadRequest","Docs":["ReadRequest reads and parses an incoming request from b.","","ReadRequest is a low-level function and should only be used for","specialized applications; most code should use the Server to read","requests and handle them via the Handler interface. ReadRequest","only supports HTTP/1.x requests. For HTTP/2, use golang.org/x/net/http2."],"Name":"ReadRequest","PkgPath":"net/http","PkgName":"http","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"b","TypeName":"Reader","PkgName":"bufio","PkgPath":"bufio","QualifiedName":"bufio.Reader","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":true,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult(0)","Element":"result","Index":0},"VarName":"","TypeName":"Request","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.Request","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":true,"IsRepeated":false},{"Identity":{"Placeholder":"isResult(1)","Element":"result","Index":1},"VarName":"","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]},{"CodeQL":{"IsEnabled":true,"Pointers":{"Inp":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"Outp":{"Placeholder":"isResult(0)","Element":"result","Index":0}}},"ClassName":"ReadResponse","Signature":"func ReadResponse(r *bufio.Reader, req *Request) (*Response, error)","ID":"FunctionReadResponse","Docs":["ReadResponse reads and returns an HTTP response from r.","The req parameter optionally specifies the Request that corresponds","to this Response. If nil, a GET request is assumed.","Clients must call resp.Body.Close when finished reading resp.Body.","After that call, clients can inspect resp.Trailer to find key/value","pairs included in the response trailer."],"Name":"ReadResponse","PkgPath":"net/http","PkgName":"http","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"r","TypeName":"Reader","PkgName":"bufio","PkgPath":"bufio","QualifiedName":"bufio.Reader","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":true,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"VarName":"req","TypeName":"Request","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.Request","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":true,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult(0)","Element":"result","Index":0},"VarName":"","TypeName":"Response","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.Response","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":true,"IsRepeated":false},{"Identity":{"Placeholder":"isResult(1)","Element":"result","Index":1},"VarName":"","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Redirect","Signature":"func Redirect(w ResponseWriter, r *Request, url string, code int)","ID":"FunctionRedirect","Docs":["Redirect replies to the request with a redirect to url,","which may be a path relative to the request path.","","The provided code should be in the 3xx range and is usually","StatusMovedPermanently, StatusFound or StatusSeeOther.","","If the Content-Type header has not been set, Redirect sets it","to \"text/html; charset=utf-8\" and writes a small HTML body.","Setting the Content-Type header to any value, including nil,","disables that behavior."],"Name":"Redirect","PkgPath":"net/http","PkgName":"http","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"w","TypeName":"ResponseWriter","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.ResponseWriter","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"VarName":"r","TypeName":"Request","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.Request","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":true,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(2)","Element":"parameter","Index":2},"VarName":"url","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(3)","Element":"parameter","Index":3},"VarName":"code","TypeName":"int","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}],"Results":null},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"RedirectHandler","Signature":"func RedirectHandler(url string, code int) Handler","ID":"FunctionRedirectHandler","Docs":["RedirectHandler returns a request handler that redirects","each request it receives to the given url using the given","status code.","","The provided code should be in the 3xx range and is usually","StatusMovedPermanently, StatusFound or StatusSeeOther."],"Name":"RedirectHandler","PkgPath":"net/http","PkgName":"http","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"url","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"VarName":"code","TypeName":"int","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"Handler","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.Handler","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Serve","Signature":"func Serve(l net.Listener, handler Handler) error","ID":"FunctionServe","Docs":["Serve accepts incoming HTTP connections on the listener l,","creating a new service goroutine for each. The service goroutines","read requests and then call handler to reply to them.","","The handler is typically nil, in which case the DefaultServeMux is used.","","HTTP/2 support is only enabled if the Listener returns *tls.Conn","connections and they were configured with \"h2\" in the TLS","Config.NextProtos.","","Serve always returns a non-nil error."],"Name":"Serve","PkgPath":"net/http","PkgName":"http","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"l","TypeName":"Listener","PkgName":"net","PkgPath":"net","QualifiedName":"net.Listener","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"VarName":"handler","TypeName":"Handler","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.Handler","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"ServeContent","Signature":"func ServeContent(w ResponseWriter, req *Request, name string, modtime time.Time, content io.ReadSeeker)","ID":"FunctionServeContent","Docs":["ServeContent replies to the request using the content in the","provided ReadSeeker. The main benefit of ServeContent over io.Copy","is that it handles Range requests properly, sets the MIME type, and","handles If-Match, If-Unmodified-Since, If-None-Match, If-Modified-Since,","and If-Range requests.","","If the response's Content-Type header is not set, ServeContent","first tries to deduce the type from name's file extension and,","if that fails, falls back to reading the first block of the content","and passing it to DetectContentType.","The name is otherwise unused; in particular it can be empty and is","never sent in the response.","","If modtime is not the zero time or Unix epoch, ServeContent","includes it in a Last-Modified header in the response. If the","request includes an If-Modified-Since header, ServeContent uses","modtime to decide whether the content needs to be sent at all.","","The content's Seek method must work: ServeContent uses","a seek to the end of the content to determine its size.","","If the caller has set w's ETag header formatted per RFC 7232, section 2.3,","ServeContent uses it to handle requests using If-Match, If-None-Match, or If-Range.","","Note that *os.File implements the io.ReadSeeker interface."],"Name":"ServeContent","PkgPath":"net/http","PkgName":"http","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"w","TypeName":"ResponseWriter","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.ResponseWriter","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"VarName":"req","TypeName":"Request","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.Request","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":true,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(2)","Element":"parameter","Index":2},"VarName":"name","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(3)","Element":"parameter","Index":3},"VarName":"modtime","TypeName":"Time","PkgName":"time","PkgPath":"time","QualifiedName":"time.Time","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":true,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(4)","Element":"parameter","Index":4},"VarName":"content","TypeName":"ReadSeeker","PkgName":"io","PkgPath":"io","QualifiedName":"io.ReadSeeker","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}],"Results":null},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"ServeFile","Signature":"func ServeFile(w ResponseWriter, r *Request, name string)","ID":"FunctionServeFile","Docs":["ServeFile replies to the request with the contents of the named","file or directory.","","If the provided file or directory name is a relative path, it is","interpreted relative to the current directory and may ascend to","parent directories. If the provided name is constructed from user","input, it should be sanitized before calling ServeFile.","","As a precaution, ServeFile will reject requests where r.URL.Path","contains a \"..\" path element; this protects against callers who","might unsafely use filepath.Join on r.URL.Path without sanitizing","it and then use that filepath.Join result as the name argument.","","As another special case, ServeFile redirects any request where r.URL.Path","ends in \"/index.html\" to the same path, without the final","\"index.html\". To avoid such redirects either modify the path or","use ServeContent.","","Outside of those two special cases, ServeFile does not use","r.URL.Path for selecting the file or directory to serve; only the","file or directory provided in the name argument is used."],"Name":"ServeFile","PkgPath":"net/http","PkgName":"http","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"w","TypeName":"ResponseWriter","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.ResponseWriter","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"VarName":"r","TypeName":"Request","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.Request","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":true,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(2)","Element":"parameter","Index":2},"VarName":"name","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}],"Results":null},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"ServeTLS","Signature":"func ServeTLS(l net.Listener, handler Handler, certFile string, keyFile string) error","ID":"FunctionServeTLS","Docs":["ServeTLS accepts incoming HTTPS connections on the listener l,","creating a new service goroutine for each. The service goroutines","read requests and then call handler to reply to them.","","The handler is typically nil, in which case the DefaultServeMux is used.","","Additionally, files containing a certificate and matching private key","for the server must be provided. If the certificate is signed by a","certificate authority, the certFile should be the concatenation","of the server's certificate, any intermediates, and the CA's certificate.","","ServeTLS always returns a non-nil error."],"Name":"ServeTLS","PkgPath":"net/http","PkgName":"http","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"l","TypeName":"Listener","PkgName":"net","PkgPath":"net","QualifiedName":"net.Listener","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"VarName":"handler","TypeName":"Handler","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.Handler","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(2)","Element":"parameter","Index":2},"VarName":"certFile","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(3)","Element":"parameter","Index":3},"VarName":"keyFile","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]},{"CodeQL":{"IsEnabled":true,"Pointers":{"Inp":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"Outp":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0}}},"ClassName":"SetCookie","Signature":"func SetCookie(w ResponseWriter, cookie *Cookie)","ID":"FunctionSetCookie","Docs":["SetCookie adds a Set-Cookie header to the provided ResponseWriter's headers.","The provided cookie must have a valid Name. Invalid cookies may be","silently dropped."],"Name":"SetCookie","PkgPath":"net/http","PkgName":"http","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"w","TypeName":"ResponseWriter","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.ResponseWriter","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"VarName":"cookie","TypeName":"Cookie","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.Cookie","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":true,"IsRepeated":false}],"Results":null},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"StatusText","Signature":"func StatusText(code int) string","ID":"FunctionStatusText","Docs":["StatusText returns a text for the HTTP status code. It returns the empty","string if the code is unknown."],"Name":"StatusText","PkgPath":"net/http","PkgName":"http","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"code","TypeName":"int","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}]},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"StripPrefix","Signature":"func StripPrefix(prefix string, h Handler) Handler","ID":"FunctionStripPrefix","Docs":["StripPrefix returns a handler that serves HTTP requests","by removing the given prefix from the request URL's Path","and invoking the handler h. StripPrefix handles a","request for a path that doesn't begin with prefix by","replying with an HTTP 404 not found error."],"Name":"StripPrefix","PkgPath":"net/http","PkgName":"http","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"prefix","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"VarName":"h","TypeName":"Handler","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.Handler","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"Handler","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.Handler","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"TimeoutHandler","Signature":"func TimeoutHandler(h Handler, dt time.Duration, msg string) Handler","ID":"FunctionTimeoutHandler","Docs":["TimeoutHandler returns a Handler that runs h with the given time limit.","","The new Handler calls h.ServeHTTP to handle each request, but if a","call runs for longer than its time limit, the handler responds with","a 503 Service Unavailable error and the given message in its body.","(If msg is empty, a suitable default message will be sent.)","After such a timeout, writes by h to its ResponseWriter will return","ErrHandlerTimeout.","","TimeoutHandler supports the Pusher interface but does not support","the Hijacker or Flusher interfaces."],"Name":"TimeoutHandler","PkgPath":"net/http","PkgName":"http","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"h","TypeName":"Handler","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.Handler","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"VarName":"dt","TypeName":"Duration","PkgName":"time","PkgPath":"time","QualifiedName":"time.Duration","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(2)","Element":"parameter","Index":2},"VarName":"msg","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"Handler","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.Handler","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]}],"TypeMethods":[{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"ClientCloseIdleConnections","Docs":["CloseIdleConnections closes any connections on its Transport which","were previously connected from previous requests but are now","sitting idle in a \"keep-alive\" state. It does not interrupt any","connections currently in use.","","If the Client's Transport does not have a CloseIdleConnections method","then this method does nothing."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Client","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.Client","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Client-CloseIdleConnections","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"CloseIdleConnections","Signature":"func (*Client).CloseIdleConnections()","ID":"FunctionCloseIdleConnections","Docs":["CloseIdleConnections closes any connections on its Transport which","were previously connected from previous requests but are now","sitting idle in a \"keep-alive\" state. It does not interrupt any","connections currently in use.","","If the Client's Transport does not have a CloseIdleConnections method","then this method does nothing."],"Name":"CloseIdleConnections","PkgPath":"net/http","PkgName":"http","Parameters":null,"Results":null}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"ClientDo","Docs":["Do sends an HTTP request and returns an HTTP response, following","policy (such as redirects, cookies, auth) as configured on the","client.","","An error is returned if caused by client policy (such as","CheckRedirect), or failure to speak HTTP (such as a network","connectivity problem). A non-2xx status code doesn't cause an","error.","","If the returned error is nil, the Response will contain a non-nil","Body which the user is expected to close. If the Body is not both","read to EOF and closed, the Client's underlying RoundTripper","(typically Transport) may not be able to re-use a persistent TCP","connection to the server for a subsequent \"keep-alive\" request.","","The request Body, if non-nil, will be closed by the underlying","Transport, even on errors.","","On error, any Response can be ignored. A non-nil Response with a","non-nil error only occurs when CheckRedirect fails, and even then","the returned Response.Body is already closed.","","Generally Get, Post, or PostForm will be used instead of Do.","","If the server replies with a redirect, the Client first uses the","CheckRedirect function to determine whether the redirect should be","followed. If permitted, a 301, 302, or 303 redirect causes","subsequent requests to use HTTP method GET","(or HEAD if the original request was HEAD), with no body.","A 307 or 308 redirect preserves the original HTTP method and body,","provided that the Request.GetBody function is defined.","The NewRequest function automatically sets GetBody for common","standard library body types.","","Any returned error will be of type *url.Error. The url.Error","value's Timeout method will report true if request timed out or was","canceled."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Client","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.Client","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Client-Do","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Do","Signature":"func (*Client).Do(req *Request) (*Response, error)","ID":"FunctionDo","Docs":["Do sends an HTTP request and returns an HTTP response, following","policy (such as redirects, cookies, auth) as configured on the","client.","","An error is returned if caused by client policy (such as","CheckRedirect), or failure to speak HTTP (such as a network","connectivity problem). A non-2xx status code doesn't cause an","error.","","If the returned error is nil, the Response will contain a non-nil","Body which the user is expected to close. If the Body is not both","read to EOF and closed, the Client's underlying RoundTripper","(typically Transport) may not be able to re-use a persistent TCP","connection to the server for a subsequent \"keep-alive\" request.","","The request Body, if non-nil, will be closed by the underlying","Transport, even on errors.","","On error, any Response can be ignored. A non-nil Response with a","non-nil error only occurs when CheckRedirect fails, and even then","the returned Response.Body is already closed.","","Generally Get, Post, or PostForm will be used instead of Do.","","If the server replies with a redirect, the Client first uses the","CheckRedirect function to determine whether the redirect should be","followed. If permitted, a 301, 302, or 303 redirect causes","subsequent requests to use HTTP method GET","(or HEAD if the original request was HEAD), with no body.","A 307 or 308 redirect preserves the original HTTP method and body,","provided that the Request.GetBody function is defined.","The NewRequest function automatically sets GetBody for common","standard library body types.","","Any returned error will be of type *url.Error. The url.Error","value's Timeout method will report true if request timed out or was","canceled."],"Name":"Do","PkgPath":"net/http","PkgName":"http","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"req","TypeName":"Request","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.Request","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":true,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult(0)","Element":"result","Index":0},"VarName":"","TypeName":"Response","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.Response","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":true,"IsRepeated":false},{"Identity":{"Placeholder":"isResult(1)","Element":"result","Index":1},"VarName":"","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"ClientGet","Docs":["Get issues a GET to the specified URL. If the response is one of the","following redirect codes, Get follows the redirect after calling the","Client's CheckRedirect function:","","   301 (Moved Permanently)","   302 (Found)","   303 (See Other)","   307 (Temporary Redirect)","   308 (Permanent Redirect)","","An error is returned if the Client's CheckRedirect function fails","or if there was an HTTP protocol error. A non-2xx response doesn't","cause an error. Any returned error will be of type *url.Error. The","url.Error value's Timeout method will report true if the request","timed out.","","When err is nil, resp always contains a non-nil resp.Body.","Caller should close resp.Body when done reading from it.","","To make a request with custom headers, use NewRequest and Client.Do."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Client","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.Client","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Client-Get","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Get","Signature":"func (*Client).Get(url string) (resp *Response, err error)","ID":"FunctionGet","Docs":["Get issues a GET to the specified URL. If the response is one of the","following redirect codes, Get follows the redirect after calling the","Client's CheckRedirect function:","","   301 (Moved Permanently)","   302 (Found)","   303 (See Other)","   307 (Temporary Redirect)","   308 (Permanent Redirect)","","An error is returned if the Client's CheckRedirect function fails","or if there was an HTTP protocol error. A non-2xx response doesn't","cause an error. Any returned error will be of type *url.Error. The","url.Error value's Timeout method will report true if the request","timed out.","","When err is nil, resp always contains a non-nil resp.Body.","Caller should close resp.Body when done reading from it.","","To make a request with custom headers, use NewRequest and Client.Do."],"Name":"Get","PkgPath":"net/http","PkgName":"http","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"url","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult(0)","Element":"result","Index":0},"VarName":"resp","TypeName":"Response","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.Response","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":true,"IsRepeated":false},{"Identity":{"Placeholder":"isResult(1)","Element":"result","Index":1},"VarName":"err","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"ClientHead","Docs":["Head issues a HEAD to the specified URL. If the response is one of the","following redirect codes, Head follows the redirect after calling the","Client's CheckRedirect function:","","   301 (Moved Permanently)","   302 (Found)","   303 (See Other)","   307 (Temporary Redirect)","   308 (Permanent Redirect)"],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Client","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.Client","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Client-Head","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Head","Signature":"func (*Client).Head(url string) (resp *Response, err error)","ID":"FunctionHead","Docs":["Head issues a HEAD to the specified URL. If the response is one of the","following redirect codes, Head follows the redirect after calling the","Client's CheckRedirect function:","","   301 (Moved Permanently)","   302 (Found)","   303 (See Other)","   307 (Temporary Redirect)","   308 (Permanent Redirect)"],"Name":"Head","PkgPath":"net/http","PkgName":"http","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"url","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult(0)","Element":"result","Index":0},"VarName":"resp","TypeName":"Response","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.Response","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":true,"IsRepeated":false},{"Identity":{"Placeholder":"isResult(1)","Element":"result","Index":1},"VarName":"err","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"ClientPost","Docs":["Post issues a POST to the specified URL.","","Caller should close resp.Body when done reading from it.","","If the provided body is an io.Closer, it is closed after the","request.","","To set custom headers, use NewRequest and Client.Do.","","See the Client.Do method documentation for details on how redirects","are handled."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Client","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.Client","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Client-Post","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Post","Signature":"func (*Client).Post(url string, contentType string, body io.Reader) (resp *Response, err error)","ID":"FunctionPost","Docs":["Post issues a POST to the specified URL.","","Caller should close resp.Body when done reading from it.","","If the provided body is an io.Closer, it is closed after the","request.","","To set custom headers, use NewRequest and Client.Do.","","See the Client.Do method documentation for details on how redirects","are handled."],"Name":"Post","PkgPath":"net/http","PkgName":"http","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"url","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"VarName":"contentType","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(2)","Element":"parameter","Index":2},"VarName":"body","TypeName":"Reader","PkgName":"io","PkgPath":"io","QualifiedName":"io.Reader","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult(0)","Element":"result","Index":0},"VarName":"resp","TypeName":"Response","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.Response","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":true,"IsRepeated":false},{"Identity":{"Placeholder":"isResult(1)","Element":"result","Index":1},"VarName":"err","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"ClientPostForm","Docs":["PostForm issues a POST to the specified URL,","with data's keys and values URL-encoded as the request body.","","The Content-Type header is set to application/x-www-form-urlencoded.","To set other headers, use NewRequest and Client.Do.","","When err is nil, resp always contains a non-nil resp.Body.","Caller should close resp.Body when done reading from it.","","See the Client.Do method documentation for details on how redirects","are handled."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Client","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.Client","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Client-PostForm","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"PostForm","Signature":"func (*Client).PostForm(url string, data net/url.Values) (resp *Response, err error)","ID":"FunctionPostForm","Docs":["PostForm issues a POST to the specified URL,","with data's keys and values URL-encoded as the request body.","","The Content-Type header is set to application/x-www-form-urlencoded.","To set other headers, use NewRequest and Client.Do.","","When err is nil, resp always contains a non-nil resp.Body.","Caller should close resp.Body when done reading from it.","","See the Client.Do method documentation for details on how redirects","are handled."],"Name":"PostForm","PkgPath":"net/http","PkgName":"http","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"url","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"VarName":"data","TypeName":"Values","PkgName":"url","PkgPath":"net/url","QualifiedName":"net/url.Values","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult(0)","Element":"result","Index":0},"VarName":"resp","TypeName":"Response","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.Response","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":true,"IsRepeated":false},{"Identity":{"Placeholder":"isResult(1)","Element":"result","Index":1},"VarName":"err","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"ConnStateString","Docs":[],"IsOnPtr":false,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"ConnState","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.ConnState","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-ConnState-String","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"String","Signature":"func (ConnState).String() string","ID":"FunctionString","Docs":[],"Name":"String","PkgPath":"net/http","PkgName":"http","Parameters":null,"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"CookieString","Docs":["String returns the serialization of the cookie for use in a Cookie","header (if only Name and Value are set) or a Set-Cookie response","header (if other fields are set).","If c is nil or c.Name is invalid, the empty string is returned."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Cookie","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.Cookie","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Cookie-String","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"String","Signature":"func (*Cookie).String() string","ID":"FunctionString","Docs":["String returns the serialization of the cookie for use in a Cookie","header (if only Name and Value are set) or a Set-Cookie response","header (if other fields are set).","If c is nil or c.Name is invalid, the empty string is returned."],"Name":"String","PkgPath":"net/http","PkgName":"http","Parameters":null,"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"DirOpen","Docs":["Open implements FileSystem using os.Open, opening files for reading rooted","and relative to the directory d."],"IsOnPtr":false,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Dir","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.Dir","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Dir-Open","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Open","Signature":"func (Dir).Open(name string) (File, error)","ID":"FunctionOpen","Docs":["Open implements FileSystem using os.Open, opening files for reading rooted","and relative to the directory d."],"Name":"Open","PkgPath":"net/http","PkgName":"http","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"name","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult(0)","Element":"result","Index":0},"VarName":"","TypeName":"File","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.File","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isResult(1)","Element":"result","Index":1},"VarName":"","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"HandlerFuncServeHTTP","Docs":["ServeHTTP calls f(w, r)."],"IsOnPtr":false,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"HandlerFunc","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.HandlerFunc","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-HandlerFunc-ServeHTTP","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"ServeHTTP","Signature":"func (HandlerFunc).ServeHTTP(w ResponseWriter, r *Request)","ID":"FunctionServeHTTP","Docs":["ServeHTTP calls f(w, r)."],"Name":"ServeHTTP","PkgPath":"net/http","PkgName":"http","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"w","TypeName":"ResponseWriter","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.ResponseWriter","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"VarName":"r","TypeName":"Request","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.Request","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":true,"IsRepeated":false}],"Results":null}},{"CodeQL":{"IsEnabled":true,"Pointers":{"Inp":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"Outp":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1}}},"ClassName":"HeaderAdd","Docs":["Add adds the key, value pair to the header.","It appends to any existing values associated with key.","The key is case insensitive; it is canonicalized by","CanonicalHeaderKey."],"IsOnPtr":false,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Header","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.Header","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Header-Add","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Add","Signature":"func (Header).Add(key string, value string)","ID":"FunctionAdd","Docs":["Add adds the key, value pair to the header.","It appends to any existing values associated with key.","The key is case insensitive; it is canonicalized by","CanonicalHeaderKey."],"Name":"Add","PkgPath":"net/http","PkgName":"http","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"key","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"VarName":"value","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}],"Results":null}},{"CodeQL":{"IsEnabled":true,"Pointers":{"Inp":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"Outp":{"Placeholder":"isResult()","Element":"result","Index":0}}},"ClassName":"HeaderClone","Docs":["Clone returns a copy of h or nil if h is nil."],"IsOnPtr":false,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Header","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.Header","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Header-Clone","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Clone","Signature":"func (Header).Clone() Header","ID":"FunctionClone","Docs":["Clone returns a copy of h or nil if h is nil."],"Name":"Clone","PkgPath":"net/http","PkgName":"http","Parameters":null,"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"Header","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.Header","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"HeaderDel","Docs":["Del deletes the values associated with key.","The key is case insensitive; it is canonicalized by","CanonicalHeaderKey."],"IsOnPtr":false,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Header","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.Header","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Header-Del","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Del","Signature":"func (Header).Del(key string)","ID":"FunctionDel","Docs":["Del deletes the values associated with key.","The key is case insensitive; it is canonicalized by","CanonicalHeaderKey."],"Name":"Del","PkgPath":"net/http","PkgName":"http","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"key","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}],"Results":null}},{"CodeQL":{"IsEnabled":true,"Pointers":{"Inp":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"Outp":{"Placeholder":"isResult()","Element":"result","Index":0}}},"ClassName":"HeaderGet","Docs":["Get gets the first value associated with the given key. If","there are no values associated with the key, Get returns \"\".","It is case insensitive; textproto.CanonicalMIMEHeaderKey is","used to canonicalize the provided key. To use non-canonical keys,","access the map directly."],"IsOnPtr":false,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Header","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.Header","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Header-Get","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Get","Signature":"func (Header).Get(key string) string","ID":"FunctionGet","Docs":["Get gets the first value associated with the given key. If","there are no values associated with the key, Get returns \"\".","It is case insensitive; textproto.CanonicalMIMEHeaderKey is","used to canonicalize the provided key. To use non-canonical keys,","access the map directly."],"Name":"Get","PkgPath":"net/http","PkgName":"http","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"key","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":true,"Pointers":{"Inp":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"Outp":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1}}},"ClassName":"HeaderSet","Docs":["Set sets the header entries associated with key to the","single element value. It replaces any existing values","associated with key. The key is case insensitive; it is","canonicalized by textproto.CanonicalMIMEHeaderKey.","To use non-canonical keys, assign to the map directly."],"IsOnPtr":false,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Header","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.Header","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Header-Set","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Set","Signature":"func (Header).Set(key string, value string)","ID":"FunctionSet","Docs":["Set sets the header entries associated with key to the","single element value. It replaces any existing values","associated with key. The key is case insensitive; it is","canonicalized by textproto.CanonicalMIMEHeaderKey.","To use non-canonical keys, assign to the map directly."],"Name":"Set","PkgPath":"net/http","PkgName":"http","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"key","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"VarName":"value","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}],"Results":null}},{"CodeQL":{"IsEnabled":true,"Pointers":{"Inp":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"Outp":{"Placeholder":"isResult()","Element":"result","Index":0}}},"ClassName":"HeaderValues","Docs":["Values returns all values associated with the given key.","It is case insensitive; textproto.CanonicalMIMEHeaderKey is","used to canonicalize the provided key. To use non-canonical","keys, access the map directly.","The returned slice is not a copy."],"IsOnPtr":false,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Header","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.Header","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Header-Values","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Values","Signature":"func (Header).Values(key string) []string","ID":"FunctionValues","Docs":["Values returns all values associated with the given key.","It is case insensitive; textproto.CanonicalMIMEHeaderKey is","used to canonicalize the provided key. To use non-canonical","keys, access the map directly.","The returned slice is not a copy."],"Name":"Values","PkgPath":"net/http","PkgName":"http","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"key","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":true}]}},{"CodeQL":{"IsEnabled":true,"Pointers":{"Inp":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"Outp":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0}}},"ClassName":"HeaderWrite","Docs":["Write writes a header in wire format."],"IsOnPtr":false,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Header","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.Header","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Header-Write","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Write","Signature":"func (Header).Write(w io.Writer) error","ID":"FunctionWrite","Docs":["Write writes a header in wire format."],"Name":"Write","PkgPath":"net/http","PkgName":"http","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"w","TypeName":"Writer","PkgName":"io","PkgPath":"io","QualifiedName":"io.Writer","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":true,"Pointers":{"Inp":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"Outp":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0}}},"ClassName":"HeaderWriteSubset","Docs":["WriteSubset writes a header in wire format.","If exclude is not nil, keys where exclude[key] == true are not written.","Keys are not canonicalized before checking the exclude map."],"IsOnPtr":false,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Header","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.Header","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Header-WriteSubset","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"WriteSubset","Signature":"func (Header).WriteSubset(w io.Writer, exclude map[string]bool) error","ID":"FunctionWriteSubset","Docs":["WriteSubset writes a header in wire format.","If exclude is not nil, keys where exclude[key] == true are not written.","Keys are not canonicalized before checking the exclude map."],"Name":"WriteSubset","PkgPath":"net/http","PkgName":"http","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"w","TypeName":"Writer","PkgName":"io","PkgPath":"io","QualifiedName":"io.Writer","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"VarName":"exclude","TypeName":"map[string]bool","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"ProtocolErrorError","Docs":[],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"ProtocolError","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.ProtocolError","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-ProtocolError-Error","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Error","Signature":"func (*ProtocolError).Error() string","ID":"FunctionError","Docs":[],"Name":"Error","PkgPath":"net/http","PkgName":"http","Parameters":null,"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":true,"Pointers":{"Inp":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"Outp":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1}}},"ClassName":"RequestAddCookie","Docs":["AddCookie adds a cookie to the request. Per RFC 6265 section 5.4,","AddCookie does not attach more than one Cookie header field. That","means all cookies, if any, are written into the same line,","separated by semicolon."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Request","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.Request","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Request-AddCookie","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"AddCookie","Signature":"func (*Request).AddCookie(c *Cookie)","ID":"FunctionAddCookie","Docs":["AddCookie adds a cookie to the request. Per RFC 6265 section 5.4,","AddCookie does not attach more than one Cookie header field. That","means all cookies, if any, are written into the same line,","separated by semicolon."],"Name":"AddCookie","PkgPath":"net/http","PkgName":"http","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"c","TypeName":"Cookie","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.Cookie","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":true,"IsRepeated":false}],"Results":null}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"isResult(0)","Element":"result","Index":0},"Outp":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1}}},"ClassName":"RequestBasicAuth","Docs":["BasicAuth returns the username and password provided in the request's","Authorization header, if the request uses HTTP Basic Authentication.","See RFC 2617, Section 2."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Request","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.Request","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Request-BasicAuth","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"BasicAuth","Signature":"func (*Request).BasicAuth() (username string, password string, ok bool)","ID":"FunctionBasicAuth","Docs":["BasicAuth returns the username and password provided in the request's","Authorization header, if the request uses HTTP Basic Authentication.","See RFC 2617, Section 2."],"Name":"BasicAuth","PkgPath":"net/http","PkgName":"http","Parameters":null,"Results":[{"Identity":{"Placeholder":"isResult(0)","Element":"result","Index":0},"VarName":"username","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isResult(1)","Element":"result","Index":1},"VarName":"password","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isResult(2)","Element":"result","Index":2},"VarName":"ok","TypeName":"bool","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":true,"Pointers":{"Inp":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"Outp":{"Placeholder":"isResult()","Element":"result","Index":0}}},"ClassName":"RequestClone","Docs":["Clone returns a deep copy of r with its context changed to ctx.","The provided ctx must be non-nil.","","For an outgoing client request, the context controls the entire","lifetime of a request and its response: obtaining a connection,","sending the request, and reading the response headers and body."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Request","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.Request","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Request-Clone","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Clone","Signature":"func (*Request).Clone(ctx context.Context) *Request","ID":"FunctionClone","Docs":["Clone returns a deep copy of r with its context changed to ctx.","The provided ctx must be non-nil.","","For an outgoing client request, the context controls the entire","lifetime of a request and its response: obtaining a connection,","sending the request, and reading the response headers and body."],"Name":"Clone","PkgPath":"net/http","PkgName":"http","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"ctx","TypeName":"Context","PkgName":"context","PkgPath":"context","QualifiedName":"context.Context","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"Request","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.Request","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":true,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"RequestContext","Docs":["Context returns the request's context. To change the context, use","WithContext.","","The returned context is always non-nil; it defaults to the","background context.","","For outgoing client requests, the context controls cancellation.","","For incoming server requests, the context is canceled when the","client's connection closes, the request is canceled (with HTTP/2),","or when the ServeHTTP method returns."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Request","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.Request","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Request-Context","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Context","Signature":"func (*Request).Context() context.Context","ID":"FunctionContext","Docs":["Context returns the request's context. To change the context, use","WithContext.","","The returned context is always non-nil; it defaults to the","background context.","","For outgoing client requests, the context controls cancellation.","","For incoming server requests, the context is canceled when the","client's connection closes, the request is canceled (with HTTP/2),","or when the ServeHTTP method returns."],"Name":"Context","PkgPath":"net/http","PkgName":"http","Parameters":null,"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"Context","PkgName":"context","PkgPath":"context","QualifiedName":"context.Context","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"RequestCookie","Docs":["Cookie returns the named cookie provided in the request or","ErrNoCookie if not found.","If multiple cookies match the given name, only one cookie will","be returned."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Request","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.Request","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Request-Cookie","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Cookie","Signature":"func (*Request).Cookie(name string) (*Cookie, error)","ID":"FunctionCookie","Docs":["Cookie returns the named cookie provided in the request or","ErrNoCookie if not found.","If multiple cookies match the given name, only one cookie will","be returned."],"Name":"Cookie","PkgPath":"net/http","PkgName":"http","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"name","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult(0)","Element":"result","Index":0},"VarName":"","TypeName":"Cookie","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.Cookie","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":true,"IsRepeated":false},{"Identity":{"Placeholder":"isResult(1)","Element":"result","Index":1},"VarName":"","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"RequestCookies","Docs":["Cookies parses and returns the HTTP cookies sent with the request."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Request","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.Request","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Request-Cookies","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Cookies","Signature":"func (*Request).Cookies() []*Cookie","ID":"FunctionCookies","Docs":["Cookies parses and returns the HTTP cookies sent with the request."],"Name":"Cookies","PkgPath":"net/http","PkgName":"http","Parameters":null,"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"Cookie","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.Cookie","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":true}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"RequestFormFile","Docs":["FormFile returns the first file for the provided form key.","FormFile calls ParseMultipartForm and ParseForm if necessary."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Request","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.Request","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Request-FormFile","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"FormFile","Signature":"func (*Request).FormFile(key string) (mime/multipart.File, *mime/multipart.FileHeader, error)","ID":"FunctionFormFile","Docs":["FormFile returns the first file for the provided form key.","FormFile calls ParseMultipartForm and ParseForm if necessary."],"Name":"FormFile","PkgPath":"net/http","PkgName":"http","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"key","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult(0)","Element":"result","Index":0},"VarName":"","TypeName":"File","PkgName":"multipart","PkgPath":"mime/multipart","QualifiedName":"mime/multipart.File","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isResult(1)","Element":"result","Index":1},"VarName":"","TypeName":"FileHeader","PkgName":"multipart","PkgPath":"mime/multipart","QualifiedName":"mime/multipart.FileHeader","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":true,"IsRepeated":false},{"Identity":{"Placeholder":"isResult(2)","Element":"result","Index":2},"VarName":"","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"RequestFormValue","Docs":["FormValue returns the first value for the named component of the query.","POST and PUT body parameters take precedence over URL query string values.","FormValue calls ParseMultipartForm and ParseForm if necessary and ignores","any errors returned by these functions.","If key is not present, FormValue returns the empty string.","To access multiple values of the same key, call ParseForm and","then inspect Request.Form directly."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Request","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.Request","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Request-FormValue","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"FormValue","Signature":"func (*Request).FormValue(key string) string","ID":"FunctionFormValue","Docs":["FormValue returns the first value for the named component of the query.","POST and PUT body parameters take precedence over URL query string values.","FormValue calls ParseMultipartForm and ParseForm if necessary and ignores","any errors returned by these functions.","If key is not present, FormValue returns the empty string.","To access multiple values of the same key, call ParseForm and","then inspect Request.Form directly."],"Name":"FormValue","PkgPath":"net/http","PkgName":"http","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"key","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"RequestMultipartReader","Docs":["MultipartReader returns a MIME multipart reader if this is a","multipart/form-data or a multipart/mixed POST request, else returns nil and an error.","Use this function instead of ParseMultipartForm to","process the request body as a stream."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Request","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.Request","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Request-MultipartReader","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"MultipartReader","Signature":"func (*Request).MultipartReader() (*mime/multipart.Reader, error)","ID":"FunctionMultipartReader","Docs":["MultipartReader returns a MIME multipart reader if this is a","multipart/form-data or a multipart/mixed POST request, else returns nil and an error.","Use this function instead of ParseMultipartForm to","process the request body as a stream."],"Name":"MultipartReader","PkgPath":"net/http","PkgName":"http","Parameters":null,"Results":[{"Identity":{"Placeholder":"isResult(0)","Element":"result","Index":0},"VarName":"","TypeName":"Reader","PkgName":"multipart","PkgPath":"mime/multipart","QualifiedName":"mime/multipart.Reader","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":true,"IsRepeated":false},{"Identity":{"Placeholder":"isResult(1)","Element":"result","Index":1},"VarName":"","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"RequestParseForm","Docs":["ParseForm populates r.Form and r.PostForm.","","For all requests, ParseForm parses the raw query from the URL and updates","r.Form.","","For POST, PUT, and PATCH requests, it also reads the request body, parses it","as a form and puts the results into both r.PostForm and r.Form. Request body","parameters take precedence over URL query string values in r.Form.","","If the request Body's size has not already been limited by MaxBytesReader,","the size is capped at 10MB.","","For other HTTP methods, or when the Content-Type is not","application/x-www-form-urlencoded, the request Body is not read, and","r.PostForm is initialized to a non-nil, empty value.","","ParseMultipartForm calls ParseForm automatically.","ParseForm is idempotent."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Request","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.Request","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Request-ParseForm","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"ParseForm","Signature":"func (*Request).ParseForm() error","ID":"FunctionParseForm","Docs":["ParseForm populates r.Form and r.PostForm.","","For all requests, ParseForm parses the raw query from the URL and updates","r.Form.","","For POST, PUT, and PATCH requests, it also reads the request body, parses it","as a form and puts the results into both r.PostForm and r.Form. Request body","parameters take precedence over URL query string values in r.Form.","","If the request Body's size has not already been limited by MaxBytesReader,","the size is capped at 10MB.","","For other HTTP methods, or when the Content-Type is not","application/x-www-form-urlencoded, the request Body is not read, and","r.PostForm is initialized to a non-nil, empty value.","","ParseMultipartForm calls ParseForm automatically.","ParseForm is idempotent."],"Name":"ParseForm","PkgPath":"net/http","PkgName":"http","Parameters":null,"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"RequestParseMultipartForm","Docs":["ParseMultipartForm parses a request body as multipart/form-data.","The whole request body is parsed and up to a total of maxMemory bytes of","its file parts are stored in memory, with the remainder stored on","disk in temporary files.","ParseMultipartForm calls ParseForm if necessary.","After one call to ParseMultipartForm, subsequent calls have no effect."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Request","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.Request","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Request-ParseMultipartForm","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"ParseMultipartForm","Signature":"func (*Request).ParseMultipartForm(maxMemory int64) error","ID":"FunctionParseMultipartForm","Docs":["ParseMultipartForm parses a request body as multipart/form-data.","The whole request body is parsed and up to a total of maxMemory bytes of","its file parts are stored in memory, with the remainder stored on","disk in temporary files.","ParseMultipartForm calls ParseForm if necessary.","After one call to ParseMultipartForm, subsequent calls have no effect."],"Name":"ParseMultipartForm","PkgPath":"net/http","PkgName":"http","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"maxMemory","TypeName":"int64","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"RequestPostFormValue","Docs":["PostFormValue returns the first value for the named component of the POST,","PATCH, or PUT request body. URL query parameters are ignored.","PostFormValue calls ParseMultipartForm and ParseForm if necessary and ignores","any errors returned by these functions.","If key is not present, PostFormValue returns the empty string."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Request","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.Request","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Request-PostFormValue","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"PostFormValue","Signature":"func (*Request).PostFormValue(key string) string","ID":"FunctionPostFormValue","Docs":["PostFormValue returns the first value for the named component of the POST,","PATCH, or PUT request body. URL query parameters are ignored.","PostFormValue calls ParseMultipartForm and ParseForm if necessary and ignores","any errors returned by these functions.","If key is not present, PostFormValue returns the empty string."],"Name":"PostFormValue","PkgPath":"net/http","PkgName":"http","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"key","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"RequestProtoAtLeast","Docs":["ProtoAtLeast reports whether the HTTP protocol used","in the request is at least major.minor."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Request","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.Request","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Request-ProtoAtLeast","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"ProtoAtLeast","Signature":"func (*Request).ProtoAtLeast(major int, minor int) bool","ID":"FunctionProtoAtLeast","Docs":["ProtoAtLeast reports whether the HTTP protocol used","in the request is at least major.minor."],"Name":"ProtoAtLeast","PkgPath":"net/http","PkgName":"http","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"major","TypeName":"int","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"VarName":"minor","TypeName":"int","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"bool","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"RequestReferer","Docs":["Referer returns the referring URL, if sent in the request.","","Referer is misspelled as in the request itself, a mistake from the","earliest days of HTTP.  This value can also be fetched from the","Header map as Header[\"Referer\"]; the benefit of making it available","as a method is that the compiler can diagnose programs that use the","alternate (correct English) spelling req.Referrer() but cannot","diagnose programs that use Header[\"Referrer\"]."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Request","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.Request","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Request-Referer","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Referer","Signature":"func (*Request).Referer() string","ID":"FunctionReferer","Docs":["Referer returns the referring URL, if sent in the request.","","Referer is misspelled as in the request itself, a mistake from the","earliest days of HTTP.  This value can also be fetched from the","Header map as Header[\"Referer\"]; the benefit of making it available","as a method is that the compiler can diagnose programs that use the","alternate (correct English) spelling req.Referrer() but cannot","diagnose programs that use Header[\"Referrer\"]."],"Name":"Referer","PkgPath":"net/http","PkgName":"http","Parameters":null,"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"RequestSetBasicAuth","Docs":["SetBasicAuth sets the request's Authorization header to use HTTP","Basic Authentication with the provided username and password.","","With HTTP Basic Authentication the provided username and password","are not encrypted.","","Some protocols may impose additional requirements on pre-escaping the","username and password. For instance, when used with OAuth2, both arguments","must be URL encoded first with url.QueryEscape."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Request","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.Request","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Request-SetBasicAuth","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"SetBasicAuth","Signature":"func (*Request).SetBasicAuth(username string, password string)","ID":"FunctionSetBasicAuth","Docs":["SetBasicAuth sets the request's Authorization header to use HTTP","Basic Authentication with the provided username and password.","","With HTTP Basic Authentication the provided username and password","are not encrypted.","","Some protocols may impose additional requirements on pre-escaping the","username and password. For instance, when used with OAuth2, both arguments","must be URL encoded first with url.QueryEscape."],"Name":"SetBasicAuth","PkgPath":"net/http","PkgName":"http","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"username","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"VarName":"password","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}],"Results":null}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"RequestUserAgent","Docs":["UserAgent returns the client's User-Agent, if sent in the request."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Request","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.Request","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Request-UserAgent","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"UserAgent","Signature":"func (*Request).UserAgent() string","ID":"FunctionUserAgent","Docs":["UserAgent returns the client's User-Agent, if sent in the request."],"Name":"UserAgent","PkgPath":"net/http","PkgName":"http","Parameters":null,"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"RequestWithContext","Docs":["WithContext returns a shallow copy of r with its context changed","to ctx. The provided ctx must be non-nil.","","For outgoing client request, the context controls the entire","lifetime of a request and its response: obtaining a connection,","sending the request, and reading the response headers and body.","","To create a new request with a context, use NewRequestWithContext.","To change the context of a request, such as an incoming request you","want to modify before sending back out, use Request.Clone. Between","those two uses, it's rare to need WithContext."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Request","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.Request","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Request-WithContext","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"WithContext","Signature":"func (*Request).WithContext(ctx context.Context) *Request","ID":"FunctionWithContext","Docs":["WithContext returns a shallow copy of r with its context changed","to ctx. The provided ctx must be non-nil.","","For outgoing client request, the context controls the entire","lifetime of a request and its response: obtaining a connection,","sending the request, and reading the response headers and body.","","To create a new request with a context, use NewRequestWithContext.","To change the context of a request, such as an incoming request you","want to modify before sending back out, use Request.Clone. Between","those two uses, it's rare to need WithContext."],"Name":"WithContext","PkgPath":"net/http","PkgName":"http","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"ctx","TypeName":"Context","PkgName":"context","PkgPath":"context","QualifiedName":"context.Context","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"Request","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.Request","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":true,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":true,"Pointers":{"Inp":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"Outp":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0}}},"ClassName":"RequestWrite","Docs":["Write writes an HTTP/1.1 request, which is the header and body, in wire format.","This method consults the following fields of the request:","\tHost","\tURL","\tMethod (defaults to \"GET\")","\tHeader","\tContentLength","\tTransferEncoding","\tBody","","If Body is present, Content-Length is \u003c= 0 and TransferEncoding","hasn't been set to \"identity\", Write adds \"Transfer-Encoding:","chunked\" to the header. Body is closed after it is sent."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Request","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.Request","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Request-Write","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Write","Signature":"func (*Request).Write(w io.Writer) error","ID":"FunctionWrite","Docs":["Write writes an HTTP/1.1 request, which is the header and body, in wire format.","This method consults the following fields of the request:","\tHost","\tURL","\tMethod (defaults to \"GET\")","\tHeader","\tContentLength","\tTransferEncoding","\tBody","","If Body is present, Content-Length is \u003c= 0 and TransferEncoding","hasn't been set to \"identity\", Write adds \"Transfer-Encoding:","chunked\" to the header. Body is closed after it is sent."],"Name":"Write","PkgPath":"net/http","PkgName":"http","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"w","TypeName":"Writer","PkgName":"io","PkgPath":"io","QualifiedName":"io.Writer","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":true,"Pointers":{"Inp":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"Outp":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0}}},"ClassName":"RequestWriteProxy","Docs":["WriteProxy is like Write but writes the request in the form","expected by an HTTP proxy. In particular, WriteProxy writes the","initial Request-URI line of the request with an absolute URI, per","section 5.3 of RFC 7230, including the scheme and host.","In either case, WriteProxy also writes a Host header, using","either r.Host or r.URL.Host."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Request","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.Request","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Request-WriteProxy","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"WriteProxy","Signature":"func (*Request).WriteProxy(w io.Writer) error","ID":"FunctionWriteProxy","Docs":["WriteProxy is like Write but writes the request in the form","expected by an HTTP proxy. In particular, WriteProxy writes the","initial Request-URI line of the request with an absolute URI, per","section 5.3 of RFC 7230, including the scheme and host.","In either case, WriteProxy also writes a Host header, using","either r.Host or r.URL.Host."],"Name":"WriteProxy","PkgPath":"net/http","PkgName":"http","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"w","TypeName":"Writer","PkgName":"io","PkgPath":"io","QualifiedName":"io.Writer","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"ResponseCookies","Docs":["Cookies parses and returns the cookies set in the Set-Cookie headers."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Response","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.Response","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Response-Cookies","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Cookies","Signature":"func (*Response).Cookies() []*Cookie","ID":"FunctionCookies","Docs":["Cookies parses and returns the cookies set in the Set-Cookie headers."],"Name":"Cookies","PkgPath":"net/http","PkgName":"http","Parameters":null,"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"Cookie","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.Cookie","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":true}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"ResponseLocation","Docs":["Location returns the URL of the response's \"Location\" header,","if present. Relative redirects are resolved relative to","the Response's Request. ErrNoLocation is returned if no","Location header is present."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Response","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.Response","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Response-Location","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Location","Signature":"func (*Response).Location() (*net/url.URL, error)","ID":"FunctionLocation","Docs":["Location returns the URL of the response's \"Location\" header,","if present. Relative redirects are resolved relative to","the Response's Request. ErrNoLocation is returned if no","Location header is present."],"Name":"Location","PkgPath":"net/http","PkgName":"http","Parameters":null,"Results":[{"Identity":{"Placeholder":"isResult(0)","Element":"result","Index":0},"VarName":"","TypeName":"URL","PkgName":"url","PkgPath":"net/url","QualifiedName":"net/url.URL","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":true,"IsRepeated":false},{"Identity":{"Placeholder":"isResult(1)","Element":"result","Index":1},"VarName":"","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"ResponseProtoAtLeast","Docs":["ProtoAtLeast reports whether the HTTP protocol used","in the response is at least major.minor."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Response","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.Response","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Response-ProtoAtLeast","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"ProtoAtLeast","Signature":"func (*Response).ProtoAtLeast(major int, minor int) bool","ID":"FunctionProtoAtLeast","Docs":["ProtoAtLeast reports whether the HTTP protocol used","in the response is at least major.minor."],"Name":"ProtoAtLeast","PkgPath":"net/http","PkgName":"http","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"major","TypeName":"int","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"VarName":"minor","TypeName":"int","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"bool","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":true,"Pointers":{"Inp":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"Outp":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0}}},"ClassName":"ResponseWrite","Docs":["Write writes r to w in the HTTP/1.x server response format,","including the status line, headers, body, and optional trailer.","","This method consults the following fields of the response r:",""," StatusCode"," ProtoMajor"," ProtoMinor"," Request.Method"," TransferEncoding"," Trailer"," Body"," ContentLength"," Header, values for non-canonical keys will have unpredictable behavior","","The Response Body is closed after it is sent."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Response","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.Response","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Response-Write","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Write","Signature":"func (*Response).Write(w io.Writer) error","ID":"FunctionWrite","Docs":["Write writes r to w in the HTTP/1.x server response format,","including the status line, headers, body, and optional trailer.","","This method consults the following fields of the response r:",""," StatusCode"," ProtoMajor"," ProtoMinor"," Request.Method"," TransferEncoding"," Trailer"," Body"," ContentLength"," Header, values for non-canonical keys will have unpredictable behavior","","The Response Body is closed after it is sent."],"Name":"Write","PkgPath":"net/http","PkgName":"http","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"w","TypeName":"Writer","PkgName":"io","PkgPath":"io","QualifiedName":"io.Writer","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"ServeMuxHandle","Docs":["Handle registers the handler for the given pattern.","If a handler already exists for pattern, Handle panics."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"ServeMux","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.ServeMux","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-ServeMux-Handle","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Handle","Signature":"func (*ServeMux).Handle(pattern string, handler Handler)","ID":"FunctionHandle","Docs":["Handle registers the handler for the given pattern.","If a handler already exists for pattern, Handle panics."],"Name":"Handle","PkgPath":"net/http","PkgName":"http","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"pattern","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"VarName":"handler","TypeName":"Handler","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.Handler","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}],"Results":null}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"ServeMuxHandleFunc","Docs":["HandleFunc registers the handler function for the given pattern."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"ServeMux","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.ServeMux","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-ServeMux-HandleFunc","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"HandleFunc","Signature":"func (*ServeMux).HandleFunc(pattern string, handler func(ResponseWriter, *Request))","ID":"FunctionHandleFunc","Docs":["HandleFunc registers the handler function for the given pattern."],"Name":"HandleFunc","PkgPath":"net/http","PkgName":"http","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"pattern","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"VarName":"handler","TypeName":"func(net/http.ResponseWriter, *net/http.Request)","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}],"Results":null}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"ServeMuxHandler","Docs":["Handler returns the handler to use for the given request,","consulting r.Method, r.Host, and r.URL.Path. It always returns","a non-nil handler. If the path is not in its canonical form, the","handler will be an internally-generated handler that redirects","to the canonical path. If the host contains a port, it is ignored","when matching handlers.","","The path and host are used unchanged for CONNECT requests.","","Handler also returns the registered pattern that matches the","request or, in the case of internally-generated redirects,","the pattern that will match after following the redirect.","","If there is no registered handler that applies to the request,","Handler returns a ``page not found'' handler and an empty pattern."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"ServeMux","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.ServeMux","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-ServeMux-Handler","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Handler","Signature":"func (*ServeMux).Handler(r *Request) (h Handler, pattern string)","ID":"FunctionHandler","Docs":["Handler returns the handler to use for the given request,","consulting r.Method, r.Host, and r.URL.Path. It always returns","a non-nil handler. If the path is not in its canonical form, the","handler will be an internally-generated handler that redirects","to the canonical path. If the host contains a port, it is ignored","when matching handlers.","","The path and host are used unchanged for CONNECT requests.","","Handler also returns the registered pattern that matches the","request or, in the case of internally-generated redirects,","the pattern that will match after following the redirect.","","If there is no registered handler that applies to the request,","Handler returns a ``page not found'' handler and an empty pattern."],"Name":"Handler","PkgPath":"net/http","PkgName":"http","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"r","TypeName":"Request","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.Request","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":true,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult(0)","Element":"result","Index":0},"VarName":"h","TypeName":"Handler","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.Handler","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isResult(1)","Element":"result","Index":1},"VarName":"pattern","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"ServeMuxServeHTTP","Docs":["ServeHTTP dispatches the request to the handler whose","pattern most closely matches the request URL."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"ServeMux","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.ServeMux","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-ServeMux-ServeHTTP","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"ServeHTTP","Signature":"func (*ServeMux).ServeHTTP(w ResponseWriter, r *Request)","ID":"FunctionServeHTTP","Docs":["ServeHTTP dispatches the request to the handler whose","pattern most closely matches the request URL."],"Name":"ServeHTTP","PkgPath":"net/http","PkgName":"http","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"w","TypeName":"ResponseWriter","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.ResponseWriter","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"VarName":"r","TypeName":"Request","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.Request","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":true,"IsRepeated":false}],"Results":null}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"ServerClose","Docs":["Close immediately closes all active net.Listeners and any","connections in state StateNew, StateActive, or StateIdle. For a","graceful shutdown, use Shutdown.","","Close does not attempt to close (and does not even know about)","any hijacked connections, such as WebSockets.","","Close returns any error returned from closing the Server's","underlying Listener(s)."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Server","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.Server","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Server-Close","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Close","Signature":"func (*Server).Close() error","ID":"FunctionClose","Docs":["Close immediately closes all active net.Listeners and any","connections in state StateNew, StateActive, or StateIdle. For a","graceful shutdown, use Shutdown.","","Close does not attempt to close (and does not even know about)","any hijacked connections, such as WebSockets.","","Close returns any error returned from closing the Server's","underlying Listener(s)."],"Name":"Close","PkgPath":"net/http","PkgName":"http","Parameters":null,"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"ServerListenAndServe","Docs":["ListenAndServe listens on the TCP network address srv.Addr and then","calls Serve to handle requests on incoming connections.","Accepted connections are configured to enable TCP keep-alives.","","If srv.Addr is blank, \":http\" is used.","","ListenAndServe always returns a non-nil error. After Shutdown or Close,","the returned error is ErrServerClosed."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Server","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.Server","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Server-ListenAndServe","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"ListenAndServe","Signature":"func (*Server).ListenAndServe() error","ID":"FunctionListenAndServe","Docs":["ListenAndServe listens on the TCP network address srv.Addr and then","calls Serve to handle requests on incoming connections.","Accepted connections are configured to enable TCP keep-alives.","","If srv.Addr is blank, \":http\" is used.","","ListenAndServe always returns a non-nil error. After Shutdown or Close,","the returned error is ErrServerClosed."],"Name":"ListenAndServe","PkgPath":"net/http","PkgName":"http","Parameters":null,"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"ServerListenAndServeTLS","Docs":["ListenAndServeTLS listens on the TCP network address srv.Addr and","then calls ServeTLS to handle requests on incoming TLS connections.","Accepted connections are configured to enable TCP keep-alives.","","Filenames containing a certificate and matching private key for the","server must be provided if neither the Server's TLSConfig.Certificates","nor TLSConfig.GetCertificate are populated. If the certificate is","signed by a certificate authority, the certFile should be the","concatenation of the server's certificate, any intermediates, and","the CA's certificate.","","If srv.Addr is blank, \":https\" is used.","","ListenAndServeTLS always returns a non-nil error. After Shutdown or","Close, the returned error is ErrServerClosed."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Server","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.Server","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Server-ListenAndServeTLS","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"ListenAndServeTLS","Signature":"func (*Server).ListenAndServeTLS(certFile string, keyFile string) error","ID":"FunctionListenAndServeTLS","Docs":["ListenAndServeTLS listens on the TCP network address srv.Addr and","then calls ServeTLS to handle requests on incoming TLS connections.","Accepted connections are configured to enable TCP keep-alives.","","Filenames containing a certificate and matching private key for the","server must be provided if neither the Server's TLSConfig.Certificates","nor TLSConfig.GetCertificate are populated. If the certificate is","signed by a certificate authority, the certFile should be the","concatenation of the server's certificate, any intermediates, and","the CA's certificate.","","If srv.Addr is blank, \":https\" is used.","","ListenAndServeTLS always returns a non-nil error. After Shutdown or","Close, the returned error is ErrServerClosed."],"Name":"ListenAndServeTLS","PkgPath":"net/http","PkgName":"http","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"certFile","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"VarName":"keyFile","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"ServerRegisterOnShutdown","Docs":["RegisterOnShutdown registers a function to call on Shutdown.","This can be used to gracefully shutdown connections that have","undergone ALPN protocol upgrade or that have been hijacked.","This function should start protocol-specific graceful shutdown,","but should not wait for shutdown to complete."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Server","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.Server","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Server-RegisterOnShutdown","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"RegisterOnShutdown","Signature":"func (*Server).RegisterOnShutdown(f func())","ID":"FunctionRegisterOnShutdown","Docs":["RegisterOnShutdown registers a function to call on Shutdown.","This can be used to gracefully shutdown connections that have","undergone ALPN protocol upgrade or that have been hijacked.","This function should start protocol-specific graceful shutdown,","but should not wait for shutdown to complete."],"Name":"RegisterOnShutdown","PkgPath":"net/http","PkgName":"http","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"f","TypeName":"func()","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}],"Results":null}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"ServerServe","Docs":["Serve accepts incoming connections on the Listener l, creating a","new service goroutine for each. The service goroutines read requests and","then call srv.Handler to reply to them.","","HTTP/2 support is only enabled if the Listener returns *tls.Conn","connections and they were configured with \"h2\" in the TLS","Config.NextProtos.","","Serve always returns a non-nil error and closes l.","After Shutdown or Close, the returned error is ErrServerClosed."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Server","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.Server","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Server-Serve","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Serve","Signature":"func (*Server).Serve(l net.Listener) error","ID":"FunctionServe","Docs":["Serve accepts incoming connections on the Listener l, creating a","new service goroutine for each. The service goroutines read requests and","then call srv.Handler to reply to them.","","HTTP/2 support is only enabled if the Listener returns *tls.Conn","connections and they were configured with \"h2\" in the TLS","Config.NextProtos.","","Serve always returns a non-nil error and closes l.","After Shutdown or Close, the returned error is ErrServerClosed."],"Name":"Serve","PkgPath":"net/http","PkgName":"http","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"l","TypeName":"Listener","PkgName":"net","PkgPath":"net","QualifiedName":"net.Listener","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"ServerServeTLS","Docs":["ServeTLS accepts incoming connections on the Listener l, creating a","new service goroutine for each. The service goroutines perform TLS","setup and then read requests, calling srv.Handler to reply to them.","","Files containing a certificate and matching private key for the","server must be provided if neither the Server's","TLSConfig.Certificates nor TLSConfig.GetCertificate are populated.","If the certificate is signed by a certificate authority, the","certFile should be the concatenation of the server's certificate,","any intermediates, and the CA's certificate.","","ServeTLS always returns a non-nil error. After Shutdown or Close, the","returned error is ErrServerClosed."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Server","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.Server","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Server-ServeTLS","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"ServeTLS","Signature":"func (*Server).ServeTLS(l net.Listener, certFile string, keyFile string) error","ID":"FunctionServeTLS","Docs":["ServeTLS accepts incoming connections on the Listener l, creating a","new service goroutine for each. The service goroutines perform TLS","setup and then read requests, calling srv.Handler to reply to them.","","Files containing a certificate and matching private key for the","server must be provided if neither the Server's","TLSConfig.Certificates nor TLSConfig.GetCertificate are populated.","If the certificate is signed by a certificate authority, the","certFile should be the concatenation of the server's certificate,","any intermediates, and the CA's certificate.","","ServeTLS always returns a non-nil error. After Shutdown or Close, the","returned error is ErrServerClosed."],"Name":"ServeTLS","PkgPath":"net/http","PkgName":"http","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"l","TypeName":"Listener","PkgName":"net","PkgPath":"net","QualifiedName":"net.Listener","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"VarName":"certFile","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(2)","Element":"parameter","Index":2},"VarName":"keyFile","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"ServerSetKeepAlivesEnabled","Docs":["SetKeepAlivesEnabled controls whether HTTP keep-alives are enabled.","By default, keep-alives are always enabled. Only very","resource-constrained environments or servers in the process of","shutting down should disable them."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Server","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.Server","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Server-SetKeepAlivesEnabled","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"SetKeepAlivesEnabled","Signature":"func (*Server).SetKeepAlivesEnabled(v bool)","ID":"FunctionSetKeepAlivesEnabled","Docs":["SetKeepAlivesEnabled controls whether HTTP keep-alives are enabled.","By default, keep-alives are always enabled. Only very","resource-constrained environments or servers in the process of","shutting down should disable them."],"Name":"SetKeepAlivesEnabled","PkgPath":"net/http","PkgName":"http","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"v","TypeName":"bool","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}],"Results":null}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"ServerShutdown","Docs":["Shutdown gracefully shuts down the server without interrupting any","active connections. Shutdown works by first closing all open","listeners, then closing all idle connections, and then waiting","indefinitely for connections to return to idle and then shut down.","If the provided context expires before the shutdown is complete,","Shutdown returns the context's error, otherwise it returns any","error returned from closing the Server's underlying Listener(s).","","When Shutdown is called, Serve, ListenAndServe, and","ListenAndServeTLS immediately return ErrServerClosed. Make sure the","program doesn't exit and waits instead for Shutdown to return.","","Shutdown does not attempt to close nor wait for hijacked","connections such as WebSockets. The caller of Shutdown should","separately notify such long-lived connections of shutdown and wait","for them to close, if desired. See RegisterOnShutdown for a way to","register shutdown notification functions.","","Once Shutdown has been called on a server, it may not be reused;","future calls to methods such as Serve will return ErrServerClosed."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Server","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.Server","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Server-Shutdown","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Shutdown","Signature":"func (*Server).Shutdown(ctx context.Context) error","ID":"FunctionShutdown","Docs":["Shutdown gracefully shuts down the server without interrupting any","active connections. Shutdown works by first closing all open","listeners, then closing all idle connections, and then waiting","indefinitely for connections to return to idle and then shut down.","If the provided context expires before the shutdown is complete,","Shutdown returns the context's error, otherwise it returns any","error returned from closing the Server's underlying Listener(s).","","When Shutdown is called, Serve, ListenAndServe, and","ListenAndServeTLS immediately return ErrServerClosed. Make sure the","program doesn't exit and waits instead for Shutdown to return.","","Shutdown does not attempt to close nor wait for hijacked","connections such as WebSockets. The caller of Shutdown should","separately notify such long-lived connections of shutdown and wait","for them to close, if desired. See RegisterOnShutdown for a way to","register shutdown notification functions.","","Once Shutdown has been called on a server, it may not be reused;","future calls to methods such as Serve will return ErrServerClosed."],"Name":"Shutdown","PkgPath":"net/http","PkgName":"http","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"ctx","TypeName":"Context","PkgName":"context","PkgPath":"context","QualifiedName":"context.Context","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"TransportCancelRequest","Docs":["CancelRequest cancels an in-flight request by closing its connection.","CancelRequest should only be called after RoundTrip has returned.","","Deprecated: Use Request.WithContext to create a request with a","cancelable context instead. CancelRequest cannot cancel HTTP/2","requests."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Transport","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.Transport","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Transport-CancelRequest","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"CancelRequest","Signature":"func (*Transport).CancelRequest(req *Request)","ID":"FunctionCancelRequest","Docs":["CancelRequest cancels an in-flight request by closing its connection.","CancelRequest should only be called after RoundTrip has returned.","","Deprecated: Use Request.WithContext to create a request with a","cancelable context instead. CancelRequest cannot cancel HTTP/2","requests."],"Name":"CancelRequest","PkgPath":"net/http","PkgName":"http","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"req","TypeName":"Request","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.Request","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":true,"IsRepeated":false}],"Results":null}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"TransportClone","Docs":["Clone returns a deep copy of t's exported fields."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Transport","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.Transport","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Transport-Clone","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Clone","Signature":"func (*Transport).Clone() *Transport","ID":"FunctionClone","Docs":["Clone returns a deep copy of t's exported fields."],"Name":"Clone","PkgPath":"net/http","PkgName":"http","Parameters":null,"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"Transport","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.Transport","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":true,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"TransportCloseIdleConnections","Docs":["CloseIdleConnections closes any connections which were previously","connected from previous requests but are now sitting idle in","a \"keep-alive\" state. It does not interrupt any connections currently","in use."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Transport","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.Transport","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Transport-CloseIdleConnections","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"CloseIdleConnections","Signature":"func (*Transport).CloseIdleConnections()","ID":"FunctionCloseIdleConnections","Docs":["CloseIdleConnections closes any connections which were previously","connected from previous requests but are now sitting idle in","a \"keep-alive\" state. It does not interrupt any connections currently","in use."],"Name":"CloseIdleConnections","PkgPath":"net/http","PkgName":"http","Parameters":null,"Results":null}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"TransportRegisterProtocol","Docs":["RegisterProtocol registers a new protocol with scheme.","The Transport will pass requests using the given scheme to rt.","It is rt's responsibility to simulate HTTP request semantics.","","RegisterProtocol can be used by other packages to provide","implementations of protocol schemes like \"ftp\" or \"file\".","","If rt.RoundTrip returns ErrSkipAltProtocol, the Transport will","handle the RoundTrip itself for that one request, as if the","protocol were not registered."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Transport","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.Transport","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Transport-RegisterProtocol","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"RegisterProtocol","Signature":"func (*Transport).RegisterProtocol(scheme string, rt RoundTripper)","ID":"FunctionRegisterProtocol","Docs":["RegisterProtocol registers a new protocol with scheme.","The Transport will pass requests using the given scheme to rt.","It is rt's responsibility to simulate HTTP request semantics.","","RegisterProtocol can be used by other packages to provide","implementations of protocol schemes like \"ftp\" or \"file\".","","If rt.RoundTrip returns ErrSkipAltProtocol, the Transport will","handle the RoundTrip itself for that one request, as if the","protocol were not registered."],"Name":"RegisterProtocol","PkgPath":"net/http","PkgName":"http","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"scheme","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"VarName":"rt","TypeName":"RoundTripper","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.RoundTripper","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}],"Results":null}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"TransportRoundTrip","Docs":["RoundTrip implements the RoundTripper interface using the WHATWG Fetch API."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Transport","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.Transport","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Transport-RoundTrip","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"RoundTrip","Signature":"func (*Transport).RoundTrip(req *Request) (*Response, error)","ID":"FunctionRoundTrip","Docs":["RoundTrip implements the RoundTripper interface using the WHATWG Fetch API."],"Name":"RoundTrip","PkgPath":"net/http","PkgName":"http","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"req","TypeName":"Request","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.Request","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":true,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult(0)","Element":"result","Index":0},"VarName":"","TypeName":"Response","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.Response","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":true,"IsRepeated":false},{"Identity":{"Placeholder":"isResult(1)","Element":"result","Index":1},"VarName":"","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]}}],"InterfaceMethods":[{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"CloseNotifierCloseNotify","Docs":["CloseNotify returns a channel that receives at most a","single value (true) when the client connection has gone","away.","","CloseNotify may wait to notify until Request.Body has been","fully read.","","After the Handler has returned, there is no guarantee","that the channel receives a value.","","If the protocol is HTTP/1.1 and CloseNotify is called while","processing an idempotent request (such a GET) while","HTTP/1.1 pipelining is in use, the arrival of a subsequent","pipelined request may cause a value to be sent on the","returned channel. In practice HTTP/1.1 pipelining is not","enabled in browsers and not seen often in the wild. If this","is a problem, use HTTP/2 or only use CloseNotify on methods","such as POST."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"CloseNotifier","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.CloseNotify","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"interface-method-CloseNotifier-CloseNotify","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"CloseNotify","Signature":"func (CloseNotifier).CloseNotify() \u003c-chan bool","ID":"FunctionCloseNotify","Docs":["CloseNotify returns a channel that receives at most a","single value (true) when the client connection has gone","away.","","CloseNotify may wait to notify until Request.Body has been","fully read.","","After the Handler has returned, there is no guarantee","that the channel receives a value.","","If the protocol is HTTP/1.1 and CloseNotify is called while","processing an idempotent request (such a GET) while","HTTP/1.1 pipelining is in use, the arrival of a subsequent","pipelined request may cause a value to be sent on the","returned channel. In practice HTTP/1.1 pipelining is not","enabled in browsers and not seen often in the wild. If this","is a problem, use HTTP/2 or only use CloseNotify on methods","such as POST."],"Name":"CloseNotify","PkgPath":"net/http","PkgName":"http","Parameters":null,"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"\u003c-chan bool","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"CookieJarCookies","Docs":["Cookies returns the cookies to send in a request for the given URL.","It is up to the implementation to honor the standard cookie use","restrictions such as in RFC 6265."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"CookieJar","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.Cookies","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"interface-method-CookieJar-Cookies","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Cookies","Signature":"func (CookieJar).Cookies(u *net/url.URL) []*Cookie","ID":"FunctionCookies","Docs":["Cookies returns the cookies to send in a request for the given URL.","It is up to the implementation to honor the standard cookie use","restrictions such as in RFC 6265."],"Name":"Cookies","PkgPath":"net/http","PkgName":"http","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"u","TypeName":"URL","PkgName":"url","PkgPath":"net/url","QualifiedName":"net/url.URL","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":true,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"Cookie","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.Cookie","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":true}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"FlusherFlush","Docs":["Flush sends any buffered data to the client."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Flusher","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.Flush","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"interface-method-Flusher-Flush","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Flush","Signature":"func (Flusher).Flush()","ID":"FunctionFlush","Docs":["Flush sends any buffered data to the client."],"Name":"Flush","PkgPath":"net/http","PkgName":"http","Parameters":null,"Results":null}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"ResponseWriterHeader","Docs":["Header returns the header map that will be sent by","WriteHeader. The Header map also is the mechanism with which","Handlers can set HTTP trailers.","","Changing the header map after a call to WriteHeader (or","Write) has no effect unless the modified headers are","trailers.","","There are two ways to set Trailers. The preferred way is to","predeclare in the headers which trailers you will later","send by setting the \"Trailer\" header to the names of the","trailer keys which will come later. In this case, those","keys of the Header map are treated as if they were","trailers. See the example. The second way, for trailer","keys not known to the Handler until after the first Write,","is to prefix the Header map keys with the TrailerPrefix","constant value. See TrailerPrefix.","","To suppress automatic response headers (such as \"Date\"), set","their value to nil."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"ResponseWriter","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.Header","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"interface-method-ResponseWriter-Header","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Header","Signature":"func (ResponseWriter).Header() Header","ID":"FunctionHeader","Docs":["Header returns the header map that will be sent by","WriteHeader. The Header map also is the mechanism with which","Handlers can set HTTP trailers.","","Changing the header map after a call to WriteHeader (or","Write) has no effect unless the modified headers are","trailers.","","There are two ways to set Trailers. The preferred way is to","predeclare in the headers which trailers you will later","send by setting the \"Trailer\" header to the names of the","trailer keys which will come later. In this case, those","keys of the Header map are treated as if they were","trailers. See the example. The second way, for trailer","keys not known to the Handler until after the first Write,","is to prefix the Header map keys with the TrailerPrefix","constant value. See TrailerPrefix.","","To suppress automatic response headers (such as \"Date\"), set","their value to nil."],"Name":"Header","PkgPath":"net/http","PkgName":"http","Parameters":null,"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"Header","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.Header","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"HijackerHijack","Docs":["Hijack lets the caller take over the connection.","After a call to Hijack the HTTP server library","will not do anything else with the connection.","","It becomes the caller's responsibility to manage","and close the connection.","","The returned net.Conn may have read or write deadlines","already set, depending on the configuration of the","Server. It is the caller's responsibility to set","or clear those deadlines as needed.","","The returned bufio.Reader may contain unprocessed buffered","data from the client.","","After a call to Hijack, the original Request.Body must not","be used. The original Request's Context remains valid and","is not canceled until the Request's ServeHTTP method","returns."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Hijacker","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.Hijack","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"interface-method-Hijacker-Hijack","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Hijack","Signature":"func (Hijacker).Hijack() (net.Conn, *bufio.ReadWriter, error)","ID":"FunctionHijack","Docs":["Hijack lets the caller take over the connection.","After a call to Hijack the HTTP server library","will not do anything else with the connection.","","It becomes the caller's responsibility to manage","and close the connection.","","The returned net.Conn may have read or write deadlines","already set, depending on the configuration of the","Server. It is the caller's responsibility to set","or clear those deadlines as needed.","","The returned bufio.Reader may contain unprocessed buffered","data from the client.","","After a call to Hijack, the original Request.Body must not","be used. The original Request's Context remains valid and","is not canceled until the Request's ServeHTTP method","returns."],"Name":"Hijack","PkgPath":"net/http","PkgName":"http","Parameters":null,"Results":[{"Identity":{"Placeholder":"isResult(0)","Element":"result","Index":0},"VarName":"","TypeName":"Conn","PkgName":"net","PkgPath":"net","QualifiedName":"net.Conn","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isResult(1)","Element":"result","Index":1},"VarName":"","TypeName":"ReadWriter","PkgName":"bufio","PkgPath":"bufio","QualifiedName":"bufio.ReadWriter","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":true,"IsRepeated":false},{"Identity":{"Placeholder":"isResult(2)","Element":"result","Index":2},"VarName":"","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"FileSystemOpen","Docs":[],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"FileSystem","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.Open","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"interface-method-FileSystem-Open","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Open","Signature":"func (FileSystem).Open(name string) (File, error)","ID":"FunctionOpen","Docs":[],"Name":"Open","PkgPath":"net/http","PkgName":"http","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"name","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult(0)","Element":"result","Index":0},"VarName":"","TypeName":"File","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.File","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isResult(1)","Element":"result","Index":1},"VarName":"","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"PusherPush","Docs":["Push initiates an HTTP/2 server push. This constructs a synthetic","request using the given target and options, serializes that request","into a PUSH_PROMISE frame, then dispatches that request using the","server's request handler. If opts is nil, default options are used.","","The target must either be an absolute path (like \"/path\") or an absolute","URL that contains a valid host and the same scheme as the parent request.","If the target is a path, it will inherit the scheme and host of the","parent request.","","The HTTP/2 spec disallows recursive pushes and cross-authority pushes.","Push may or may not detect these invalid pushes; however, invalid","pushes will be detected and canceled by conforming clients.","","Handlers that wish to push URL X should call Push before sending any","data that may trigger a request for URL X. This avoids a race where the","client issues requests for X before receiving the PUSH_PROMISE for X.","","Push will run in a separate goroutine making the order of arrival","non-deterministic. Any required synchronization needs to be implemented","by the caller.","","Push returns ErrNotSupported if the client has disabled push or if push","is not supported on the underlying connection."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Pusher","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.Push","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"interface-method-Pusher-Push","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Push","Signature":"func (Pusher).Push(target string, opts *PushOptions) error","ID":"FunctionPush","Docs":["Push initiates an HTTP/2 server push. This constructs a synthetic","request using the given target and options, serializes that request","into a PUSH_PROMISE frame, then dispatches that request using the","server's request handler. If opts is nil, default options are used.","","The target must either be an absolute path (like \"/path\") or an absolute","URL that contains a valid host and the same scheme as the parent request.","If the target is a path, it will inherit the scheme and host of the","parent request.","","The HTTP/2 spec disallows recursive pushes and cross-authority pushes.","Push may or may not detect these invalid pushes; however, invalid","pushes will be detected and canceled by conforming clients.","","Handlers that wish to push URL X should call Push before sending any","data that may trigger a request for URL X. This avoids a race where the","client issues requests for X before receiving the PUSH_PROMISE for X.","","Push will run in a separate goroutine making the order of arrival","non-deterministic. Any required synchronization needs to be implemented","by the caller.","","Push returns ErrNotSupported if the client has disabled push or if push","is not supported on the underlying connection."],"Name":"Push","PkgPath":"net/http","PkgName":"http","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"target","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"VarName":"opts","TypeName":"PushOptions","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.PushOptions","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":true,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"FileReaddir","Docs":[],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"File","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.Readdir","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"interface-method-File-Readdir","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Readdir","Signature":"func (File).Readdir(count int) ([]os.FileInfo, error)","ID":"FunctionReaddir","Docs":[],"Name":"Readdir","PkgPath":"net/http","PkgName":"http","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"count","TypeName":"int","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult(0)","Element":"result","Index":0},"VarName":"","TypeName":"FileInfo","PkgName":"os","PkgPath":"os","QualifiedName":"os.FileInfo","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":true},{"Identity":{"Placeholder":"isResult(1)","Element":"result","Index":1},"VarName":"","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"RoundTripperRoundTrip","Docs":["RoundTrip executes a single HTTP transaction, returning","a Response for the provided Request.","","RoundTrip should not attempt to interpret the response. In","particular, RoundTrip must return err == nil if it obtained","a response, regardless of the response's HTTP status code.","A non-nil err should be reserved for failure to obtain a","response. Similarly, RoundTrip should not attempt to","handle higher-level protocol details such as redirects,","authentication, or cookies.","","RoundTrip should not modify the request, except for","consuming and closing the Request's Body. RoundTrip may","read fields of the request in a separate goroutine. Callers","should not mutate or reuse the request until the Response's","Body has been closed.","","RoundTrip must always close the body, including on errors,","but depending on the implementation may do so in a separate","goroutine even after RoundTrip returns. This means that","callers wanting to reuse the body for subsequent requests","must arrange to wait for the Close call before doing so.","","The Request's URL and Header fields must be initialized."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"RoundTripper","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.RoundTrip","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"interface-method-RoundTripper-RoundTrip","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"RoundTrip","Signature":"func (RoundTripper).RoundTrip(*Request) (*Response, error)","ID":"FunctionRoundTrip","Docs":["RoundTrip executes a single HTTP transaction, returning","a Response for the provided Request.","","RoundTrip should not attempt to interpret the response. In","particular, RoundTrip must return err == nil if it obtained","a response, regardless of the response's HTTP status code.","A non-nil err should be reserved for failure to obtain a","response. Similarly, RoundTrip should not attempt to","handle higher-level protocol details such as redirects,","authentication, or cookies.","","RoundTrip should not modify the request, except for","consuming and closing the Request's Body. RoundTrip may","read fields of the request in a separate goroutine. Callers","should not mutate or reuse the request until the Response's","Body has been closed.","","RoundTrip must always close the body, including on errors,","but depending on the implementation may do so in a separate","goroutine even after RoundTrip returns. This means that","callers wanting to reuse the body for subsequent requests","must arrange to wait for the Close call before doing so.","","The Request's URL and Header fields must be initialized."],"Name":"RoundTrip","PkgPath":"net/http","PkgName":"http","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"","TypeName":"Request","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.Request","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":true,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult(0)","Element":"result","Index":0},"VarName":"","TypeName":"Response","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.Response","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":true,"IsRepeated":false},{"Identity":{"Placeholder":"isResult(1)","Element":"result","Index":1},"VarName":"","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"HandlerServeHTTP","Docs":[],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Handler","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.ServeHTTP","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"interface-method-Handler-ServeHTTP","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"ServeHTTP","Signature":"func (Handler).ServeHTTP(ResponseWriter, *Request)","ID":"FunctionServeHTTP","Docs":[],"Name":"ServeHTTP","PkgPath":"net/http","PkgName":"http","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"","TypeName":"ResponseWriter","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.ResponseWriter","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"VarName":"","TypeName":"Request","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.Request","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":true,"IsRepeated":false}],"Results":null}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"CookieJarSetCookies","Docs":["SetCookies handles the receipt of the cookies in a reply for the","given URL.  It may or may not choose to save the cookies, depending","on the jar's policy and implementation."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"CookieJar","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.SetCookies","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"interface-method-CookieJar-SetCookies","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"SetCookies","Signature":"func (CookieJar).SetCookies(u *net/url.URL, cookies []*Cookie)","ID":"FunctionSetCookies","Docs":["SetCookies handles the receipt of the cookies in a reply for the","given URL.  It may or may not choose to save the cookies, depending","on the jar's policy and implementation."],"Name":"SetCookies","PkgPath":"net/http","PkgName":"http","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"u","TypeName":"URL","PkgName":"url","PkgPath":"net/url","QualifiedName":"net/url.URL","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":true,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"VarName":"cookies","TypeName":"Cookie","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.Cookie","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":true}],"Results":null}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"FileStat","Docs":[],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"File","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.Stat","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"interface-method-File-Stat","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Stat","Signature":"func (File).Stat() (os.FileInfo, error)","ID":"FunctionStat","Docs":[],"Name":"Stat","PkgPath":"net/http","PkgName":"http","Parameters":null,"Results":[{"Identity":{"Placeholder":"isResult(0)","Element":"result","Index":0},"VarName":"","TypeName":"FileInfo","PkgName":"os","PkgPath":"os","QualifiedName":"os.FileInfo","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isResult(1)","Element":"result","Index":1},"VarName":"","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":true,"Pointers":{"Inp":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"Outp":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1}}},"ClassName":"ResponseWriterWrite","Docs":["Write writes the data to the connection as part of an HTTP reply.","","If WriteHeader has not yet been called, Write calls","WriteHeader(http.StatusOK) before writing the data. If the Header","does not contain a Content-Type line, Write adds a Content-Type set","to the result of passing the initial 512 bytes of written data to","DetectContentType. Additionally, if the total size of all written","data is under a few KB and there are no Flush calls, the","Content-Length header is added automatically.","","Depending on the HTTP protocol version and the client, calling","Write or WriteHeader may prevent future reads on the","Request.Body. For HTTP/1.x requests, handlers should read any","needed request body data before writing the response. Once the","headers have been flushed (due to either an explicit Flusher.Flush","call or writing enough data to trigger a flush), the request body","may be unavailable. For HTTP/2 requests, the Go HTTP server permits","handlers to continue to read the request body while concurrently","writing the response. However, such behavior may not be supported","by all HTTP/2 clients. Handlers should read before writing if","possible to maximize compatibility."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"ResponseWriter","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.Write","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"interface-method-ResponseWriter-Write","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Write","Signature":"func (ResponseWriter).Write([]byte) (int, error)","ID":"FunctionWrite","Docs":["Write writes the data to the connection as part of an HTTP reply.","","If WriteHeader has not yet been called, Write calls","WriteHeader(http.StatusOK) before writing the data. If the Header","does not contain a Content-Type line, Write adds a Content-Type set","to the result of passing the initial 512 bytes of written data to","DetectContentType. Additionally, if the total size of all written","data is under a few KB and there are no Flush calls, the","Content-Length header is added automatically.","","Depending on the HTTP protocol version and the client, calling","Write or WriteHeader may prevent future reads on the","Request.Body. For HTTP/1.x requests, handlers should read any","needed request body data before writing the response. Once the","headers have been flushed (due to either an explicit Flusher.Flush","call or writing enough data to trigger a flush), the request body","may be unavailable. For HTTP/2 requests, the Go HTTP server permits","handlers to continue to read the request body while concurrently","writing the response. However, such behavior may not be supported","by all HTTP/2 clients. Handlers should read before writing if","possible to maximize compatibility."],"Name":"Write","PkgPath":"net/http","PkgName":"http","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"","TypeName":"byte","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":true}],"Results":[{"Identity":{"Placeholder":"isResult(0)","Element":"result","Index":0},"VarName":"","TypeName":"int","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isResult(1)","Element":"result","Index":1},"VarName":"","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"ResponseWriterWriteHeader","Docs":["WriteHeader sends an HTTP response header with the provided","status code.","","If WriteHeader is not called explicitly, the first call to Write","will trigger an implicit WriteHeader(http.StatusOK).","Thus explicit calls to WriteHeader are mainly used to","send error codes.","","The provided code must be a valid HTTP 1xx-5xx status code.","Only one header may be written. Go does not currently","support sending user-defined 1xx informational headers,","with the exception of 100-continue response header that the","Server sends automatically when the Request.Body is read."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"ResponseWriter","PkgName":"http","PkgPath":"net/http","QualifiedName":"net/http.WriteHeader","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"interface-method-ResponseWriter-WriteHeader","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"WriteHeader","Signature":"func (ResponseWriter).WriteHeader(statusCode int)","ID":"FunctionWriteHeader","Docs":["WriteHeader sends an HTTP response header with the provided","status code.","","If WriteHeader is not called explicitly, the first call to Write","will trigger an implicit WriteHeader(http.StatusOK).","Thus explicit calls to WriteHeader are mainly used to","send error codes.","","The provided code must be a valid HTTP 1xx-5xx status code.","Only one header may be written. Go does not currently","support sending user-defined 1xx informational headers,","with the exception of 100-continue response header that the","Server sends automatically when the Request.Body is read."],"Name":"WriteHeader","PkgPath":"net/http","PkgName":"http","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"statusCode","TypeName":"int","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}],"Results":null}}]}