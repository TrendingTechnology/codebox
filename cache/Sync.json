{"Name":"sync","PkgPath":"sync","PkgName":"sync","ID":"sync","Funcs":[{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"NewCond","Signature":"func NewCond(l Locker) *Cond","ID":"FunctionNewCond","Docs":["NewCond returns a new Cond with Locker l."],"Name":"NewCond","PkgPath":"sync","PkgName":"sync","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"l","TypeName":"Locker","PkgName":"sync","PkgPath":"sync","QualifiedName":"sync.Locker","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"Cond","PkgName":"sync","PkgPath":"sync","QualifiedName":"sync.Cond","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":true,"IsRepeated":false}]}],"TypeMethods":[{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"CondBroadcast","Docs":["Broadcast wakes all goroutines waiting on c.","","It is allowed but not required for the caller to hold c.L","during the call."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Cond","PkgName":"sync","PkgPath":"sync","QualifiedName":"sync.Cond","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Cond-Broadcast","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Broadcast","Signature":"func (*Cond).Broadcast()","ID":"FunctionBroadcast","Docs":["Broadcast wakes all goroutines waiting on c.","","It is allowed but not required for the caller to hold c.L","during the call."],"Name":"Broadcast","PkgPath":"sync","PkgName":"sync","Parameters":null,"Results":null}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"CondSignal","Docs":["Signal wakes one goroutine waiting on c, if there is any.","","It is allowed but not required for the caller to hold c.L","during the call."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Cond","PkgName":"sync","PkgPath":"sync","QualifiedName":"sync.Cond","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Cond-Signal","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Signal","Signature":"func (*Cond).Signal()","ID":"FunctionSignal","Docs":["Signal wakes one goroutine waiting on c, if there is any.","","It is allowed but not required for the caller to hold c.L","during the call."],"Name":"Signal","PkgPath":"sync","PkgName":"sync","Parameters":null,"Results":null}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"CondWait","Docs":["Wait atomically unlocks c.L and suspends execution","of the calling goroutine. After later resuming execution,","Wait locks c.L before returning. Unlike in other systems,","Wait cannot return unless awoken by Broadcast or Signal.","","Because c.L is not locked when Wait first resumes, the caller","typically cannot assume that the condition is true when","Wait returns. Instead, the caller should Wait in a loop:","","   c.L.Lock()","   for !condition() {","       c.Wait()","   }","   ... make use of condition ...","   c.L.Unlock()"],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Cond","PkgName":"sync","PkgPath":"sync","QualifiedName":"sync.Cond","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Cond-Wait","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Wait","Signature":"func (*Cond).Wait()","ID":"FunctionWait","Docs":["Wait atomically unlocks c.L and suspends execution","of the calling goroutine. After later resuming execution,","Wait locks c.L before returning. Unlike in other systems,","Wait cannot return unless awoken by Broadcast or Signal.","","Because c.L is not locked when Wait first resumes, the caller","typically cannot assume that the condition is true when","Wait returns. Instead, the caller should Wait in a loop:","","   c.L.Lock()","   for !condition() {","       c.Wait()","   }","   ... make use of condition ...","   c.L.Unlock()"],"Name":"Wait","PkgPath":"sync","PkgName":"sync","Parameters":null,"Results":null}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"MapDelete","Docs":["Delete deletes the value for a key."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Map","PkgName":"sync","PkgPath":"sync","QualifiedName":"sync.Map","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Map-Delete","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Delete","Signature":"func (*Map).Delete(key interface{})","ID":"FunctionDelete","Docs":["Delete deletes the value for a key."],"Name":"Delete","PkgPath":"sync","PkgName":"sync","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"key","TypeName":"interface{}","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}],"Results":null}},{"CodeQL":{"IsEnabled":true,"Pointers":{"Inp":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"Outp":{"Placeholder":"isResult(0)","Element":"result","Index":0}}},"ClassName":"MapLoad","Docs":["Load returns the value stored in the map for a key, or nil if no","value is present.","The ok result indicates whether value was found in the map."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"from963","TypeName":"Map","PkgName":"sync","PkgPath":"sync","QualifiedName":"sync.Map","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Map-Load","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Load","Signature":"func (*Map).Load(key interface{}) (value interface{}, ok bool)","ID":"FunctionLoad","Docs":["Load returns the value stored in the map for a key, or nil if no","value is present.","The ok result indicates whether value was found in the map."],"Name":"Load","PkgPath":"sync","PkgName":"sync","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"key","TypeName":"interface{}","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult(0)","Element":"result","Index":0},"VarName":"value","TypeName":"interface{}","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isResult(1)","Element":"result","Index":1},"VarName":"ok","TypeName":"bool","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":true,"Pointers":{"Inp":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"Outp":{"Placeholder":"isResult(0)","Element":"result","Index":0}}},"ClassName":"MapLoadOrStore","Docs":["LoadOrStore returns the existing value for the key if present.","Otherwise, it stores and returns the given value.","The loaded result is true if the value was loaded, false if stored."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"from261","TypeName":"Map","PkgName":"sync","PkgPath":"sync","QualifiedName":"sync.Map","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Map-LoadOrStore","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"LoadOrStore","Signature":"func (*Map).LoadOrStore(key interface{}, value interface{}) (actual interface{}, loaded bool)","ID":"FunctionLoadOrStore","Docs":["LoadOrStore returns the existing value for the key if present.","Otherwise, it stores and returns the given value.","The loaded result is true if the value was loaded, false if stored."],"Name":"LoadOrStore","PkgPath":"sync","PkgName":"sync","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"key","TypeName":"interface{}","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"VarName":"value","TypeName":"interface{}","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult(0)","Element":"result","Index":0},"VarName":"actual","TypeName":"interface{}","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isResult(1)","Element":"result","Index":1},"VarName":"loaded","TypeName":"bool","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":true,"Pointers":{"Inp":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"Outp":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0}}},"ClassName":"MapRange","Docs":["Range calls f sequentially for each key and value present in the map.","If f returns false, range stops the iteration.","","Range does not necessarily correspond to any consistent snapshot of the Map's","contents: no key will be visited more than once, but if the value for any key","is stored or deleted concurrently, Range may reflect any mapping for that key","from any point during the Range call.","","Range may be O(N) with the number of elements in the map even if f returns","false after a constant number of calls."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"from919","TypeName":"Map","PkgName":"sync","PkgPath":"sync","QualifiedName":"sync.Map","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Map-Range","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Range","Signature":"func (*Map).Range(f func(key interface{}, value interface{}) bool)","ID":"FunctionRange","Docs":["Range calls f sequentially for each key and value present in the map.","If f returns false, range stops the iteration.","","Range does not necessarily correspond to any consistent snapshot of the Map's","contents: no key will be visited more than once, but if the value for any key","is stored or deleted concurrently, Range may reflect any mapping for that key","from any point during the Range call.","","Range may be O(N) with the number of elements in the map even if f returns","false after a constant number of calls."],"Name":"Range","PkgPath":"sync","PkgName":"sync","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"f","TypeName":"func(key interface{}, value interface{}) bool","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}],"Results":null}},{"CodeQL":{"IsEnabled":true,"Pointers":{"Inp":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"Outp":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1}}},"ClassName":"MapStore","Docs":["Store sets the value for a key."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"into555","TypeName":"Map","PkgName":"sync","PkgPath":"sync","QualifiedName":"sync.Map","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Map-Store","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Store","Signature":"func (*Map).Store(key interface{}, value interface{})","ID":"FunctionStore","Docs":["Store sets the value for a key."],"Name":"Store","PkgPath":"sync","PkgName":"sync","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"key","TypeName":"interface{}","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"VarName":"value","TypeName":"interface{}","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}],"Results":null}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"MutexLock","Docs":["Lock locks m.","If the lock is already in use, the calling goroutine","blocks until the mutex is available."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Mutex","PkgName":"sync","PkgPath":"sync","QualifiedName":"sync.Mutex","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Mutex-Lock","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Lock","Signature":"func (*Mutex).Lock()","ID":"FunctionLock","Docs":["Lock locks m.","If the lock is already in use, the calling goroutine","blocks until the mutex is available."],"Name":"Lock","PkgPath":"sync","PkgName":"sync","Parameters":null,"Results":null}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"MutexUnlock","Docs":["Unlock unlocks m.","It is a run-time error if m is not locked on entry to Unlock.","","A locked Mutex is not associated with a particular goroutine.","It is allowed for one goroutine to lock a Mutex and then","arrange for another goroutine to unlock it."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Mutex","PkgName":"sync","PkgPath":"sync","QualifiedName":"sync.Mutex","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Mutex-Unlock","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Unlock","Signature":"func (*Mutex).Unlock()","ID":"FunctionUnlock","Docs":["Unlock unlocks m.","It is a run-time error if m is not locked on entry to Unlock.","","A locked Mutex is not associated with a particular goroutine.","It is allowed for one goroutine to lock a Mutex and then","arrange for another goroutine to unlock it."],"Name":"Unlock","PkgPath":"sync","PkgName":"sync","Parameters":null,"Results":null}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"OnceDo","Docs":["Do calls the function f if and only if Do is being called for the","first time for this instance of Once. In other words, given","\tvar once Once","if once.Do(f) is called multiple times, only the first call will invoke f,","even if f has a different value in each invocation. A new instance of","Once is required for each function to execute.","","Do is intended for initialization that must be run exactly once. Since f","is niladic, it may be necessary to use a function literal to capture the","arguments to a function to be invoked by Do:","\tconfig.once.Do(func() { config.init(filename) })","","Because no call to Do returns until the one call to f returns, if f causes","Do to be called, it will deadlock.","","If f panics, Do considers it to have returned; future calls of Do return","without calling f."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Once","PkgName":"sync","PkgPath":"sync","QualifiedName":"sync.Once","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Once-Do","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Do","Signature":"func (*Once).Do(f func())","ID":"FunctionDo","Docs":["Do calls the function f if and only if Do is being called for the","first time for this instance of Once. In other words, given","\tvar once Once","if once.Do(f) is called multiple times, only the first call will invoke f,","even if f has a different value in each invocation. A new instance of","Once is required for each function to execute.","","Do is intended for initialization that must be run exactly once. Since f","is niladic, it may be necessary to use a function literal to capture the","arguments to a function to be invoked by Do:","\tconfig.once.Do(func() { config.init(filename) })","","Because no call to Do returns until the one call to f returns, if f causes","Do to be called, it will deadlock.","","If f panics, Do considers it to have returned; future calls of Do return","without calling f."],"Name":"Do","PkgPath":"sync","PkgName":"sync","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"f","TypeName":"func()","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}],"Results":null}},{"CodeQL":{"IsEnabled":true,"Pointers":{"Inp":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"Outp":{"Placeholder":"isResult()","Element":"result","Index":0}}},"ClassName":"PoolGet","Docs":["Get selects an arbitrary item from the Pool, removes it from the","Pool, and returns it to the caller.","Get may choose to ignore the pool and treat it as empty.","Callers should not assume any relation between values passed to Put and","the values returned by Get.","","If Get would otherwise return nil and p.New is non-nil, Get returns","the result of calling p.New."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"from577","TypeName":"Pool","PkgName":"sync","PkgPath":"sync","QualifiedName":"sync.Pool","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Pool-Get","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Get","Signature":"func (*Pool).Get() interface{}","ID":"FunctionGet","Docs":["Get selects an arbitrary item from the Pool, removes it from the","Pool, and returns it to the caller.","Get may choose to ignore the pool and treat it as empty.","Callers should not assume any relation between values passed to Put and","the values returned by Get.","","If Get would otherwise return nil and p.New is non-nil, Get returns","the result of calling p.New."],"Name":"Get","PkgPath":"sync","PkgName":"sync","Parameters":null,"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"into611","TypeName":"interface{}","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":true,"Pointers":{"Inp":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"Outp":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1}}},"ClassName":"PoolPut","Docs":["Put adds x to the pool."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"into264","TypeName":"Pool","PkgName":"sync","PkgPath":"sync","QualifiedName":"sync.Pool","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Pool-Put","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Put","Signature":"func (*Pool).Put(x interface{})","ID":"FunctionPut","Docs":["Put adds x to the pool."],"Name":"Put","PkgPath":"sync","PkgName":"sync","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"x","TypeName":"interface{}","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}],"Results":null}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"RWMutexLock","Docs":["Lock locks rw for writing.","If the lock is already locked for reading or writing,","Lock blocks until the lock is available."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"RWMutex","PkgName":"sync","PkgPath":"sync","QualifiedName":"sync.RWMutex","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-RWMutex-Lock","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Lock","Signature":"func (*RWMutex).Lock()","ID":"FunctionLock","Docs":["Lock locks rw for writing.","If the lock is already locked for reading or writing,","Lock blocks until the lock is available."],"Name":"Lock","PkgPath":"sync","PkgName":"sync","Parameters":null,"Results":null}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"RWMutexRLock","Docs":["RLock locks rw for reading.","","It should not be used for recursive read locking; a blocked Lock","call excludes new readers from acquiring the lock. See the","documentation on the RWMutex type."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"RWMutex","PkgName":"sync","PkgPath":"sync","QualifiedName":"sync.RWMutex","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-RWMutex-RLock","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"RLock","Signature":"func (*RWMutex).RLock()","ID":"FunctionRLock","Docs":["RLock locks rw for reading.","","It should not be used for recursive read locking; a blocked Lock","call excludes new readers from acquiring the lock. See the","documentation on the RWMutex type."],"Name":"RLock","PkgPath":"sync","PkgName":"sync","Parameters":null,"Results":null}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"RWMutexRLocker","Docs":["RLocker returns a Locker interface that implements","the Lock and Unlock methods by calling rw.RLock and rw.RUnlock."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"RWMutex","PkgName":"sync","PkgPath":"sync","QualifiedName":"sync.RWMutex","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-RWMutex-RLocker","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"RLocker","Signature":"func (*RWMutex).RLocker() Locker","ID":"FunctionRLocker","Docs":["RLocker returns a Locker interface that implements","the Lock and Unlock methods by calling rw.RLock and rw.RUnlock."],"Name":"RLocker","PkgPath":"sync","PkgName":"sync","Parameters":null,"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"Locker","PkgName":"sync","PkgPath":"sync","QualifiedName":"sync.Locker","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"RWMutexRUnlock","Docs":["RUnlock undoes a single RLock call;","it does not affect other simultaneous readers.","It is a run-time error if rw is not locked for reading","on entry to RUnlock."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"RWMutex","PkgName":"sync","PkgPath":"sync","QualifiedName":"sync.RWMutex","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-RWMutex-RUnlock","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"RUnlock","Signature":"func (*RWMutex).RUnlock()","ID":"FunctionRUnlock","Docs":["RUnlock undoes a single RLock call;","it does not affect other simultaneous readers.","It is a run-time error if rw is not locked for reading","on entry to RUnlock."],"Name":"RUnlock","PkgPath":"sync","PkgName":"sync","Parameters":null,"Results":null}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"RWMutexUnlock","Docs":["Unlock unlocks rw for writing. It is a run-time error if rw is","not locked for writing on entry to Unlock.","","As with Mutexes, a locked RWMutex is not associated with a particular","goroutine. One goroutine may RLock (Lock) a RWMutex and then","arrange for another goroutine to RUnlock (Unlock) it."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"RWMutex","PkgName":"sync","PkgPath":"sync","QualifiedName":"sync.RWMutex","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-RWMutex-Unlock","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Unlock","Signature":"func (*RWMutex).Unlock()","ID":"FunctionUnlock","Docs":["Unlock unlocks rw for writing. It is a run-time error if rw is","not locked for writing on entry to Unlock.","","As with Mutexes, a locked RWMutex is not associated with a particular","goroutine. One goroutine may RLock (Lock) a RWMutex and then","arrange for another goroutine to RUnlock (Unlock) it."],"Name":"Unlock","PkgPath":"sync","PkgName":"sync","Parameters":null,"Results":null}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"WaitGroupAdd","Docs":["Add adds delta, which may be negative, to the WaitGroup counter.","If the counter becomes zero, all goroutines blocked on Wait are released.","If the counter goes negative, Add panics.","","Note that calls with a positive delta that occur when the counter is zero","must happen before a Wait. Calls with a negative delta, or calls with a","positive delta that start when the counter is greater than zero, may happen","at any time.","Typically this means the calls to Add should execute before the statement","creating the goroutine or other event to be waited for.","If a WaitGroup is reused to wait for several independent sets of events,","new Add calls must happen after all previous Wait calls have returned.","See the WaitGroup example."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"WaitGroup","PkgName":"sync","PkgPath":"sync","QualifiedName":"sync.WaitGroup","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-WaitGroup-Add","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Add","Signature":"func (*WaitGroup).Add(delta int)","ID":"FunctionAdd","Docs":["Add adds delta, which may be negative, to the WaitGroup counter.","If the counter becomes zero, all goroutines blocked on Wait are released.","If the counter goes negative, Add panics.","","Note that calls with a positive delta that occur when the counter is zero","must happen before a Wait. Calls with a negative delta, or calls with a","positive delta that start when the counter is greater than zero, may happen","at any time.","Typically this means the calls to Add should execute before the statement","creating the goroutine or other event to be waited for.","If a WaitGroup is reused to wait for several independent sets of events,","new Add calls must happen after all previous Wait calls have returned.","See the WaitGroup example."],"Name":"Add","PkgPath":"sync","PkgName":"sync","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"delta","TypeName":"int","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}],"Results":null}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"WaitGroupDone","Docs":["Done decrements the WaitGroup counter by one."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"WaitGroup","PkgName":"sync","PkgPath":"sync","QualifiedName":"sync.WaitGroup","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-WaitGroup-Done","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Done","Signature":"func (*WaitGroup).Done()","ID":"FunctionDone","Docs":["Done decrements the WaitGroup counter by one."],"Name":"Done","PkgPath":"sync","PkgName":"sync","Parameters":null,"Results":null}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"WaitGroupWait","Docs":["Wait blocks until the WaitGroup counter is zero."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"WaitGroup","PkgName":"sync","PkgPath":"sync","QualifiedName":"sync.WaitGroup","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-WaitGroup-Wait","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Wait","Signature":"func (*WaitGroup).Wait()","ID":"FunctionWait","Docs":["Wait blocks until the WaitGroup counter is zero."],"Name":"Wait","PkgPath":"sync","PkgName":"sync","Parameters":null,"Results":null}}],"InterfaceMethods":[{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"LockerLock","Docs":[],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Locker","PkgName":"sync","PkgPath":"sync","QualifiedName":"sync.Lock","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"interface-method-Locker-Lock","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Lock","Signature":"func (Locker).Lock()","ID":"FunctionLock","Docs":[],"Name":"Lock","PkgPath":"sync","PkgName":"sync","Parameters":null,"Results":null}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"LockerUnlock","Docs":[],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Locker","PkgName":"sync","PkgPath":"sync","QualifiedName":"sync.Unlock","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"interface-method-Locker-Unlock","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Unlock","Signature":"func (Locker).Unlock()","ID":"FunctionUnlock","Docs":[],"Name":"Unlock","PkgPath":"sync","PkgName":"sync","Parameters":null,"Results":null}}]}