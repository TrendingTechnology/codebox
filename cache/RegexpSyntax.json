{"Name":"syntax","PkgPath":"regexp/syntax","PkgName":"syntax","ID":"regexp/syntax","Funcs":[{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Compile","Signature":"func Compile(re *Regexp) (*Prog, error)","ID":"FunctionCompile","Docs":["Compile compiles the regexp into a program to be executed.","The regexp should have been simplified already (returned from re.Simplify)."],"Name":"Compile","PkgPath":"regexp/syntax","PkgName":"syntax","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"re","TypeName":"Regexp","PkgName":"syntax","PkgPath":"regexp/syntax","QualifiedName":"regexp/syntax.Regexp","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":true,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult(0)","Element":"result","Index":0},"VarName":"","TypeName":"Prog","PkgName":"syntax","PkgPath":"regexp/syntax","QualifiedName":"regexp/syntax.Prog","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":true,"IsRepeated":false},{"Identity":{"Placeholder":"isResult(1)","Element":"result","Index":1},"VarName":"","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"EmptyOpContext","Signature":"func EmptyOpContext(r1 rune, r2 rune) EmptyOp","ID":"FunctionEmptyOpContext","Docs":["EmptyOpContext returns the zero-width assertions","satisfied at the position between the runes r1 and r2.","Passing r1 == -1 indicates that the position is","at the beginning of the text.","Passing r2 == -1 indicates that the position is","at the end of the text."],"Name":"EmptyOpContext","PkgPath":"regexp/syntax","PkgName":"syntax","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"r1","TypeName":"rune","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"VarName":"r2","TypeName":"rune","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"EmptyOp","PkgName":"syntax","PkgPath":"regexp/syntax","QualifiedName":"regexp/syntax.EmptyOp","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}]},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"IsWordChar","Signature":"func IsWordChar(r rune) bool","ID":"FunctionIsWordChar","Docs":["IsWordChar reports whether r is consider a ``word character''","during the evaluation of the \\b and \\B zero-width assertions.","These assertions are ASCII-only: the word characters are [A-Za-z0-9_]."],"Name":"IsWordChar","PkgPath":"regexp/syntax","PkgName":"syntax","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"r","TypeName":"rune","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"bool","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}]},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Parse","Signature":"func Parse(s string, flags Flags) (*Regexp, error)","ID":"FunctionParse","Docs":["Parse parses a regular expression string s, controlled by the specified","Flags, and returns a regular expression parse tree. The syntax is","described in the top-level comment."],"Name":"Parse","PkgPath":"regexp/syntax","PkgName":"syntax","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"s","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"VarName":"flags","TypeName":"Flags","PkgName":"syntax","PkgPath":"regexp/syntax","QualifiedName":"regexp/syntax.Flags","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult(0)","Element":"result","Index":0},"VarName":"","TypeName":"Regexp","PkgName":"syntax","PkgPath":"regexp/syntax","QualifiedName":"regexp/syntax.Regexp","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":true,"IsRepeated":false},{"Identity":{"Placeholder":"isResult(1)","Element":"result","Index":1},"VarName":"","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]}],"TypeMethods":[{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"ErrorError","Docs":[],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Error","PkgName":"syntax","PkgPath":"regexp/syntax","QualifiedName":"regexp/syntax.Error","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Error-Error","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Error","Signature":"func (*Error).Error() string","ID":"FunctionError","Docs":[],"Name":"Error","PkgPath":"regexp/syntax","PkgName":"syntax","Parameters":null,"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"ErrorCodeString","Docs":[],"IsOnPtr":false,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"ErrorCode","PkgName":"syntax","PkgPath":"regexp/syntax","QualifiedName":"regexp/syntax.ErrorCode","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-ErrorCode-String","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"String","Signature":"func (ErrorCode).String() string","ID":"FunctionString","Docs":[],"Name":"String","PkgPath":"regexp/syntax","PkgName":"syntax","Parameters":null,"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"InstMatchEmptyWidth","Docs":["MatchEmptyWidth reports whether the instruction matches","an empty string between the runes before and after.","It should only be called when i.Op == InstEmptyWidth."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Inst","PkgName":"syntax","PkgPath":"regexp/syntax","QualifiedName":"regexp/syntax.Inst","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Inst-MatchEmptyWidth","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"MatchEmptyWidth","Signature":"func (*Inst).MatchEmptyWidth(before rune, after rune) bool","ID":"FunctionMatchEmptyWidth","Docs":["MatchEmptyWidth reports whether the instruction matches","an empty string between the runes before and after.","It should only be called when i.Op == InstEmptyWidth."],"Name":"MatchEmptyWidth","PkgPath":"regexp/syntax","PkgName":"syntax","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"before","TypeName":"rune","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"VarName":"after","TypeName":"rune","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"bool","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"InstMatchRune","Docs":["MatchRune reports whether the instruction matches (and consumes) r.","It should only be called when i.Op == InstRune."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Inst","PkgName":"syntax","PkgPath":"regexp/syntax","QualifiedName":"regexp/syntax.Inst","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Inst-MatchRune","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"MatchRune","Signature":"func (*Inst).MatchRune(r rune) bool","ID":"FunctionMatchRune","Docs":["MatchRune reports whether the instruction matches (and consumes) r.","It should only be called when i.Op == InstRune."],"Name":"MatchRune","PkgPath":"regexp/syntax","PkgName":"syntax","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"r","TypeName":"rune","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"bool","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"InstMatchRunePos","Docs":["MatchRunePos checks whether the instruction matches (and consumes) r.","If so, MatchRunePos returns the index of the matching rune pair","(or, when len(i.Rune) == 1, rune singleton).","If not, MatchRunePos returns -1.","MatchRunePos should only be called when i.Op == InstRune."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Inst","PkgName":"syntax","PkgPath":"regexp/syntax","QualifiedName":"regexp/syntax.Inst","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Inst-MatchRunePos","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"MatchRunePos","Signature":"func (*Inst).MatchRunePos(r rune) int","ID":"FunctionMatchRunePos","Docs":["MatchRunePos checks whether the instruction matches (and consumes) r.","If so, MatchRunePos returns the index of the matching rune pair","(or, when len(i.Rune) == 1, rune singleton).","If not, MatchRunePos returns -1.","MatchRunePos should only be called when i.Op == InstRune."],"Name":"MatchRunePos","PkgPath":"regexp/syntax","PkgName":"syntax","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"r","TypeName":"rune","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"int","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"InstString","Docs":[],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Inst","PkgName":"syntax","PkgPath":"regexp/syntax","QualifiedName":"regexp/syntax.Inst","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Inst-String","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"String","Signature":"func (*Inst).String() string","ID":"FunctionString","Docs":[],"Name":"String","PkgPath":"regexp/syntax","PkgName":"syntax","Parameters":null,"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"InstOpString","Docs":[],"IsOnPtr":false,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"InstOp","PkgName":"syntax","PkgPath":"regexp/syntax","QualifiedName":"regexp/syntax.InstOp","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-InstOp-String","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"String","Signature":"func (InstOp).String() string","ID":"FunctionString","Docs":[],"Name":"String","PkgPath":"regexp/syntax","PkgName":"syntax","Parameters":null,"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"OpString","Docs":[],"IsOnPtr":false,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Op","PkgName":"syntax","PkgPath":"regexp/syntax","QualifiedName":"regexp/syntax.Op","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Op-String","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"String","Signature":"func (Op).String() string","ID":"FunctionString","Docs":[],"Name":"String","PkgPath":"regexp/syntax","PkgName":"syntax","Parameters":null,"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"ProgPrefix","Docs":["Prefix returns a literal string that all matches for the","regexp must start with. Complete is true if the prefix","is the entire match."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Prog","PkgName":"syntax","PkgPath":"regexp/syntax","QualifiedName":"regexp/syntax.Prog","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Prog-Prefix","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Prefix","Signature":"func (*Prog).Prefix() (prefix string, complete bool)","ID":"FunctionPrefix","Docs":["Prefix returns a literal string that all matches for the","regexp must start with. Complete is true if the prefix","is the entire match."],"Name":"Prefix","PkgPath":"regexp/syntax","PkgName":"syntax","Parameters":null,"Results":[{"Identity":{"Placeholder":"isResult(0)","Element":"result","Index":0},"VarName":"prefix","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isResult(1)","Element":"result","Index":1},"VarName":"complete","TypeName":"bool","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"ProgStartCond","Docs":["StartCond returns the leading empty-width conditions that must","be true in any match. It returns ^EmptyOp(0) if no matches are possible."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Prog","PkgName":"syntax","PkgPath":"regexp/syntax","QualifiedName":"regexp/syntax.Prog","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Prog-StartCond","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"StartCond","Signature":"func (*Prog).StartCond() EmptyOp","ID":"FunctionStartCond","Docs":["StartCond returns the leading empty-width conditions that must","be true in any match. It returns ^EmptyOp(0) if no matches are possible."],"Name":"StartCond","PkgPath":"regexp/syntax","PkgName":"syntax","Parameters":null,"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"EmptyOp","PkgName":"syntax","PkgPath":"regexp/syntax","QualifiedName":"regexp/syntax.EmptyOp","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"ProgString","Docs":[],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Prog","PkgName":"syntax","PkgPath":"regexp/syntax","QualifiedName":"regexp/syntax.Prog","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Prog-String","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"String","Signature":"func (*Prog).String() string","ID":"FunctionString","Docs":[],"Name":"String","PkgPath":"regexp/syntax","PkgName":"syntax","Parameters":null,"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"RegexpCapNames","Docs":["CapNames walks the regexp to find the names of capturing groups."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Regexp","PkgName":"syntax","PkgPath":"regexp/syntax","QualifiedName":"regexp/syntax.Regexp","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Regexp-CapNames","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"CapNames","Signature":"func (*Regexp).CapNames() []string","ID":"FunctionCapNames","Docs":["CapNames walks the regexp to find the names of capturing groups."],"Name":"CapNames","PkgPath":"regexp/syntax","PkgName":"syntax","Parameters":null,"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":true}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"RegexpEqual","Docs":["Equal reports whether x and y have identical structure."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Regexp","PkgName":"syntax","PkgPath":"regexp/syntax","QualifiedName":"regexp/syntax.Regexp","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Regexp-Equal","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Equal","Signature":"func (*Regexp).Equal(y *Regexp) bool","ID":"FunctionEqual","Docs":["Equal reports whether x and y have identical structure."],"Name":"Equal","PkgPath":"regexp/syntax","PkgName":"syntax","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"y","TypeName":"Regexp","PkgName":"syntax","PkgPath":"regexp/syntax","QualifiedName":"regexp/syntax.Regexp","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":true,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"bool","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"RegexpMaxCap","Docs":["MaxCap walks the regexp to find the maximum capture index."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Regexp","PkgName":"syntax","PkgPath":"regexp/syntax","QualifiedName":"regexp/syntax.Regexp","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Regexp-MaxCap","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"MaxCap","Signature":"func (*Regexp).MaxCap() int","ID":"FunctionMaxCap","Docs":["MaxCap walks the regexp to find the maximum capture index."],"Name":"MaxCap","PkgPath":"regexp/syntax","PkgName":"syntax","Parameters":null,"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"int","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"RegexpSimplify","Docs":["Simplify returns a regexp equivalent to re but without counted repetitions","and with various other simplifications, such as rewriting /(?:a+)+/ to /a+/.","The resulting regexp will execute correctly but its string representation","will not produce the same parse tree, because capturing parentheses","may have been duplicated or removed. For example, the simplified form","for /(x){1,2}/ is /(x)(x)?/ but both parentheses capture as $1.","The returned regexp may share structure with or be the original."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Regexp","PkgName":"syntax","PkgPath":"regexp/syntax","QualifiedName":"regexp/syntax.Regexp","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Regexp-Simplify","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Simplify","Signature":"func (*Regexp).Simplify() *Regexp","ID":"FunctionSimplify","Docs":["Simplify returns a regexp equivalent to re but without counted repetitions","and with various other simplifications, such as rewriting /(?:a+)+/ to /a+/.","The resulting regexp will execute correctly but its string representation","will not produce the same parse tree, because capturing parentheses","may have been duplicated or removed. For example, the simplified form","for /(x){1,2}/ is /(x)(x)?/ but both parentheses capture as $1.","The returned regexp may share structure with or be the original."],"Name":"Simplify","PkgPath":"regexp/syntax","PkgName":"syntax","Parameters":null,"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"Regexp","PkgName":"syntax","PkgPath":"regexp/syntax","QualifiedName":"regexp/syntax.Regexp","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":true,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"RegexpString","Docs":[],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Regexp","PkgName":"syntax","PkgPath":"regexp/syntax","QualifiedName":"regexp/syntax.Regexp","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Regexp-String","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"String","Signature":"func (*Regexp).String() string","ID":"FunctionString","Docs":[],"Name":"String","PkgPath":"regexp/syntax","PkgName":"syntax","Parameters":null,"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}]}}],"InterfaceMethods":[]}