{
   "func (*Error).Error() string": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false
            ],
            "Outp": [
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func (*Template).AddParseTree(name string, tree *text/template/parse.Tree) (*Template, error)": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false,
               false,
               false,
               false
            ],
            "Outp": [
               false,
               false,
               false,
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func (*Template).Clone() (*Template, error)": {
      "GeneratedClass": "\n    private class TemplateClone extends TaintTracking::FunctionModel, Method {\n      // signature: func (*Template).Clone() (*Template, error)\n      TemplateClone() { this.(Method).hasQualifiedName(\"html/template\", \"Template\", \"Clone\") }\n\n      override predicate hasTaintFlow(FunctionInput inp, FunctionOutput outp) {\n        ((inp.isReceiver()) and (outp.isResult(0)))\n      }\n    }",
      "GeneratedConditions": "((inp.isReceiver()) and (outp.isResult(0)))",
      "Blocks": [
         {
            "Inp": [
               true,
               false,
               false
            ],
            "Outp": [
               false,
               true,
               false
            ]
         }
      ],
      "IsEnabled": true
   },
   "func (*Template).DefinedTemplates() string": {
      "GeneratedClass": "\n    private class TemplateDefinedTemplates extends TaintTracking::FunctionModel, Method {\n      // signature: func (*Template).DefinedTemplates() string\n      TemplateDefinedTemplates() { this.(Method).hasQualifiedName(\"html/template\", \"Template\", \"DefinedTemplates\") }\n\n      override predicate hasTaintFlow(FunctionInput inp, FunctionOutput outp) {\n        ((inp.isReceiver()) and (outp.isResult()))\n      }\n    }",
      "GeneratedConditions": "((inp.isReceiver()) and (outp.isResult()))",
      "Blocks": [
         {
            "Inp": [
               true,
               false
            ],
            "Outp": [
               false,
               true
            ]
         }
      ],
      "IsEnabled": true
   },
   "func (*Template).Delims(left string, right string) *Template": {
      "GeneratedClass": "\n    private class TemplateDelims extends TaintTracking::FunctionModel, Method {\n      // signature: func (*Template).Delims(left string, right string) *Template\n      TemplateDelims() { this.(Method).hasQualifiedName(\"html/template\", \"Template\", \"Delims\") }\n\n      override predicate hasTaintFlow(FunctionInput inp, FunctionOutput outp) {\n        ((inp.isReceiver() or inp.isParameter(_)) and (outp.isResult()))\n      }\n    }",
      "GeneratedConditions": "((inp.isReceiver() or inp.isParameter(_)) and (outp.isResult()))",
      "Blocks": [
         {
            "Inp": [
               true,
               true,
               true,
               false
            ],
            "Outp": [
               false,
               false,
               false,
               true
            ]
         }
      ],
      "IsEnabled": true
   },
   "func (*Template).Execute(wr io.Writer, data interface{}) error": {
      "GeneratedClass": "\n    private class TemplateExecute extends TaintTracking::FunctionModel, Method {\n      // signature: func (*Template).Execute(wr io.Writer, data interface{}) error\n      TemplateExecute() { this.(Method).hasQualifiedName(\"html/template\", \"Template\", \"Execute\") }\n\n      override predicate hasTaintFlow(FunctionInput inp, FunctionOutput outp) {\n        ((inp.isReceiver() or inp.isParameter(1)) and (outp.isParameter(0)))\n      }\n    }",
      "GeneratedConditions": "((inp.isReceiver() or inp.isParameter(1)) and (outp.isParameter(0)))",
      "Blocks": [
         {
            "Inp": [
               true,
               false,
               true,
               false
            ],
            "Outp": [
               false,
               true,
               false,
               false
            ]
         }
      ],
      "IsEnabled": true
   },
   "func (*Template).ExecuteTemplate(wr io.Writer, name string, data interface{}) error": {
      "GeneratedClass": "\n    private class TemplateExecuteTemplate extends TaintTracking::FunctionModel, Method {\n      // signature: func (*Template).ExecuteTemplate(wr io.Writer, name string, data interface{}) error\n      TemplateExecuteTemplate() { this.(Method).hasQualifiedName(\"html/template\", \"Template\", \"ExecuteTemplate\") }\n\n      override predicate hasTaintFlow(FunctionInput inp, FunctionOutput outp) {\n        ((inp.isReceiver() or inp.isParameter(2)) and (outp.isParameter(0)))\n      }\n    }",
      "GeneratedConditions": "((inp.isReceiver() or inp.isParameter(2)) and (outp.isParameter(0)))",
      "Blocks": [
         {
            "Inp": [
               true,
               false,
               false,
               true,
               false
            ],
            "Outp": [
               false,
               true,
               false,
               false,
               false
            ]
         }
      ],
      "IsEnabled": true
   },
   "func (*Template).Funcs(funcMap FuncMap) *Template": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false,
               false
            ],
            "Outp": [
               false,
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func (*Template).Lookup(name string) *Template": {
      "GeneratedClass": "\n    private class TemplateLookup extends TaintTracking::FunctionModel, Method {\n      // signature: func (*Template).Lookup(name string) *Template\n      TemplateLookup() { this.(Method).hasQualifiedName(\"html/template\", \"Template\", \"Lookup\") }\n\n      override predicate hasTaintFlow(FunctionInput inp, FunctionOutput outp) {\n        ((inp.isReceiver()) and (outp.isResult()))\n      }\n    }",
      "GeneratedConditions": "((inp.isReceiver()) and (outp.isResult()))",
      "Blocks": [
         {
            "Inp": [
               true,
               false,
               false
            ],
            "Outp": [
               false,
               false,
               true
            ]
         }
      ],
      "IsEnabled": true
   },
   "func (*Template).Name() string": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false
            ],
            "Outp": [
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func (*Template).New(name string) *Template": {
      "GeneratedClass": "\n    private class TemplateNew extends TaintTracking::FunctionModel, Method {\n      // signature: func (*Template).New(name string) *Template\n      TemplateNew() { this.(Method).hasQualifiedName(\"html/template\", \"Template\", \"New\") }\n\n      override predicate hasTaintFlow(FunctionInput inp, FunctionOutput outp) {\n        ((inp.isReceiver()) and (outp.isResult()))\n      }\n    }",
      "GeneratedConditions": "((inp.isReceiver()) and (outp.isResult()))",
      "Blocks": [
         {
            "Inp": [
               true,
               false,
               false
            ],
            "Outp": [
               false,
               false,
               true
            ]
         }
      ],
      "IsEnabled": true
   },
   "func (*Template).Option(opt ...string) *Template": {
      "GeneratedClass": "\n    private class TemplateOption extends TaintTracking::FunctionModel, Method {\n      // signature: func (*Template).Option(opt ...string) *Template\n      TemplateOption() { this.(Method).hasQualifiedName(\"html/template\", \"Template\", \"Option\") }\n\n      override predicate hasTaintFlow(FunctionInput inp, FunctionOutput outp) {\n        ((inp.isReceiver()) and (outp.isResult()))\n      }\n    }",
      "GeneratedConditions": "((inp.isReceiver()) and (outp.isResult()))",
      "Blocks": [
         {
            "Inp": [
               true,
               false,
               false
            ],
            "Outp": [
               false,
               false,
               true
            ]
         }
      ],
      "IsEnabled": true
   },
   "func (*Template).Parse(text string) (*Template, error)": {
      "GeneratedClass": "\n    private class TemplateParse extends TaintTracking::FunctionModel, Method {\n      // signature: func (*Template).Parse(text string) (*Template, error)\n      TemplateParse() { this.(Method).hasQualifiedName(\"html/template\", \"Template\", \"Parse\") }\n\n      override predicate hasTaintFlow(FunctionInput inp, FunctionOutput outp) {\n        ((inp.isParameter(0)) and (outp.isResult(0)))\n      }\n    }",
      "GeneratedConditions": "((inp.isParameter(0)) and (outp.isResult(0)))",
      "Blocks": [
         {
            "Inp": [
               false,
               true,
               false,
               false
            ],
            "Outp": [
               false,
               false,
               true,
               false
            ]
         }
      ],
      "IsEnabled": true
   },
   "func (*Template).ParseFiles(filenames ...string) (*Template, error)": {
      "GeneratedClass": "\n    private class TemplateParseFiles extends TaintTracking::FunctionModel, Method {\n      // signature: func (*Template).ParseFiles(filenames ...string) (*Template, error)\n      TemplateParseFiles() { this.(Method).hasQualifiedName(\"html/template\", \"Template\", \"ParseFiles\") }\n\n      override predicate hasTaintFlow(FunctionInput inp, FunctionOutput outp) {\n        ((inp.isReceiver() or inp.isParameter(_)) and (outp.isResult(0)))\n      }\n    }",
      "GeneratedConditions": "((inp.isReceiver() or inp.isParameter(_)) and (outp.isResult(0)))",
      "Blocks": [
         {
            "Inp": [
               true,
               true,
               false,
               false
            ],
            "Outp": [
               false,
               false,
               true,
               false
            ]
         }
      ],
      "IsEnabled": true
   },
   "func (*Template).ParseGlob(pattern string) (*Template, error)": {
      "GeneratedClass": "\n    private class TemplateParseGlob extends TaintTracking::FunctionModel, Method {\n      // signature: func (*Template).ParseGlob(pattern string) (*Template, error)\n      TemplateParseGlob() { this.(Method).hasQualifiedName(\"html/template\", \"Template\", \"ParseGlob\") }\n\n      override predicate hasTaintFlow(FunctionInput inp, FunctionOutput outp) {\n        ((inp.isReceiver() or inp.isParameter(0)) and (outp.isResult(0)))\n      }\n    }",
      "GeneratedConditions": "((inp.isReceiver() or inp.isParameter(0)) and (outp.isResult(0)))",
      "Blocks": [
         {
            "Inp": [
               true,
               true,
               false,
               false
            ],
            "Outp": [
               false,
               false,
               true,
               false
            ]
         }
      ],
      "IsEnabled": true
   },
   "func (*Template).Templates() []*Template": {
      "GeneratedClass": "\n    private class TemplateTemplates extends TaintTracking::FunctionModel, Method {\n      // signature: func (*Template).Templates() []*Template\n      TemplateTemplates() { this.(Method).hasQualifiedName(\"html/template\", \"Template\", \"Templates\") }\n\n      override predicate hasTaintFlow(FunctionInput inp, FunctionOutput outp) {\n        ((inp.isReceiver()) and (outp.isResult()))\n      }\n    }",
      "GeneratedConditions": "((inp.isReceiver()) and (outp.isResult()))",
      "Blocks": [
         {
            "Inp": [
               true,
               false
            ],
            "Outp": [
               false,
               true
            ]
         }
      ],
      "IsEnabled": true
   },
   "func HTMLEscape(w io.Writer, b []byte)": {
      "GeneratedClass": "\n    private class HTMLEscape extends TaintTracking::FunctionModel {\n      // signature: func HTMLEscape(w io.Writer, b []byte)\n      HTMLEscape() { hasQualifiedName(\"html/template\", \"HTMLEscape\") }\n\n      override predicate hasTaintFlow(FunctionInput inp, FunctionOutput outp) {\n        ((inp.isParameter(1)) and (outp.isParameter(0)))\n      }\n    }",
      "GeneratedConditions": "((inp.isParameter(1)) and (outp.isParameter(0)))",
      "Blocks": [
         {
            "Inp": [
               false,
               true
            ],
            "Outp": [
               true,
               false
            ]
         }
      ],
      "IsEnabled": true
   },
   "func HTMLEscapeString(s string) string": {
      "GeneratedClass": "\n    private class HTMLEscapeString extends TaintTracking::FunctionModel {\n      // signature: func HTMLEscapeString(s string) string\n      HTMLEscapeString() { hasQualifiedName(\"html/template\", \"HTMLEscapeString\") }\n\n      override predicate hasTaintFlow(FunctionInput inp, FunctionOutput outp) {\n        ((inp.isParameter(0)) and (outp.isResult()))\n      }\n    }",
      "GeneratedConditions": "((inp.isParameter(0)) and (outp.isResult()))",
      "Blocks": [
         {
            "Inp": [
               true,
               false
            ],
            "Outp": [
               false,
               true
            ]
         }
      ],
      "IsEnabled": true
   },
   "func HTMLEscaper(args ...interface{}) string": {
      "GeneratedClass": "\n    private class HTMLEscaper extends TaintTracking::FunctionModel {\n      // signature: func HTMLEscaper(args ...interface{}) string\n      HTMLEscaper() { hasQualifiedName(\"html/template\", \"HTMLEscaper\") }\n\n      override predicate hasTaintFlow(FunctionInput inp, FunctionOutput outp) {\n        ((inp.isParameter(_)) and (outp.isResult()))\n      }\n    }",
      "GeneratedConditions": "((inp.isParameter(_)) and (outp.isResult()))",
      "Blocks": [
         {
            "Inp": [
               true,
               false
            ],
            "Outp": [
               false,
               true
            ]
         }
      ],
      "IsEnabled": true
   },
   "func IsTrue(val interface{}) (truth bool, ok bool)": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false,
               false
            ],
            "Outp": [
               false,
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func JSEscape(w io.Writer, b []byte)": {
      "GeneratedClass": "\n    private class JSEscape extends TaintTracking::FunctionModel {\n      // signature: func JSEscape(w io.Writer, b []byte)\n      JSEscape() { hasQualifiedName(\"html/template\", \"JSEscape\") }\n\n      override predicate hasTaintFlow(FunctionInput inp, FunctionOutput outp) {\n        ((inp.isParameter(1)) and (outp.isParameter(0)))\n      }\n    }",
      "GeneratedConditions": "((inp.isParameter(1)) and (outp.isParameter(0)))",
      "Blocks": [
         {
            "Inp": [
               false,
               true
            ],
            "Outp": [
               true,
               false
            ]
         }
      ],
      "IsEnabled": true
   },
   "func JSEscapeString(s string) string": {
      "GeneratedClass": "\n    private class JSEscapeString extends TaintTracking::FunctionModel {\n      // signature: func JSEscapeString(s string) string\n      JSEscapeString() { hasQualifiedName(\"html/template\", \"JSEscapeString\") }\n\n      override predicate hasTaintFlow(FunctionInput inp, FunctionOutput outp) {\n        ((inp.isParameter(0)) and (outp.isResult()))\n      }\n    }",
      "GeneratedConditions": "((inp.isParameter(0)) and (outp.isResult()))",
      "Blocks": [
         {
            "Inp": [
               true,
               false
            ],
            "Outp": [
               false,
               true
            ]
         }
      ],
      "IsEnabled": true
   },
   "func JSEscaper(args ...interface{}) string": {
      "GeneratedClass": "\n    private class JSEscaper extends TaintTracking::FunctionModel {\n      // signature: func JSEscaper(args ...interface{}) string\n      JSEscaper() { hasQualifiedName(\"html/template\", \"JSEscaper\") }\n\n      override predicate hasTaintFlow(FunctionInput inp, FunctionOutput outp) {\n        ((inp.isParameter(_)) and (outp.isResult()))\n      }\n    }",
      "GeneratedConditions": "((inp.isParameter(_)) and (outp.isResult()))",
      "Blocks": [
         {
            "Inp": [
               true,
               false
            ],
            "Outp": [
               false,
               true
            ]
         }
      ],
      "IsEnabled": true
   },
   "func Must(t *Template, err error) *Template": {
      "GeneratedClass": "\n    private class Must extends TaintTracking::FunctionModel {\n      // signature: func Must(t *Template, err error) *Template\n      Must() { hasQualifiedName(\"html/template\", \"Must\") }\n\n      override predicate hasTaintFlow(FunctionInput inp, FunctionOutput outp) {\n        ((inp.isParameter(0)) and (outp.isResult()))\n      }\n    }",
      "GeneratedConditions": "((inp.isParameter(0)) and (outp.isResult()))",
      "Blocks": [
         {
            "Inp": [
               true,
               false,
               false
            ],
            "Outp": [
               false,
               false,
               true
            ]
         }
      ],
      "IsEnabled": true
   },
   "func New(name string) *Template": {
      "GeneratedClass": "",
      "GeneratedConditions": "",
      "Blocks": [
         {
            "Inp": [
               false,
               false
            ],
            "Outp": [
               false,
               false
            ]
         }
      ],
      "IsEnabled": false
   },
   "func ParseFiles(filenames ...string) (*Template, error)": {
      "GeneratedClass": "\n    private class ParseFiles extends TaintTracking::FunctionModel {\n      // signature: func ParseFiles(filenames ...string) (*Template, error)\n      ParseFiles() { hasQualifiedName(\"html/template\", \"ParseFiles\") }\n\n      override predicate hasTaintFlow(FunctionInput inp, FunctionOutput outp) {\n        ((inp.isParameter(_)) and (outp.isResult(0)))\n      }\n    }",
      "GeneratedConditions": "((inp.isParameter(_)) and (outp.isResult(0)))",
      "Blocks": [
         {
            "Inp": [
               true,
               false,
               false
            ],
            "Outp": [
               false,
               true,
               false
            ]
         }
      ],
      "IsEnabled": true
   },
   "func ParseGlob(pattern string) (*Template, error)": {
      "GeneratedClass": "\n    private class ParseGlob extends TaintTracking::FunctionModel {\n      // signature: func ParseGlob(pattern string) (*Template, error)\n      ParseGlob() { hasQualifiedName(\"html/template\", \"ParseGlob\") }\n\n      override predicate hasTaintFlow(FunctionInput inp, FunctionOutput outp) {\n        ((inp.isParameter(0)) and (outp.isResult(0)))\n      }\n    }",
      "GeneratedConditions": "((inp.isParameter(0)) and (outp.isResult(0)))",
      "Blocks": [
         {
            "Inp": [
               true,
               false,
               false
            ],
            "Outp": [
               false,
               true,
               false
            ]
         }
      ],
      "IsEnabled": true
   },
   "func URLQueryEscaper(args ...interface{}) string": {
      "GeneratedClass": "\n    private class URLQueryEscaper extends TaintTracking::FunctionModel {\n      // signature: func URLQueryEscaper(args ...interface{}) string\n      URLQueryEscaper() { hasQualifiedName(\"html/template\", \"URLQueryEscaper\") }\n\n      override predicate hasTaintFlow(FunctionInput inp, FunctionOutput outp) {\n        ((inp.isParameter(_)) and (outp.isResult()))\n      }\n    }",
      "GeneratedConditions": "((inp.isParameter(_)) and (outp.isResult()))",
      "Blocks": [
         {
            "Inp": [
               true,
               false
            ],
            "Outp": [
               false,
               true
            ]
         }
      ],
      "IsEnabled": true
   }
}
