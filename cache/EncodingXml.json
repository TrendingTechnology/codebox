{"Name":"xml","PkgPath":"encoding/xml","PkgName":"xml","ID":"encoding/xml","Funcs":[{"CodeQL":{"IsEnabled":true,"Pointers":{"Inp":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"Outp":{"Placeholder":"isResult()","Element":"result","Index":0}}},"ClassName":"CopyToken","Signature":"func CopyToken(t Token) Token","ID":"FunctionCopyToken","Docs":["CopyToken returns a copy of a Token."],"Name":"CopyToken","PkgPath":"encoding/xml","PkgName":"xml","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"t","TypeName":"Token","PkgName":"xml","PkgPath":"encoding/xml","QualifiedName":"encoding/xml.Token","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"into212","TypeName":"Token","PkgName":"xml","PkgPath":"encoding/xml","QualifiedName":"encoding/xml.Token","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]},{"CodeQL":{"IsEnabled":true,"Pointers":{"Inp":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"Outp":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0}}},"ClassName":"Escape","Signature":"func Escape(w io.Writer, s []byte)","ID":"FunctionEscape","Docs":["Escape is like EscapeText but omits the error return value.","It is provided for backwards compatibility with Go 1.0.","Code targeting Go 1.1 or later should use EscapeText."],"Name":"Escape","PkgPath":"encoding/xml","PkgName":"xml","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"w","TypeName":"Writer","PkgName":"io","PkgPath":"io","QualifiedName":"io.Writer","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"VarName":"s","TypeName":"byte","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":true}],"Results":null},{"CodeQL":{"IsEnabled":true,"Pointers":{"Inp":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"Outp":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0}}},"ClassName":"EscapeText","Signature":"func EscapeText(w io.Writer, s []byte) error","ID":"FunctionEscapeText","Docs":["EscapeText writes to w the properly escaped XML equivalent","of the plain text data s."],"Name":"EscapeText","PkgPath":"encoding/xml","PkgName":"xml","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"w","TypeName":"Writer","PkgName":"io","PkgPath":"io","QualifiedName":"io.Writer","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"VarName":"s","TypeName":"byte","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":true}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]},{"CodeQL":{"IsEnabled":true,"Pointers":{"Inp":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"Outp":{"Placeholder":"isResult(0)","Element":"result","Index":0}}},"ClassName":"Marshal","Signature":"func Marshal(v interface{}) ([]byte, error)","ID":"FunctionMarshal","Docs":["Marshal returns the XML encoding of v.","","Marshal handles an array or slice by marshaling each of the elements.","Marshal handles a pointer by marshaling the value it points at or, if the","pointer is nil, by writing nothing. Marshal handles an interface value by","marshaling the value it contains or, if the interface value is nil, by","writing nothing. Marshal handles all other data by writing one or more XML","elements containing the data.","","The name for the XML elements is taken from, in order of preference:","    - the tag on the XMLName field, if the data is a struct","    - the value of the XMLName field of type Name","    - the tag of the struct field used to obtain the data","    - the name of the struct field used to obtain the data","    - the name of the marshaled type","","The XML element for a struct contains marshaled elements for each of the","exported fields of the struct, with these exceptions:","    - the XMLName field, described above, is omitted.","    - a field with tag \"-\" is omitted.","    - a field with tag \"name,attr\" becomes an attribute with","      the given name in the XML element.","    - a field with tag \",attr\" becomes an attribute with the","      field name in the XML element.","    - a field with tag \",chardata\" is written as character data,","      not as an XML element.","    - a field with tag \",cdata\" is written as character data","      wrapped in one or more \u003c![CDATA[ ... ]]\u003e tags, not as an XML element.","    - a field with tag \",innerxml\" is written verbatim, not subject","      to the usual marshaling procedure.","    - a field with tag \",comment\" is written as an XML comment, not","      subject to the usual marshaling procedure. It must not contain","      the \"--\" string within it.","    - a field with a tag including the \"omitempty\" option is omitted","      if the field value is empty. The empty values are false, 0, any","      nil pointer or interface value, and any array, slice, map, or","      string of length zero.","    - an anonymous struct field is handled as if the fields of its","      value were part of the outer struct.","    - a field implementing Marshaler is written by calling its MarshalXML","      method.","    - a field implementing encoding.TextMarshaler is written by encoding the","      result of its MarshalText method as text.","","If a field uses a tag \"a\u003eb\u003ec\", then the element c will be nested inside","parent elements a and b. Fields that appear next to each other that name","the same parent will be enclosed in one XML element.","","If the XML name for a struct field is defined by both the field tag and the","struct's XMLName field, the names must match.","","See MarshalIndent for an example.","","Marshal will return an error if asked to marshal a channel, function, or map."],"Name":"Marshal","PkgPath":"encoding/xml","PkgName":"xml","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"v","TypeName":"interface{}","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult(0)","Element":"result","Index":0},"VarName":"into562","TypeName":"byte","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":true},{"Identity":{"Placeholder":"isResult(1)","Element":"result","Index":1},"VarName":"","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]},{"CodeQL":{"IsEnabled":true,"Pointers":{"Inp":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"Outp":{"Placeholder":"isResult(0)","Element":"result","Index":0}}},"ClassName":"MarshalIndent","Signature":"func MarshalIndent(v interface{}, prefix string, indent string) ([]byte, error)","ID":"FunctionMarshalIndent","Docs":["MarshalIndent works like Marshal, but each XML element begins on a new","indented line that starts with prefix and is followed by one or more","copies of indent according to the nesting depth."],"Name":"MarshalIndent","PkgPath":"encoding/xml","PkgName":"xml","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"v","TypeName":"interface{}","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"VarName":"prefix","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(2)","Element":"parameter","Index":2},"VarName":"indent","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult(0)","Element":"result","Index":0},"VarName":"into293","TypeName":"byte","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":true},{"Identity":{"Placeholder":"isResult(1)","Element":"result","Index":1},"VarName":"","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]},{"CodeQL":{"IsEnabled":true,"Pointers":{"Inp":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"Outp":{"Placeholder":"isResult()","Element":"result","Index":0}}},"ClassName":"NewDecoder","Signature":"func NewDecoder(r io.Reader) *Decoder","ID":"FunctionNewDecoder","Docs":["NewDecoder creates a new XML parser reading from r.","If r does not implement io.ByteReader, NewDecoder will","do its own buffering."],"Name":"NewDecoder","PkgPath":"encoding/xml","PkgName":"xml","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"r","TypeName":"Reader","PkgName":"io","PkgPath":"io","QualifiedName":"io.Reader","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"into734","TypeName":"Decoder","PkgName":"xml","PkgPath":"encoding/xml","QualifiedName":"encoding/xml.Decoder","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":true,"IsRepeated":false}]},{"CodeQL":{"IsEnabled":true,"Pointers":{"Inp":{"Placeholder":"isResult()","Element":"result","Index":0},"Outp":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0}}},"ClassName":"NewEncoder","Signature":"func NewEncoder(w io.Writer) *Encoder","ID":"FunctionNewEncoder","Docs":["NewEncoder returns a new encoder that writes to w."],"Name":"NewEncoder","PkgPath":"encoding/xml","PkgName":"xml","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"w","TypeName":"Writer","PkgName":"io","PkgPath":"io","QualifiedName":"io.Writer","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"from321","TypeName":"Encoder","PkgName":"xml","PkgPath":"encoding/xml","QualifiedName":"encoding/xml.Encoder","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":true,"IsRepeated":false}]},{"CodeQL":{"IsEnabled":true,"Pointers":{"Inp":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"Outp":{"Placeholder":"isResult()","Element":"result","Index":0}}},"ClassName":"NewTokenDecoder","Signature":"func NewTokenDecoder(t TokenReader) *Decoder","ID":"FunctionNewTokenDecoder","Docs":["NewTokenDecoder creates a new XML parser using an underlying token stream."],"Name":"NewTokenDecoder","PkgPath":"encoding/xml","PkgName":"xml","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"t","TypeName":"TokenReader","PkgName":"xml","PkgPath":"encoding/xml","QualifiedName":"encoding/xml.TokenReader","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"into849","TypeName":"Decoder","PkgName":"xml","PkgPath":"encoding/xml","QualifiedName":"encoding/xml.Decoder","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":true,"IsRepeated":false}]},{"CodeQL":{"IsEnabled":true,"Pointers":{"Inp":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"Outp":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1}}},"ClassName":"Unmarshal","Signature":"func Unmarshal(data []byte, v interface{}) error","ID":"FunctionUnmarshal","Docs":["Unmarshal parses the XML-encoded data and stores the result in","the value pointed to by v, which must be an arbitrary struct,","slice, or string. Well-formed data that does not fit into v is","discarded.","","Because Unmarshal uses the reflect package, it can only assign","to exported (upper case) fields. Unmarshal uses a case-sensitive","comparison to match XML element names to tag values and struct","field names.","","Unmarshal maps an XML element to a struct using the following rules.","In the rules, the tag of a field refers to the value associated with the","key 'xml' in the struct field's tag (see the example above).","","  * If the struct has a field of type []byte or string with tag","     \",innerxml\", Unmarshal accumulates the raw XML nested inside the","     element in that field. The rest of the rules still apply.","","  * If the struct has a field named XMLName of type Name,","     Unmarshal records the element name in that field.","","  * If the XMLName field has an associated tag of the form","     \"name\" or \"namespace-URL name\", the XML element must have","     the given name (and, optionally, name space) or else Unmarshal","     returns an error.","","  * If the XML element has an attribute whose name matches a","     struct field name with an associated tag containing \",attr\" or","     the explicit name in a struct field tag of the form \"name,attr\",","     Unmarshal records the attribute value in that field.","","  * If the XML element has an attribute not handled by the previous","     rule and the struct has a field with an associated tag containing","     \",any,attr\", Unmarshal records the attribute value in the first","     such field.","","  * If the XML element contains character data, that data is","     accumulated in the first struct field that has tag \",chardata\".","     The struct field may have type []byte or string.","     If there is no such field, the character data is discarded.","","  * If the XML element contains comments, they are accumulated in","     the first struct field that has tag \",comment\".  The struct","     field may have type []byte or string. If there is no such","     field, the comments are discarded.","","  * If the XML element contains a sub-element whose name matches","     the prefix of a tag formatted as \"a\" or \"a\u003eb\u003ec\", unmarshal","     will descend into the XML structure looking for elements with the","     given names, and will map the innermost elements to that struct","     field. A tag starting with \"\u003e\" is equivalent to one starting","     with the field name followed by \"\u003e\".","","  * If the XML element contains a sub-element whose name matches","     a struct field's XMLName tag and the struct field has no","     explicit name tag as per the previous rule, unmarshal maps","     the sub-element to that struct field.","","  * If the XML element contains a sub-element whose name matches a","     field without any mode flags (\",attr\", \",chardata\", etc), Unmarshal","     maps the sub-element to that struct field.","","  * If the XML element contains a sub-element that hasn't matched any","     of the above rules and the struct has a field with tag \",any\",","     unmarshal maps the sub-element to that struct field.","","  * An anonymous struct field is handled as if the fields of its","     value were part of the outer struct.","","  * A struct field with tag \"-\" is never unmarshaled into.","","If Unmarshal encounters a field type that implements the Unmarshaler","interface, Unmarshal calls its UnmarshalXML method to produce the value from","the XML element.  Otherwise, if the value implements","encoding.TextUnmarshaler, Unmarshal calls that value's UnmarshalText method.","","Unmarshal maps an XML element to a string or []byte by saving the","concatenation of that element's character data in the string or","[]byte. The saved []byte is never nil.","","Unmarshal maps an attribute value to a string or []byte by saving","the value in the string or slice.","","Unmarshal maps an attribute value to an Attr by saving the attribute,","including its name, in the Attr.","","Unmarshal maps an XML element or attribute value to a slice by","extending the length of the slice and mapping the element or attribute","to the newly created value.","","Unmarshal maps an XML element or attribute value to a bool by","setting it to the boolean value represented by the string. Whitespace","is trimmed and ignored.","","Unmarshal maps an XML element or attribute value to an integer or","floating-point field by setting the field to the result of","interpreting the string value in decimal. There is no check for","overflow. Whitespace is trimmed and ignored.","","Unmarshal maps an XML element to a Name by recording the element","name.","","Unmarshal maps an XML element to a pointer by setting the pointer","to a freshly allocated value and then mapping the element to that value.","","A missing element or empty attribute value will be unmarshaled as a zero value.","If the field is a slice, a zero value will be appended to the field. Otherwise, the","field will be set to its zero value."],"Name":"Unmarshal","PkgPath":"encoding/xml","PkgName":"xml","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"data","TypeName":"byte","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":true},{"Identity":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"VarName":"v","TypeName":"interface{}","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]}],"TypeMethods":[{"CodeQL":{"IsEnabled":true,"Pointers":{"Inp":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"Outp":{"Placeholder":"isResult()","Element":"result","Index":0}}},"ClassName":"CharDataCopy","Docs":["Copy creates a new copy of CharData."],"IsOnPtr":false,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"from166","TypeName":"CharData","PkgName":"xml","PkgPath":"encoding/xml","QualifiedName":"encoding/xml.CharData","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-CharData-Copy","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Copy","Signature":"func (CharData).Copy() CharData","ID":"FunctionCopy","Docs":["Copy creates a new copy of CharData."],"Name":"Copy","PkgPath":"encoding/xml","PkgName":"xml","Parameters":null,"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"into136","TypeName":"CharData","PkgName":"xml","PkgPath":"encoding/xml","QualifiedName":"encoding/xml.CharData","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":true}]}},{"CodeQL":{"IsEnabled":true,"Pointers":{"Inp":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"Outp":{"Placeholder":"isResult()","Element":"result","Index":0}}},"ClassName":"CommentCopy","Docs":["Copy creates a new copy of Comment."],"IsOnPtr":false,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"from757","TypeName":"Comment","PkgName":"xml","PkgPath":"encoding/xml","QualifiedName":"encoding/xml.Comment","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Comment-Copy","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Copy","Signature":"func (Comment).Copy() Comment","ID":"FunctionCopy","Docs":["Copy creates a new copy of Comment."],"Name":"Copy","PkgPath":"encoding/xml","PkgName":"xml","Parameters":null,"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"into765","TypeName":"Comment","PkgName":"xml","PkgPath":"encoding/xml","QualifiedName":"encoding/xml.Comment","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":true}]}},{"CodeQL":{"IsEnabled":true,"Pointers":{"Inp":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"Outp":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0}}},"ClassName":"DecoderDecode","Docs":["Decode works like Unmarshal, except it reads the decoder","stream to find the start element."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"from111","TypeName":"Decoder","PkgName":"xml","PkgPath":"encoding/xml","QualifiedName":"encoding/xml.Decoder","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Decoder-Decode","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Decode","Signature":"func (*Decoder).Decode(v interface{}) error","ID":"FunctionDecode","Docs":["Decode works like Unmarshal, except it reads the decoder","stream to find the start element."],"Name":"Decode","PkgPath":"encoding/xml","PkgName":"xml","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"v","TypeName":"interface{}","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":true,"Pointers":{"Inp":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"Outp":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0}}},"ClassName":"DecoderDecodeElement","Docs":["DecodeElement works like Unmarshal except that it takes","a pointer to the start XML element to decode into v.","It is useful when a client reads some raw XML tokens itself","but also wants to defer to Unmarshal for some elements."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"from528","TypeName":"Decoder","PkgName":"xml","PkgPath":"encoding/xml","QualifiedName":"encoding/xml.Decoder","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Decoder-DecodeElement","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"DecodeElement","Signature":"func (*Decoder).DecodeElement(v interface{}, start *StartElement) error","ID":"FunctionDecodeElement","Docs":["DecodeElement works like Unmarshal except that it takes","a pointer to the start XML element to decode into v.","It is useful when a client reads some raw XML tokens itself","but also wants to defer to Unmarshal for some elements."],"Name":"DecodeElement","PkgPath":"encoding/xml","PkgName":"xml","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"v","TypeName":"interface{}","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"VarName":"start","TypeName":"StartElement","PkgName":"xml","PkgPath":"encoding/xml","QualifiedName":"encoding/xml.StartElement","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":true,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"DecoderInputOffset","Docs":["InputOffset returns the input stream byte offset of the current decoder position.","The offset gives the location of the end of the most recently returned token","and the beginning of the next token."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Decoder","PkgName":"xml","PkgPath":"encoding/xml","QualifiedName":"encoding/xml.Decoder","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Decoder-InputOffset","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"InputOffset","Signature":"func (*Decoder).InputOffset() int64","ID":"FunctionInputOffset","Docs":["InputOffset returns the input stream byte offset of the current decoder position.","The offset gives the location of the end of the most recently returned token","and the beginning of the next token."],"Name":"InputOffset","PkgPath":"encoding/xml","PkgName":"xml","Parameters":null,"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"int64","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":true,"Pointers":{"Inp":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"Outp":{"Placeholder":"isResult(0)","Element":"result","Index":0}}},"ClassName":"DecoderRawToken","Docs":["RawToken is like Token but does not verify that","start and end elements match and does not translate","name space prefixes to their corresponding URLs."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"from708","TypeName":"Decoder","PkgName":"xml","PkgPath":"encoding/xml","QualifiedName":"encoding/xml.Decoder","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Decoder-RawToken","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"RawToken","Signature":"func (*Decoder).RawToken() (Token, error)","ID":"FunctionRawToken","Docs":["RawToken is like Token but does not verify that","start and end elements match and does not translate","name space prefixes to their corresponding URLs."],"Name":"RawToken","PkgPath":"encoding/xml","PkgName":"xml","Parameters":null,"Results":[{"Identity":{"Placeholder":"isResult(0)","Element":"result","Index":0},"VarName":"into971","TypeName":"Token","PkgName":"xml","PkgPath":"encoding/xml","QualifiedName":"encoding/xml.Token","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isResult(1)","Element":"result","Index":1},"VarName":"","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"DecoderSkip","Docs":["Skip reads tokens until it has consumed the end element","matching the most recent start element already consumed.","It recurs if it encounters a start element, so it can be used to","skip nested structures.","It returns nil if it finds an end element matching the start","element; otherwise it returns an error describing the problem."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Decoder","PkgName":"xml","PkgPath":"encoding/xml","QualifiedName":"encoding/xml.Decoder","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Decoder-Skip","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Skip","Signature":"func (*Decoder).Skip() error","ID":"FunctionSkip","Docs":["Skip reads tokens until it has consumed the end element","matching the most recent start element already consumed.","It recurs if it encounters a start element, so it can be used to","skip nested structures.","It returns nil if it finds an end element matching the start","element; otherwise it returns an error describing the problem."],"Name":"Skip","PkgPath":"encoding/xml","PkgName":"xml","Parameters":null,"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":true,"Pointers":{"Inp":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"Outp":{"Placeholder":"isResult(0)","Element":"result","Index":0}}},"ClassName":"DecoderToken","Docs":["Token returns the next XML token in the input stream.","At the end of the input stream, Token returns nil, io.EOF.","","Slices of bytes in the returned token data refer to the","parser's internal buffer and remain valid only until the next","call to Token. To acquire a copy of the bytes, call CopyToken","or the token's Copy method.","","Token expands self-closing elements such as \u003cbr/\u003e","into separate start and end elements returned by successive calls.","","Token guarantees that the StartElement and EndElement","tokens it returns are properly nested and matched:","if Token encounters an unexpected end element","or EOF before all expected end elements,","it will return an error.","","Token implements XML name spaces as described by","https://www.w3.org/TR/REC-xml-names/.  Each of the","Name structures contained in the Token has the Space","set to the URL identifying its name space when known.","If Token encounters an unrecognized name space prefix,","it uses the prefix as the Space rather than report an error."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"from856","TypeName":"Decoder","PkgName":"xml","PkgPath":"encoding/xml","QualifiedName":"encoding/xml.Decoder","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Decoder-Token","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Token","Signature":"func (*Decoder).Token() (Token, error)","ID":"FunctionToken","Docs":["Token returns the next XML token in the input stream.","At the end of the input stream, Token returns nil, io.EOF.","","Slices of bytes in the returned token data refer to the","parser's internal buffer and remain valid only until the next","call to Token. To acquire a copy of the bytes, call CopyToken","or the token's Copy method.","","Token expands self-closing elements such as \u003cbr/\u003e","into separate start and end elements returned by successive calls.","","Token guarantees that the StartElement and EndElement","tokens it returns are properly nested and matched:","if Token encounters an unexpected end element","or EOF before all expected end elements,","it will return an error.","","Token implements XML name spaces as described by","https://www.w3.org/TR/REC-xml-names/.  Each of the","Name structures contained in the Token has the Space","set to the URL identifying its name space when known.","If Token encounters an unrecognized name space prefix,","it uses the prefix as the Space rather than report an error."],"Name":"Token","PkgPath":"encoding/xml","PkgName":"xml","Parameters":null,"Results":[{"Identity":{"Placeholder":"isResult(0)","Element":"result","Index":0},"VarName":"into830","TypeName":"Token","PkgName":"xml","PkgPath":"encoding/xml","QualifiedName":"encoding/xml.Token","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isResult(1)","Element":"result","Index":1},"VarName":"","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":true,"Pointers":{"Inp":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"Outp":{"Placeholder":"isResult()","Element":"result","Index":0}}},"ClassName":"DirectiveCopy","Docs":["Copy creates a new copy of Directive."],"IsOnPtr":false,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"from136","TypeName":"Directive","PkgName":"xml","PkgPath":"encoding/xml","QualifiedName":"encoding/xml.Directive","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Directive-Copy","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Copy","Signature":"func (Directive).Copy() Directive","ID":"FunctionCopy","Docs":["Copy creates a new copy of Directive."],"Name":"Copy","PkgPath":"encoding/xml","PkgName":"xml","Parameters":null,"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"into398","TypeName":"Directive","PkgName":"xml","PkgPath":"encoding/xml","QualifiedName":"encoding/xml.Directive","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":true}]}},{"CodeQL":{"IsEnabled":true,"Pointers":{"Inp":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"Outp":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1}}},"ClassName":"EncoderEncode","Docs":["Encode writes the XML encoding of v to the stream.","","See the documentation for Marshal for details about the conversion","of Go values to XML.","","Encode calls Flush before returning."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"into644","TypeName":"Encoder","PkgName":"xml","PkgPath":"encoding/xml","QualifiedName":"encoding/xml.Encoder","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Encoder-Encode","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Encode","Signature":"func (*Encoder).Encode(v interface{}) error","ID":"FunctionEncode","Docs":["Encode writes the XML encoding of v to the stream.","","See the documentation for Marshal for details about the conversion","of Go values to XML.","","Encode calls Flush before returning."],"Name":"Encode","PkgPath":"encoding/xml","PkgName":"xml","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"v","TypeName":"interface{}","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":true,"Pointers":{"Inp":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"Outp":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1}}},"ClassName":"EncoderEncodeElement","Docs":["EncodeElement writes the XML encoding of v to the stream,","using start as the outermost tag in the encoding.","","See the documentation for Marshal for details about the conversion","of Go values to XML.","","EncodeElement calls Flush before returning."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"into584","TypeName":"Encoder","PkgName":"xml","PkgPath":"encoding/xml","QualifiedName":"encoding/xml.Encoder","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Encoder-EncodeElement","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"EncodeElement","Signature":"func (*Encoder).EncodeElement(v interface{}, start StartElement) error","ID":"FunctionEncodeElement","Docs":["EncodeElement writes the XML encoding of v to the stream,","using start as the outermost tag in the encoding.","","See the documentation for Marshal for details about the conversion","of Go values to XML.","","EncodeElement calls Flush before returning."],"Name":"EncodeElement","PkgPath":"encoding/xml","PkgName":"xml","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"v","TypeName":"interface{}","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"VarName":"start","TypeName":"StartElement","PkgName":"xml","PkgPath":"encoding/xml","QualifiedName":"encoding/xml.StartElement","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":true,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":true,"Pointers":{"Inp":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"Outp":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1}}},"ClassName":"EncoderEncodeToken","Docs":["EncodeToken writes the given XML token to the stream.","It returns an error if StartElement and EndElement tokens are not properly matched.","","EncodeToken does not call Flush, because usually it is part of a larger operation","such as Encode or EncodeElement (or a custom Marshaler's MarshalXML invoked","during those), and those will call Flush when finished.","Callers that create an Encoder and then invoke EncodeToken directly, without","using Encode or EncodeElement, need to call Flush when finished to ensure","that the XML is written to the underlying writer.","","EncodeToken allows writing a ProcInst with Target set to \"xml\" only as the first token","in the stream."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"into340","TypeName":"Encoder","PkgName":"xml","PkgPath":"encoding/xml","QualifiedName":"encoding/xml.Encoder","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Encoder-EncodeToken","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"EncodeToken","Signature":"func (*Encoder).EncodeToken(t Token) error","ID":"FunctionEncodeToken","Docs":["EncodeToken writes the given XML token to the stream.","It returns an error if StartElement and EndElement tokens are not properly matched.","","EncodeToken does not call Flush, because usually it is part of a larger operation","such as Encode or EncodeElement (or a custom Marshaler's MarshalXML invoked","during those), and those will call Flush when finished.","Callers that create an Encoder and then invoke EncodeToken directly, without","using Encode or EncodeElement, need to call Flush when finished to ensure","that the XML is written to the underlying writer.","","EncodeToken allows writing a ProcInst with Target set to \"xml\" only as the first token","in the stream."],"Name":"EncodeToken","PkgPath":"encoding/xml","PkgName":"xml","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"t","TypeName":"Token","PkgName":"xml","PkgPath":"encoding/xml","QualifiedName":"encoding/xml.Token","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"EncoderFlush","Docs":["Flush flushes any buffered XML to the underlying writer.","See the EncodeToken documentation for details about when it is necessary."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Encoder","PkgName":"xml","PkgPath":"encoding/xml","QualifiedName":"encoding/xml.Encoder","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Encoder-Flush","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Flush","Signature":"func (*Encoder).Flush() error","ID":"FunctionFlush","Docs":["Flush flushes any buffered XML to the underlying writer.","See the EncodeToken documentation for details about when it is necessary."],"Name":"Flush","PkgPath":"encoding/xml","PkgName":"xml","Parameters":null,"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"EncoderIndent","Docs":["Indent sets the encoder to generate XML in which each element","begins on a new indented line that starts with prefix and is followed by","one or more copies of indent according to the nesting depth."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Encoder","PkgName":"xml","PkgPath":"encoding/xml","QualifiedName":"encoding/xml.Encoder","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Encoder-Indent","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Indent","Signature":"func (*Encoder).Indent(prefix string, indent string)","ID":"FunctionIndent","Docs":["Indent sets the encoder to generate XML in which each element","begins on a new indented line that starts with prefix and is followed by","one or more copies of indent according to the nesting depth."],"Name":"Indent","PkgPath":"encoding/xml","PkgName":"xml","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"prefix","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"VarName":"indent","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}],"Results":null}},{"CodeQL":{"IsEnabled":true,"Pointers":{"Inp":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"Outp":{"Placeholder":"isResult()","Element":"result","Index":0}}},"ClassName":"ProcInstCopy","Docs":["Copy creates a new copy of ProcInst."],"IsOnPtr":false,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"from255","TypeName":"ProcInst","PkgName":"xml","PkgPath":"encoding/xml","QualifiedName":"encoding/xml.ProcInst","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-ProcInst-Copy","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Copy","Signature":"func (ProcInst).Copy() ProcInst","ID":"FunctionCopy","Docs":["Copy creates a new copy of ProcInst."],"Name":"Copy","PkgPath":"encoding/xml","PkgName":"xml","Parameters":null,"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"into763","TypeName":"ProcInst","PkgName":"xml","PkgPath":"encoding/xml","QualifiedName":"encoding/xml.ProcInst","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":true,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":true,"Pointers":{"Inp":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"Outp":{"Placeholder":"isResult()","Element":"result","Index":0}}},"ClassName":"StartElementCopy","Docs":["Copy creates a new copy of StartElement."],"IsOnPtr":false,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"from676","TypeName":"StartElement","PkgName":"xml","PkgPath":"encoding/xml","QualifiedName":"encoding/xml.StartElement","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-StartElement-Copy","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Copy","Signature":"func (StartElement).Copy() StartElement","ID":"FunctionCopy","Docs":["Copy creates a new copy of StartElement."],"Name":"Copy","PkgPath":"encoding/xml","PkgName":"xml","Parameters":null,"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"into130","TypeName":"StartElement","PkgName":"xml","PkgPath":"encoding/xml","QualifiedName":"encoding/xml.StartElement","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":true,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"Outp":{"Placeholder":"isResult()","Element":"result","Index":0}}},"ClassName":"StartElementEnd","Docs":["End returns the corresponding XML end element."],"IsOnPtr":false,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"from744","TypeName":"StartElement","PkgName":"xml","PkgPath":"encoding/xml","QualifiedName":"encoding/xml.StartElement","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-StartElement-End","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"End","Signature":"func (StartElement).End() EndElement","ID":"FunctionEnd","Docs":["End returns the corresponding XML end element."],"Name":"End","PkgPath":"encoding/xml","PkgName":"xml","Parameters":null,"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"into379","TypeName":"EndElement","PkgName":"xml","PkgPath":"encoding/xml","QualifiedName":"encoding/xml.EndElement","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":true,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"SyntaxErrorError","Docs":[],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"SyntaxError","PkgName":"xml","PkgPath":"encoding/xml","QualifiedName":"encoding/xml.SyntaxError","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-SyntaxError-Error","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Error","Signature":"func (*SyntaxError).Error() string","ID":"FunctionError","Docs":[],"Name":"Error","PkgPath":"encoding/xml","PkgName":"xml","Parameters":null,"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"TagPathErrorError","Docs":[],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"TagPathError","PkgName":"xml","PkgPath":"encoding/xml","QualifiedName":"encoding/xml.TagPathError","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-TagPathError-Error","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Error","Signature":"func (*TagPathError).Error() string","ID":"FunctionError","Docs":[],"Name":"Error","PkgPath":"encoding/xml","PkgName":"xml","Parameters":null,"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"UnmarshalErrorError","Docs":[],"IsOnPtr":false,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"UnmarshalError","PkgName":"xml","PkgPath":"encoding/xml","QualifiedName":"encoding/xml.UnmarshalError","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-UnmarshalError-Error","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Error","Signature":"func (UnmarshalError).Error() string","ID":"FunctionError","Docs":[],"Name":"Error","PkgPath":"encoding/xml","PkgName":"xml","Parameters":null,"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"UnsupportedTypeErrorError","Docs":[],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"UnsupportedTypeError","PkgName":"xml","PkgPath":"encoding/xml","QualifiedName":"encoding/xml.UnsupportedTypeError","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-UnsupportedTypeError-Error","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Error","Signature":"func (*UnsupportedTypeError).Error() string","ID":"FunctionError","Docs":[],"Name":"Error","PkgPath":"encoding/xml","PkgName":"xml","Parameters":null,"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"string","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}]}}],"InterfaceMethods":[{"CodeQL":{"IsEnabled":true,"Pointers":{"Inp":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"Outp":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0}}},"ClassName":"MarshalerMarshalXML","Docs":[],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"from671","TypeName":"Marshaler","PkgName":"xml","PkgPath":"encoding/xml","QualifiedName":"encoding/xml.MarshalXML","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"interface-method-Marshaler-MarshalXML","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"MarshalXML","Signature":"func (Marshaler).MarshalXML(e *Encoder, start StartElement) error","ID":"FunctionMarshalXML","Docs":[],"Name":"MarshalXML","PkgPath":"encoding/xml","PkgName":"xml","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"e","TypeName":"Encoder","PkgName":"xml","PkgPath":"encoding/xml","QualifiedName":"encoding/xml.Encoder","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":true,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"VarName":"start","TypeName":"StartElement","PkgName":"xml","PkgPath":"encoding/xml","QualifiedName":"encoding/xml.StartElement","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":true,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"MarshalerAttrMarshalXMLAttr","Docs":[],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"MarshalerAttr","PkgName":"xml","PkgPath":"encoding/xml","QualifiedName":"encoding/xml.MarshalXMLAttr","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"interface-method-MarshalerAttr-MarshalXMLAttr","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"MarshalXMLAttr","Signature":"func (MarshalerAttr).MarshalXMLAttr(name Name) (Attr, error)","ID":"FunctionMarshalXMLAttr","Docs":[],"Name":"MarshalXMLAttr","PkgPath":"encoding/xml","PkgName":"xml","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"name","TypeName":"Name","PkgName":"xml","PkgPath":"encoding/xml","QualifiedName":"encoding/xml.Name","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":true,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult(0)","Element":"result","Index":0},"VarName":"","TypeName":"Attr","PkgName":"xml","PkgPath":"encoding/xml","QualifiedName":"encoding/xml.Attr","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":true,"IsRepeated":false},{"Identity":{"Placeholder":"isResult(1)","Element":"result","Index":1},"VarName":"","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":true,"Pointers":{"Inp":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"Outp":{"Placeholder":"isResult(0)","Element":"result","Index":0}}},"ClassName":"TokenReaderToken","Docs":[],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"from914","TypeName":"TokenReader","PkgName":"xml","PkgPath":"encoding/xml","QualifiedName":"encoding/xml.Token","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"interface-method-TokenReader-Token","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Token","Signature":"func (TokenReader).Token() (Token, error)","ID":"FunctionToken","Docs":[],"Name":"Token","PkgPath":"encoding/xml","PkgName":"xml","Parameters":null,"Results":[{"Identity":{"Placeholder":"isResult(0)","Element":"result","Index":0},"VarName":"into415","TypeName":"Token","PkgName":"xml","PkgPath":"encoding/xml","QualifiedName":"encoding/xml.Token","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isResult(1)","Element":"result","Index":1},"VarName":"","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":true,"Pointers":{"Inp":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"Outp":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1}}},"ClassName":"UnmarshalerUnmarshalXML","Docs":[],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"into259","TypeName":"Unmarshaler","PkgName":"xml","PkgPath":"encoding/xml","QualifiedName":"encoding/xml.UnmarshalXML","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"interface-method-Unmarshaler-UnmarshalXML","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"UnmarshalXML","Signature":"func (Unmarshaler).UnmarshalXML(d *Decoder, start StartElement) error","ID":"FunctionUnmarshalXML","Docs":[],"Name":"UnmarshalXML","PkgPath":"encoding/xml","PkgName":"xml","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"d","TypeName":"Decoder","PkgName":"xml","PkgPath":"encoding/xml","QualifiedName":"encoding/xml.Decoder","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":true,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"VarName":"start","TypeName":"StartElement","PkgName":"xml","PkgPath":"encoding/xml","QualifiedName":"encoding/xml.StartElement","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":true,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"UnmarshalerAttrUnmarshalXMLAttr","Docs":[],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"UnmarshalerAttr","PkgName":"xml","PkgPath":"encoding/xml","QualifiedName":"encoding/xml.UnmarshalXMLAttr","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"interface-method-UnmarshalerAttr-UnmarshalXMLAttr","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"UnmarshalXMLAttr","Signature":"func (UnmarshalerAttr).UnmarshalXMLAttr(attr Attr) error","ID":"FunctionUnmarshalXMLAttr","Docs":[],"Name":"UnmarshalXMLAttr","PkgPath":"encoding/xml","PkgName":"xml","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"attr","TypeName":"Attr","PkgName":"xml","PkgPath":"encoding/xml","QualifiedName":"encoding/xml.Attr","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":true,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]}}]}