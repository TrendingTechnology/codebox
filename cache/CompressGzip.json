{"Name":"gzip","PkgPath":"compress/gzip","PkgName":"gzip","ID":"compress/gzip","Funcs":[{"CodeQL":{"IsEnabled":true,"Pointers":{"Inp":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"Outp":{"Placeholder":"isResult(0)","Element":"result","Index":0}}},"ClassName":"NewReader","Signature":"func NewReader(r io.Reader) (*Reader, error)","ID":"FunctionNewReader","Docs":["NewReader creates a new Reader reading the given reader.","If r does not also implement io.ByteReader,","the decompressor may read more data than necessary from r.","","It is the caller's responsibility to call Close on the Reader when done.","","The Reader.Header fields will be valid in the Reader returned."],"Name":"NewReader","PkgPath":"compress/gzip","PkgName":"gzip","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"r","TypeName":"Reader","PkgName":"io","PkgPath":"io","QualifiedName":"io.Reader","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult(0)","Element":"result","Index":0},"VarName":"into423","TypeName":"Reader","PkgName":"gzip","PkgPath":"compress/gzip","QualifiedName":"compress/gzip.Reader","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":true,"IsRepeated":false},{"Identity":{"Placeholder":"isResult(1)","Element":"result","Index":1},"VarName":"","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]},{"CodeQL":{"IsEnabled":true,"Pointers":{"Inp":{"Placeholder":"isResult()","Element":"result","Index":0},"Outp":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0}}},"ClassName":"NewWriter","Signature":"func NewWriter(w io.Writer) *Writer","ID":"FunctionNewWriter","Docs":["NewWriter returns a new Writer.","Writes to the returned writer are compressed and written to w.","","It is the caller's responsibility to call Close on the Writer when done.","Writes may be buffered and not flushed until Close.","","Callers that wish to set the fields in Writer.Header must do so before","the first call to Write, Flush, or Close."],"Name":"NewWriter","PkgPath":"compress/gzip","PkgName":"gzip","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"w","TypeName":"Writer","PkgName":"io","PkgPath":"io","QualifiedName":"io.Writer","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"from706","TypeName":"Writer","PkgName":"gzip","PkgPath":"compress/gzip","QualifiedName":"compress/gzip.Writer","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":true,"IsRepeated":false}]},{"CodeQL":{"IsEnabled":true,"Pointers":{"Inp":{"Placeholder":"isResult(0)","Element":"result","Index":0},"Outp":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0}}},"ClassName":"NewWriterLevel","Signature":"func NewWriterLevel(w io.Writer, level int) (*Writer, error)","ID":"FunctionNewWriterLevel","Docs":["NewWriterLevel is like NewWriter but specifies the compression level instead","of assuming DefaultCompression.","","The compression level can be DefaultCompression, NoCompression, HuffmanOnly","or any integer value between BestSpeed and BestCompression inclusive.","The error returned will be nil if the level is valid."],"Name":"NewWriterLevel","PkgPath":"compress/gzip","PkgName":"gzip","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"w","TypeName":"Writer","PkgName":"io","PkgPath":"io","QualifiedName":"io.Writer","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isParameter(1)","Element":"parameter","Index":1},"VarName":"level","TypeName":"int","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult(0)","Element":"result","Index":0},"VarName":"from682","TypeName":"Writer","PkgName":"gzip","PkgPath":"compress/gzip","QualifiedName":"compress/gzip.Writer","IsPtr":true,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":true,"IsRepeated":false},{"Identity":{"Placeholder":"isResult(1)","Element":"result","Index":1},"VarName":"","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]}],"TypeMethods":[{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"ReaderClose","Docs":["Close closes the Reader. It does not close the underlying io.Reader.","In order for the GZIP checksum to be verified, the reader must be","fully consumed until the io.EOF."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Reader","PkgName":"gzip","PkgPath":"compress/gzip","QualifiedName":"compress/gzip.Reader","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Reader-Close","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Close","Signature":"func (*Reader).Close() error","ID":"FunctionClose","Docs":["Close closes the Reader. It does not close the underlying io.Reader.","In order for the GZIP checksum to be verified, the reader must be","fully consumed until the io.EOF."],"Name":"Close","PkgPath":"compress/gzip","PkgName":"gzip","Parameters":null,"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"ReaderMultistream","Docs":["Multistream controls whether the reader supports multistream files.","","If enabled (the default), the Reader expects the input to be a sequence","of individually gzipped data streams, each with its own header and","trailer, ending at EOF. The effect is that the concatenation of a sequence","of gzipped files is treated as equivalent to the gzip of the concatenation","of the sequence. This is standard behavior for gzip readers.","","Calling Multistream(false) disables this behavior; disabling the behavior","can be useful when reading file formats that distinguish individual gzip","data streams or mix gzip data streams with other data streams.","In this mode, when the Reader reaches the end of the data stream,","Read returns io.EOF. The underlying reader must implement io.ByteReader","in order to be left positioned just after the gzip stream.","To start the next stream, call z.Reset(r) followed by z.Multistream(false).","If there is no next stream, z.Reset(r) will return io.EOF."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Reader","PkgName":"gzip","PkgPath":"compress/gzip","QualifiedName":"compress/gzip.Reader","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Reader-Multistream","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Multistream","Signature":"func (*Reader).Multistream(ok bool)","ID":"FunctionMultistream","Docs":["Multistream controls whether the reader supports multistream files.","","If enabled (the default), the Reader expects the input to be a sequence","of individually gzipped data streams, each with its own header and","trailer, ending at EOF. The effect is that the concatenation of a sequence","of gzipped files is treated as equivalent to the gzip of the concatenation","of the sequence. This is standard behavior for gzip readers.","","Calling Multistream(false) disables this behavior; disabling the behavior","can be useful when reading file formats that distinguish individual gzip","data streams or mix gzip data streams with other data streams.","In this mode, when the Reader reaches the end of the data stream,","Read returns io.EOF. The underlying reader must implement io.ByteReader","in order to be left positioned just after the gzip stream.","To start the next stream, call z.Reset(r) followed by z.Multistream(false).","If there is no next stream, z.Reset(r) will return io.EOF."],"Name":"Multistream","PkgPath":"compress/gzip","PkgName":"gzip","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"ok","TypeName":"bool","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false}],"Results":null}},{"CodeQL":{"IsEnabled":true,"Pointers":{"Inp":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"Outp":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0}}},"ClassName":"ReaderRead","Docs":["Read implements io.Reader, reading uncompressed bytes from its underlying Reader."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"from661","TypeName":"Reader","PkgName":"gzip","PkgPath":"compress/gzip","QualifiedName":"compress/gzip.Reader","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Reader-Read","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Read","Signature":"func (*Reader).Read(p []byte) (n int, err error)","ID":"FunctionRead","Docs":["Read implements io.Reader, reading uncompressed bytes from its underlying Reader."],"Name":"Read","PkgPath":"compress/gzip","PkgName":"gzip","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"p","TypeName":"byte","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":true}],"Results":[{"Identity":{"Placeholder":"isResult(0)","Element":"result","Index":0},"VarName":"n","TypeName":"int","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isResult(1)","Element":"result","Index":1},"VarName":"err","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":true,"Pointers":{"Inp":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"Outp":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1}}},"ClassName":"ReaderReset","Docs":["Reset discards the Reader z's state and makes it equivalent to the","result of its original state from NewReader, but reading from r instead.","This permits reusing a Reader rather than allocating a new one."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"into719","TypeName":"Reader","PkgName":"gzip","PkgPath":"compress/gzip","QualifiedName":"compress/gzip.Reader","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Reader-Reset","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Reset","Signature":"func (*Reader).Reset(r io.Reader) error","ID":"FunctionReset","Docs":["Reset discards the Reader z's state and makes it equivalent to the","result of its original state from NewReader, but reading from r instead.","This permits reusing a Reader rather than allocating a new one."],"Name":"Reset","PkgPath":"compress/gzip","PkgName":"gzip","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"r","TypeName":"Reader","PkgName":"io","PkgPath":"io","QualifiedName":"io.Reader","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}],"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"WriterClose","Docs":["Close closes the Writer by flushing any unwritten data to the underlying","io.Writer and writing the GZIP footer.","It does not close the underlying io.Writer."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Writer","PkgName":"gzip","PkgPath":"compress/gzip","QualifiedName":"compress/gzip.Writer","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Writer-Close","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Close","Signature":"func (*Writer).Close() error","ID":"FunctionClose","Docs":["Close closes the Writer by flushing any unwritten data to the underlying","io.Writer and writing the GZIP footer.","It does not close the underlying io.Writer."],"Name":"Close","PkgPath":"compress/gzip","PkgName":"gzip","Parameters":null,"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"WriterFlush","Docs":["Flush flushes any pending compressed data to the underlying writer.","","It is useful mainly in compressed network protocols, to ensure that","a remote reader has enough data to reconstruct a packet. Flush does","not return until the data has been written. If the underlying","writer returns an error, Flush returns that error.","","In the terminology of the zlib library, Flush is equivalent to Z_SYNC_FLUSH."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"","TypeName":"Writer","PkgName":"gzip","PkgPath":"compress/gzip","QualifiedName":"compress/gzip.Writer","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Writer-Flush","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Flush","Signature":"func (*Writer).Flush() error","ID":"FunctionFlush","Docs":["Flush flushes any pending compressed data to the underlying writer.","","It is useful mainly in compressed network protocols, to ensure that","a remote reader has enough data to reconstruct a packet. Flush does","not return until the data has been written. If the underlying","writer returns an error, Flush returns that error.","","In the terminology of the zlib library, Flush is equivalent to Z_SYNC_FLUSH."],"Name":"Flush","PkgPath":"compress/gzip","PkgName":"gzip","Parameters":null,"Results":[{"Identity":{"Placeholder":"isResult()","Element":"result","Index":0},"VarName":"","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]}},{"CodeQL":{"IsEnabled":true,"Pointers":{"Inp":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"Outp":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0}}},"ClassName":"WriterReset","Docs":["Reset discards the Writer z's state and makes it equivalent to the","result of its original state from NewWriter or NewWriterLevel, but","writing to w instead. This permits reusing a Writer rather than","allocating a new one."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"into457","TypeName":"Writer","PkgName":"gzip","PkgPath":"compress/gzip","QualifiedName":"compress/gzip.Writer","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Writer-Reset","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Reset","Signature":"func (*Writer).Reset(w io.Writer)","ID":"FunctionReset","Docs":["Reset discards the Writer z's state and makes it equivalent to the","result of its original state from NewWriter or NewWriterLevel, but","writing to w instead. This permits reusing a Writer rather than","allocating a new one."],"Name":"Reset","PkgPath":"compress/gzip","PkgName":"gzip","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"w","TypeName":"Writer","PkgName":"io","PkgPath":"io","QualifiedName":"io.Writer","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}],"Results":null}},{"CodeQL":{"IsEnabled":true,"Pointers":{"Inp":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"Outp":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1}}},"ClassName":"WriterWrite","Docs":["Write writes a compressed form of p to the underlying io.Writer. The","compressed bytes are not necessarily flushed until the Writer is closed."],"IsOnPtr":true,"Receiver":{"Identity":{"Placeholder":"isReceiver()","Element":"receiver","Index":-1},"VarName":"into857","TypeName":"Writer","PkgName":"gzip","PkgPath":"compress/gzip","QualifiedName":"compress/gzip.Writer","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},"ID":"type-method-Writer-Write","Func":{"CodeQL":{"IsEnabled":false,"Pointers":{"Inp":{"Placeholder":"TODO","Element":"TODO","Index":-1},"Outp":{"Placeholder":"TODO","Element":"TODO","Index":-1}}},"ClassName":"Write","Signature":"func (*Writer).Write(p []byte) (int, error)","ID":"FunctionWrite","Docs":["Write writes a compressed form of p to the underlying io.Writer. The","compressed bytes are not necessarily flushed until the Writer is closed."],"Name":"Write","PkgPath":"compress/gzip","PkgName":"gzip","Parameters":[{"Identity":{"Placeholder":"isParameter(0)","Element":"parameter","Index":0},"VarName":"p","TypeName":"byte","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":true}],"Results":[{"Identity":{"Placeholder":"isResult(0)","Element":"result","Index":0},"VarName":"","TypeName":"int","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":true,"IsVariadic":false,"IsNullable":false,"IsStruct":false,"IsRepeated":false},{"Identity":{"Placeholder":"isResult(1)","Element":"result","Index":1},"VarName":"","TypeName":"error","PkgName":"","PkgPath":"","QualifiedName":"","IsPtr":false,"IsBasic":false,"IsVariadic":false,"IsNullable":true,"IsStruct":false,"IsRepeated":false}]}}],"InterfaceMethods":[]}